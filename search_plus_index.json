{"./":{"url":"./","title":"简介","keywords":"","body":"xinwuyun的笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/about.html":{"url":"database/about.html","title":"数据库笔记","keywords":"","body":"数据库笔记 CH1 CH2 CH3 CH4 CH5 CH6 CH7 CH8 CH9 CH10 CH11 CH12 CH13 CH14 CH15 并发控制 ch16 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch1.html":{"url":"database/ch1.html","title":"CH1","keywords":"","body":"第一章 一、Data Models and Databases 抽象层次 Levels of Abstraction 物理层Phsical Level：描述数据如何存储 逻辑层Logical Level：描述数据库中存储什么数据以及数据间的关系。 物理数据独立性（phicial data indepentdence） 视图层View Level：描述整个数据库的某个部分 例子 定义如下记录 type instructor = record ID: char(5) name: char(20) dept_name: char(20) salary: numberic(8, 2) end; 物理层：instructor记录可能被描述为连续存储位置组成的存储块。 逻辑层：定义了这些记录类型的相互关系 程序设计人员正式在这个抽象层次上使用某种程序设计语言进行工作。 数据库管理员也是在这个抽象层次工作。 视图层：计算机用户看见的是为其屏蔽了数据类型细节的一组应用程序 视图层上定义了数据库的多个视图，数据库用户看到的是这些视图。 提供了防止用户访问数据库的某些部分的安全性机制 二、实例和模式 实例 特定时刻存储在数据库中的信息的集合称作数据库的一个实例。 模式 数据库的总体设计 物理模式 physical schema 物理层描述数据库的设计 逻辑模式 logical schema 在逻辑层描述数据库的设计 视图层模式 有若干种，有时称为子模式（subschema） 描述了数据库的不同视图 逻辑层最重要，物理模式隐藏在逻辑模式下，通常可以轻易被更改应用程序如果不依赖与物理模式，他们就被称为具有物理数据独立性 三、数据模型 data model 是一个 描述数据 数据联系 数据语义 以及一致性约束 的概念工具集合 提供了一种描述 物理层 逻辑层 视图层 的数据库设计的方式 关系模型 rational model 关系模型用表的集合来表示数据和数据间的联系。 实体-联系模型 entity-relationship model ER模型，基于对显示世界的这样一种认识 现实世界由一组称作实体的基本对象以及这些对象间的联系构成。实体是现实世界中可区别于 基于对象的数据模型 object-based model ER模型增加了封装、方法和对象标识等概念后的扩展。 半结构化数据模型 semistructured data model（XML） 允许那些相同类型的数据项含有不同的属性集的数据定义。XML被广泛用来标识半结构化数据。 四、关系数据库 关系数据库包括DML和DDL。 表 所有数据都存放在若干表中 数据操纵语言 DML Data-Manipulation Language DML中设计信息检索的部分称作查询语言（query language）。通常把查询语言和数据操纵语言作为同义词 非过程化的，以几个表作为输入，总是仅返回一个表。 数据定义语言 DDL Data-Defination Language 可以定义表、完整性约束、断言和授权等。 元数据：metadata，关于数据的数据。只能由数据库系统本身来访问和修改 五、Database Design 设计过程 初始阶段：全面刻画预期的数据库 概念设计**conceptual-design**：描述数据以及他们之间的关系 ER模型 规范化算法，将所有属性集所谓输入，生成一组关系表 逻辑设计阶段：将高层的概念模型映射到要使用的数据库系统的实现数据模型上 物理设计阶段指定物理特性，包括文件组织的形式以及内部的存储结构 六、数据库引擎 存储管理器（storage manager） 查询处理器（query processing） 事务管理（transaction manager） 存储管理器 storage manager 存储管理器在数据库中存储的底层数据与应用数据以及向系统提交的查询之间提供接口的部件； 存储管理器负责与文件管理器进行交互，原始数据通过操作系统提供的文件系统存储在磁盘上； 存储管理器将各种DML语句翻译为底层文件系统命令。 存储管理器负责数据库中数据的存储、检索和更新 权限及完整性管理器 事务管理器 文件管理器 缓冲器管理器 实现了几种数据结构 数据文件：数据库自身 数据字典：关于数据库结构的元数据，尤其是数据库模式 索引：针对数据项的快速访问 查询处理器 DDL解释器（DDL interpreter），解释DDL语句并将这些定义记录在数据字典里 DML编译器（DMLcompiler），将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令 一个查询通常可被翻译成多中等价的具有相同结果的执行方案的一种，DML编译器还进行查询优化，从几种选择汇总选出代价最小的一种 查询执行引擎（query evaluation engine），执行由DML编译器产生的低级指令。 事务管理 原子性 atomicity 一致性 consistency 持久性 durability 事务transaction是数据库应用中完成单一逻辑功能的操作集合。 每个事务是一个具有原子性和一致性的单元。我们要求单元不违反任何数据库的一致性约束。但是执行过程中，必要时允许暂时的不一致。 原子性和一致性是恢复管理器recovery manager的职责。 为了保证原子性，失败的事务必须对数据库状态不产生任何影响，数据库必须被恢复到该失败事务开始执行之前的状态。这种情况下数据库系统必须进行故障恢复failure recovery。 并发控制管理器concurrency-control manager，控制并发事务间的相互影响，保证数据一致性 事务管理器transaction manager包括并发控制管理器和恢复管理器 数据库体系结构 数据库架构很大程度上取决于所运行的操作系统 集中式 客户端-服务器的 并行的 分布式的 数据库史 50~60年代 磁带用于数据存储，只能顺序读取。 60年代末~70年代 摆脱了顺序访问的限制，可以将表和数保存在磁盘上。 关系模型和查询数据的非过程化方法出现。关系型数据库诞生 80年代 关系型数据库真正应用，取代了网状和层次型数据库。 程序猿只需要考虑逻辑层的工作。 90年代初 许多厂商推出了并行数据库产品。 90年代 互联网的爆发式发展。数据库系统需要提高事务处理速度和高可靠性，提供对数据的web接口 2010年前 XML兴起。开源数据库系统应用显著增长——PostgreSQL和MySql 至今 用于数据分析的数据库。 按列存储的列存储数据库 高度并行的数据库 分布式数据库 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch2.html":{"url":"database/ch2.html","title":"CH2","keywords":"","body":"第二章 关系模型 [toc] 一、Structure of relational database 关系数据库的结构 关系数据库由表的集合组成，每个表有唯一的名字。 关系——表 元组——行 属性——列 关系实例——一个关系的特定实例 域——属性的取值范围 数据库模式 需要区分数据库模式和数据库实例（database） 前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照。 关系实例的内容经常变化，关系模式不经常变化。 码keys 一个元组的属性值必须能够唯一区分元组。 一个关系中没有两个元组在所有属性上取值相同 超码 superkey 一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地确定一个元组。 形式化描述：设R表示关系r模式中的属性集合，如果R的一个子集K是r的一个超码，则关系r中任意两个不同元组不会在K的所有属性上取值完全相等。 超码中可能包含无关紧要的属性。如果K是一个超码，则K的任意超集也是超码。 最小超码称为候选码 candidate key，他们的任意真子集 主码 primary key 表示被数据库设计者选中，用来在关系中区分不同元组的候选码。 外码 foreign key 一个关系模式$r_1$可能在它的属性中包括另一个关系模式$r_2$的主码。 关系$r_1$也称为外码依赖的参照关系（referencing realtion），$r_2$称为外码的被参照关系（referenced relation）。 参照完整性 referential integrity constraint 要求在参照关系任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值 二、关系查询语言 查询语言（query language）是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化和非过程化的 过程化语言（procedural language） 用户指导系统对数据库执行一系列操作以计算出所需结果。 非过程化语言（nonprocedural language） 用户只需描述所需信息，不用给出获取该信息的具体过程 三、关系运算 关系运算是过程化语言，有如下6个运算 select（选择）：$\\sigma$ project（投影）：$\\pi$ union（并）：$\\cup$ set difference（集合差）：$-$ cartesian product（笛卡尔积）：$\\times$ rename：$\\rho$ select 选择 $\\sigma_{p}(r)$ $p$是选择谓词 \\sigma_{p}(r)=\\{t \\mid t \\in r \\text { and } p(t)\\} project 投影 Union并 按行并 r和s必须有相同的属性 属性的domain必须是compatible可兼容的 笛卡尔积 $r\\times s$ $\\rho$ 四、例子 五、额外操作符 set intersection（集合交） natural join（自然连接） division（除法） 集合交 与union同等级 r \\cap S=\\{t \\mid t \\in r \\wedge t \\in S\\} r \\cap s=r-(r-s)$ 连接 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch3.html":{"url":"database/ch3.html","title":"CH3","keywords":"","body":"第三章 SQL 一、SQL查询语言概览 SQL包含一下部分 数据定义语言（data-defination language，DDL）：提供定义关系模式、删除关系以及修改关系模式的命令 数据操纵语言（data-manipulation language，DML） 插入元祖 删除元组 修改元组 完整性（integrity） DDL包括定义完整性约束的命令 破坏完整性约束的更新是不允许 视图定义（view defination） DDL定义视图的命令 事务控制（transaction control） SQL包括定义事务的开始或结束的命令 嵌入式SQL和动态SQL（embedded SQL and dynamic SQL） Embedded sql and dynamic sql如何嵌入到通用编程语言，如C、C++和java 授权（authorization） DDL包括定义对关系和视图的访问权限命令 基本类型 每种类型都可能包含一个被称作空值的特殊值。 该值可能存在但并不为人所知，可能根本不存在 create table construct create table r(A1D1, A2D2, ..., AnDn, integrity-constraint1, ... integrity-constraintk) integrity constraints完整性约束 not null Primary key($A_1, ..., A_n$) Foreign key($A_m,...,A_n$) references r create table instructor( ID char(5), name varchar(20) not null, dept_name varchar(20), salary varchar(20), salary numeric(8,2), primary key(ID), foreign key(dept_name) references department); primary key自动保证字段为not null Integrity Constraints in Tables表的完整性约束 完整性约束保证数据库的修改不会导致数据一致性的丢失 primary key foreign key [not] null unique default check assertion update insert insert into instructor values(.....) delete delete from student where... drop table alter alter table r add A D A是attribute D是domain alter table r drop A SQL查询的基本结构 结果也是一个关系 执行顺序 select语句 大小写不敏感 \\text { Name } \\equiv N A M E \\equiv \\text { name } 结果的元组重复 allow duplicates in relations as well as in query results. 允许query结果中存在重复元组 force elimination of duplicates, 在select后添加distinct select distinct dept_name from instructor 使用all关键字显示保留重复值 select all dept_name from instructor 星号 asterisk asterisk * 表示all attributes select * from instructor 属性可以是字面值 没有from语句 select '457' 结果是一个一行一列的表，值为'457' 可以给列命名 select '233' as FOO 使用from语句 select 'A' from instructor 结果一列n行（n是instructor表的行数） 每一行的值都会“A” 可以使用算术表达式 select ID, name, salary/12 from instructor 返回的relation中salary属性的值均除以12 可以对该字段进行重命名 select ID, name, salary/12 as monthly_salary where语句 from语句 rename operation select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name = 'Comp.Sci' 自连接例子 find the supervisor of the supervisor of \"Bob\" select S.supervisor from emp_super as T, emp_super as S where T.person = 'Bob' and T.supervisor = S.person like percent%：匹配任意子串 underscore_：匹配任意字符 Find the names of all instructors whose name includes the substring \"dar\" select name from instructor where name like \"%dar%\" 如果匹配字符串“100%” like '100\\%' escape '\\' Esacpe '\\'指定转义字符 是大小写敏感的 排序 select distinct name from instructor order by name 指定顺序逆序 desc 降序 asc 升序 order by name desc 根据多个属性排序 order by dept_nam, name 重复 集合操作 union：并 intersect：交 except：差 上述操作默认消除重复元组，使用union\\intersect\\except all保留重复 集合操作例子 题目：找出最高的工资 找出工资不是最高的instructor的工资 select distinct T.salary from instructor as S, instructor as T where T.salary 用总体的减去上述结果 (select distinct salary from instructor) except (select distinct T.salary from instructor as T, instructor as S where T.salary Null values null表示未知值或不存在的值 任何包含null的数学表达式的结果都是null is null可以用来检查null值 example Find all instructors whose salary is null select name from instructor where salary is null unknown 三个逻辑值 true false unknown 任何与null值进行的比较都返回unknown example：5 null or null = null 对于上述操作，令unknown为true或false，如果得到结果一致，则结果是对应结果，如果结果不一致，则结果是unknown 聚合函数 avg min max sum count group by 找出每个学院教师的平均工资 select dept_name avg(salary) as avg_salary from instructor group by dept_name 注意：在group by中出现的属性，必须在select中出现，不能出现其他属性（除了聚合函数） having语句 找出所有平均工资超过42000的学院 select dept_name, avg(salary) from instructor group by dept_name having avg(salary) > 42000 having语句中是在group by之后进行的 null值和聚合 select sum(salary) from instructor 上述语句忽略空值 如果没有非空值则查询结果是null 除了$count(*)$，所有聚合函数都忽略在被聚合属性上是空值的元组 嵌套子查询 where语句中的嵌套子查询 set成员 set比较 set基数 membership Find courses offered in Fall 2009 and in Spring 2010 select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id in (select course_id from section where semester='Spring' and year = 2010) Find courses offered in Fall 2009 but not in Spring 2010 select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id not in (select course_id from section where semester='Spring' and year=2010); 可以考察更多属性的membership select count(distinct ID) from takes where (course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year from teaches where teaches.ID=10101); comparison——\"some\" 找出收入高于生物学院的instructor select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name='Biology'; 等同于用some select distinct name from instructor where salary > some(select salary from instructor where dept_name='Biology'); comparison——all Comparison——'exists' 当子查询不是空集时，exists返回true 找出选了生物学院的所有课程的学生 select distinct S.ID, S.name from student as S where not exists((select distinct course_id from course where dept_name='Biology') except (select course_id from takes where S.ID=takes.ID)); Comparison——unique 考察子查询结果中是否存在重复元组，是则返回false，否则返回true 找出2009年最多开展一次的课程 select T.course_id from course as T where unique(select S.course_id from course as S where S.course_id=T.course_id and S.year=2009); from子句中的子查询 with语句 with子句提供了定义临时关系的方式，这个临时关系只能在当前语句中使用 例子：找出预算最多的院 with max_budget(value) as (select max(budget) from department) select department.name from deparment, max_budget where department.budget = max_budget.value 例子：找出总收入大于所有院平均总收入的院 with dept_total(dept_name, value) as (select dept_name, sum(salary) from instructor group by dept_name), dept_total_avg(value) as (select avg(salary) from instructor) select dept_name from dept_total, dept_total_avg where dept_total.value > dept_total_avg.value; select中的嵌套子查询 一个语句必须只得到一个值 例子：列出所有department和院中的教师数 select dept_name, (select count(*) from instructor where instructor.dept_name=department.dept_name) as num from department; 如果这个查询返回超过一个元组，则报错。 修改数据库 删除 插入 更新 条件语句 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch4.html":{"url":"database/ch4.html","title":"CH4","keywords":"","body":"CH4 views 某些情况下，不是所有用户都想看到整个逻辑模型。 创建方法 create view v as \"query expression\"是一个合法的SQL表达式，视图名是v Once a veiw is defined, the view name can be used to refer to the virtual relation that the view generates. A view defination causes the saving of an expression; the expression is substituted into queries using the view. 使用了视图的queris中，view会替换为expression create view faculty as select ID, name, dept_name from insturctor create view departments_total_salary(dept_name, total_salary) as select dept_name, sum(salary) from instructor group by dept_name; 使用view定义其他view create view physics_fall_2009 as select course.course_id, sec_id, building, room_number from course, section where course.course_id = section.course_id and course.dept_name='Physics' and section.semester='Fall' and section.year='2009' 使用上面的view创建其他view create view physics_fall_2009_watson as select course_id, room_number from physics_fall_2009 where building='Watson'; view展开为如下： create view physics_fall_2009_watson as (select course_id, room_number from (select course.course_id, building, room_number from course, section where course.course_id=section.section_id and section.semester='Fall' and section.year='2009') where building='watson'); view更新 向faculty视图中添加值 insert into faculty values('30765', 'Green', 'Music') 某些更新无法uniquely翻译 create view instructor_info as select ID, name, building from instructor, department where instructor.dept_name=department.dept_name 插入一行 insert into instructor_info values('1000', 'wzr', 'watson'); 如果一个建筑中有多个department，就无法确定这个老师是哪个院的，并且如果该建筑中没有department。 满足如下条件view可以 From语句中只涉及一个关系 select语句只包含属性名，不包含任何表达式、聚合函数和distinct 任何没有在select中列出的属性都可以设为null 没有group by和having 物化视图 Materialized Views 允许存储视图关系（物理上） 如果视图中使用的关系更新了，物化视图的结果就会过时 需要通过更新视图来维护视图 alter table table-name add constraint Integrity Constraints完整性约束 not null primary key unique check(P)，P是个谓语 not null name varchar(20) not null, budget numberic(12, 2) not null unique($A_1, A_2, ..., A_m$) 表示属性集A_1, A_2, ..., A_m构成候选码 与主键不同，候选码可以使null（控制不等于其他任何值） check子句 check(P)，关系中每个元组都必须满足谓词P check ( semester in ('Fall', 'Winter', 'Spring', 'Summer')) 参照完整性 referential integrity 保证一个关系中给定属性集上的取值也在另一个关系的特定属性集的取值中出现称为 referential integrity 令关系$r_1$和$r_2$的属性集分别为$R_1$和$R_2$，主码分别为$K_1$和$K_2$。如果$r_2$任意元组$t_2$，均存在$r_1$中元组$t_1$使得$t_1.K_1=t_2.\\alpha$，我们称$R_2$的子集$\\alpha$为参照关系$r_1$中$K_1$的外码（foreign key） 这种关系称为参照完整性约束（referential-integrity constraint）或子集依赖（subset dependency）。 $r_2$中$\\alpha$上的取值集合必须是$r_1$中$K_1$上的取值集合的子集 $\\alpha$和$K_1$必须是相容的属性集 $\\alpha$ 等于$K_1$ 二者属性数相同，且对应属性的类型必须相容 create table course( course_id char(5) primary key, title varchar(20), dept_name varchar(20) references department ) create table course ( ... dept_name varchar(20), foreign key(dept_name) references department on delete cascade on update cascade, ... ) 级联删除on delete cascade：如果删除department中的元组导致参照完整性被违反，则删除不被系统拒绝，course中参照了被删除元组的元组被删除 在插入一个人之前先插入爸爸和妈妈 先把爸爸和妈妈设为null，插入所有人之后在设置爸爸和妈妈 延迟约束检查 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch5.html":{"url":"database/ch5.html","title":"CH5","keywords":"","body":"第五章 高级SQL 有两个重点 使用程序设计语言访问数据库 如何允许数据库与普通程序交互，C还是JAVA 如何处理SQL和C、JAVA中数据类型的不同 如何处理被很多短时进程共享的数据库连接 三种不同类型的可编程SQL embedded sql API ODBC JDBC procedure SQL 函数和过程 Functions and Procedural Constructs 过程 Procedure 使用create procedure创建，使用call语句调用 procedure没有返回值但是可以通过修改参数供调用者稍后检查，它也可以生成结果集。 参数 proc_parameter: [IN|OUT|INOUT] param_name type 每个参数默认是IN参数，可以在参数名前面指定IN OUT 这个关键字（IN|OUT|INOUT）只对PROCEDURE有效 对于FUNCTION，参数都是IN，过程中有可能会改变这些值，但是修改不会对调用者产生影响 OUT参数会将值传送到调用者 INOUT参数由调用者进行初始化，传送一个值到procedure再返回给调用者，对参数的任何修改对调用者都会生效。 delimiter命令，设定分隔符。 delimiter //表示之后如果一行命令以//结束，则执行命令，否则不执行 函数 Function 使用create function使用起来类似内置函数。可以在表达式中调用，它会在表达式执行过程中返回一个值。 定义一个函数，返回一个院内教师人数 create function dept_count(dept_name varchar(20)) returns integer begin declear d_count integer; select count(*) into d_count from instructor where instructor.dept_name=dept_name return d_count; end 内容组成 复合语句：begin...end 可能包含多个SQL语句 returns——指出返回值的类型 return——指出返回值，作为函数调用的结果 SOL 函数实际上是泛化的参数化视图 BEGIN [statement_list] END dept_countfunction也可以procudure代替。 declare statement local variables conditions and handlers cursors declare var_name [, var_name] ... type[DEFAULT value] set variable = expr [, variable=expr]... create procedure sql (x varchar(5)) begin declear xname varchar(5) default 'bob'; declear newname varchar(5); declear xid INT; select xname, id INTO newname, xid from table1 where xname = xname; select newname; end; 流程控制语句 IF CASE LOOP ITERATE LEAVE LOOP WHILE REPEAT RETURN if create funtion xxxx (n INT, m, INT) returns varchar(50) begin declare s varchar(50); if n=m then set s = 'equal'; else if n>m then set s = 'greate'; else set s='less'; end if; end if; set s=concat(n, ' ', s, ' ', m, '.'); return s; end// delimiter ; case语句 case case_value when when_value then statement_list [when when_value then statement_list] [else statement_list] end case 或 case when search_condition then statement_list [when search_condition then statement_list] [else statement_list] end case delimiter | create procedure p() begin declare v int default 1; case v when 2 then select v; when 3 then select 0; else begin end; end case; | delimiter ; LOOP LOOP statement_list END LOOP ITERATE 只能在LOOP REPEAT和WHILE statements中使用，表示\"Start the loop again\" LEAVE 离开循环。 例子 create procedure doiterate(p1 INT) BEGIN l1: loop set p1 = p1 + 1; if p1 while [begin_label]while search_condition do statement_list end while end_label create procedure dowhile() begin declare v1 int default 5; l1: while v1 > 0 do ... set v1 = v1 - 1; end while l1; end repeat create procedure dorepeat(p1 INT) begin set @x = 0; l1: repeat set @x = @x + 1; until @x > p1 end repeat l1; end; cursor游标 mysql支持在存储程序中使用游标，只能单向遍历 create procedure curdemo() begin declare done int default false; declare a char(6); declare b, c int; declare cur1 cursor for select id, data from test.t1; declare cur2 cursor for select i from test.t2; declare continue handler for NOT FOUND SET done = truel open cur1; open cur2; read_loop: LOOP fetch cur1 into a, b; fetch cur2 into c; if done then leave read_loop; end if; if b create procedure curdemo() begin declare dont int default false; declare a char(16); -- 事先声明 declare b, c int; declare cur1 cursor for select id, data from test.t1; declare cur2 cursor for select i from test.t2; declare continue handler for not found set done = true; open cur1; open cur2; read_loop: loop fetch cur1 into a, b; fetch cur2 into c; if done then leave read_loop; end if; if b Condition handling 可以定义handlers，来应对诸如warning、exceptions或者特殊的条件，比如特定错误码 可以给特定条件设定名字并在handlers中引用 declare .. condition statement declare .. handler statement declare condition_name condition for condition_value declare continue handler for 1051 begin -- body of handler end; 通过声明条件的名字，handler的目的是更容易看到 declare condition declare no_such_table condition for 1051; declare continue handler for no_such_table; begin -- body of handler end; declare handler DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement handler_action: { CONTINUE | EXIT | UNDO } condition_value: { mysql_error_code | SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING | NOT FOUND | SQLEXCEPTION } create procedure handlerdemo() begin declare continue handler for sqlstate '23000' set @x2 = 1; set @x = 1; insert into test.t values(1); set @x = 2; insert into test.t values(1); set @x = 3; end triggers event insert delete update create trigger trigger-name trigger-time trigger-event on table-name for each row trigger-action trigger-time$\\in${BEFORE, AFTER} trigger-event$\\in${INSERT, DELETE, UPDATE} 两个值 old row：for deletes and updates new row：for inserts and updates 创建一个触发器，当雇佣新的雇员时更新deparment的总收入 delimiter | create trigger udpate_salary after insert on employee for each row begin if new.dno is not null then update deptsal set totalsalary = totalsalary + new.salary where dnumber = new.dno; end | delimiter ; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch7.html":{"url":"database/ch7.html","title":"CH7","keywords":"","body":"CH7 ER图 [toc] design process 第一个阶段是完整刻画未来数据库用户的数据需求 概念设计阶段选择数据模型 完整的概念模式还指明企业的功能需求。在功能需求规格说明（specification of functional requirement），用户描述将在数据上进行的各类操作（事务） 从抽象数据模型到数据库实现 逻辑设计logical design 物理设计physical design design approaches ER图 规范化理论 建模 ER数据模型的提出旨在方便数据库的设计，它是通过允许定义代表数据库全局逻辑结构的企业模式实现的 ER模型在将现实世界企业的含义和交互 映射到概念模型上非常有用 三个概念 实体集 联系集 属性 实体集 Entity set Entity是现实生活中区别于其他对象的事务 entity set是类型属性相同的实体的集合 实体由一组属性表示；即描述性属性。实体集的所有成员都拥有。 insrtructor=(ID, name, street, city, salary) course=(course_id, title, credits) 实体集属性的一个子集构成primary key，唯一标识（uniquely identify）集合中的成员 关系集 Relationship set Relationship是若干实体之间的联系 例子 advisor 描述性属性 descriptive attribute 属性也可以和联系集相关联 比如，advisor有一个时间 degree of relationship set 联系集的度 二元关系 binary relationship 涉及两个实体集的联系集 度>2的联系，一般联系都是二元的 映射基数 mapping cardinality 表示一个实体通过一个联系集能关联的实体的个数 对于二元联系，一定是如下 一对一 一对多 多对一 多对多 复杂属性 简单simple和复合compsite属性 单值single和多值multivalued属性 派生derived属性 冗余属性 弱实体集 考虑section，由 course_id, semester, year 和 sec_id唯一标识 显然，section实体与course实体相关，假设我们创建一个sec_course联系来联系section和course 弱实体集的存在依赖于另一个实体（标识 identifying）或属主实体集owner entity set。 我们使用标识实体和额外属性（discriminator 分辨符）来唯一标识弱实体，非弱实体集叫强实体集 section的分辨符是sec_id、year和semester existence dependent 弱实体集存在依赖于标识实体集 标识实体集拥有（own）弱实体集 ER图 实体集 矩形代表实体集 矩形中列出属性 下划线指出主码 联系集 菱形代表联系集 描述性属性 角色role 映射基数cardinality constraints 全部和部分参与 total and partial participation 全部参与 total participation 每个学生都必须有一个instructor 部分参与partial participation 某些实体可能没有参与联系集中的所有联系 有些instructor没有参与advisor 复杂属性的表示 instructor ID name —— 复合属性 frist_name middle_initial last_name address ——复合属性 street street_number street_name apt_number city state zip {phone_number} ——多值属性 date_of_birth age()——派生属性 弱实体集 ER图中，用双矩形表示weak entity set 分辨符（discriminator）用虚线下划线标出 联系集用双菱形标出 简化为关系模式 实体集和关系集可以统一表示为表示数据库内容的关系模式。 一个符合ER图的数据库可以由模式的集合表示 对于每个实体集和联系集，都有唯一的模式对应 每个模式有多个列，每个列有唯一的名字 reduction——表示实体集 Strong entity set reduces to a schema whith the same attribute 强实体集变成模式时属性名不变 student(ID, name, tot_cred) Weak entity set 变成一个表，包含标识强实体集的主键和分辨符 section(course_id, sec_id, sem, year) 复杂属性 复合属性：为每个子属性创建独立的属性 多值属性：对于多值属性M，实体集中不包含该属性，构建关系模式R，该模式包含一个对应于M的属性A。 instructor_phone(ID, phone_number) 映射 一对多和多对一联系集 many side是total participation的情况下，直接在many side添加one side的主码 instructor(ID, name, salary, dept_name) 对于一对一联系 任何一边可以作为many side 弱实体集 section(course_id, sec_id, semester, year) n元联系集 以三元联系集为例 最多一个箭头 如果超过一个箭头则有多重解释 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch8.html":{"url":"database/ch8.html","title":"CH8","keywords":"","body":"CH8 好的设计的特点Features of Good Relational Design A combined schema without repetion 没有重复的组合模式 更小的模式 对于inst_dept。decompose it into instructor and department dept_name是候选码 表示为函数依赖 dept_name → building, budget 在inst_dept中，因为dept_name不是候选码，building和budget可能会出现重复 不是所有的分解都是好的 lossy decomposition有损分解 如果有多个同名的kim，则无法分辨 lossless decomposition 无损分解 ⚛原子域和第一范式1NF domain is atomic if its elements are considered to be indivisible units 如果域中的元素是不可分割的称域为原子域 如果R的所有属性的域都是原子的，则称该关系模式是第一范式（first normal form, 1NF） goal目的——为下列内容设计一个理论 决定关系R是否是好的范式 当R不是good form时，把它分解成{$R_1, R_2, R_3...$}，其中 每个关系都是good form 分解必须是无损连接分解 理论基于 函数依赖 多值依赖 Functional Dependency Theory 合法关系集的约束 要求关系中有候选码 函数依赖是key的泛化 R是个关系模式 Relation Schema \\alpha \\subseteq R \\text { and } \\beta \\subseteq R 与码的关系 key 当$K\\rightarrow R$时，$K$是超码。 当$K\\rightarrow R$，并且不存在$\\alpha \\subset K, \\alpha \\rightarrow R$ 不存在K的子集，使得函数依赖$\\alpha \\rightarrow R$成立 Function Dependencies允许我们表达不能使用超码表达的约束 考虑如下模式 inst_dept(ID, name, salary, dept_name, building, budget) 使用函数依赖表示 $dept_name\\rightarrow building \\text{ } and \\text{ } ID\\rightarrow building$ we use funcional dependencies to 实例：判定关系的实例是否satisfies给定函数依赖集F satisfies：模式r满足函数依赖集F 模式：说明合法关系集上的约束。如果模式R上满足函数依赖集F的关系，则F在r(R)上成立 注意：一个关系模式的实例可能satisfy一个函数依赖即使这个函数依赖在模式上并不成立。 平凡trivial函数依赖 如果一个函数依赖在一个关系的所有实例上都成立，则它是平凡的 ID, name \\rightarrow ID \\\\ name \\rightarrow name 函数依赖集闭包 closure of a set of functional dependencies 给定函数依赖集F，可以推断出一些其他的函数依赖也成立 例如 $if \\; A \\rightarrow B \\; and \\; B \\rightarrow C$ 可以推出$A \\rightarrow C$ 能够从给定函数依赖集F推导出的所有函数依赖是F的闭包（closure） 写作$F^+$ $F^+$是F的超集 BCNF范式 消除所有基于函数依赖能够发现的冗余 具有函数依赖集F的关系模式R属于BCNF的条件是，对$F^+$中所有函数依赖$\\alpha \\rightarrow \\beta$，下列至少一项成立 是平凡的函数依赖 或者$\\alpha$是超码 数据库属于BCNF的条件是，构成该设计的所有关系模式都属于BCNF 将一个模式分解为BCNF 假设我们有一个关系模式R和非平凡函数依赖，不满足BCNF decompose it into $(\\alpha \\cup \\beta)$ $R-(\\beta - \\alpha)$ BCNF和依赖保留 Dependency Preservation 依赖保留，有时我们希望进行BCNF分解后，某些依赖仍然保留。 但是往往BCNF和依赖保留不能两全。 所以我们提出3NF，它比BCNF更弱。 3NF，第三范式 BCNF基础上再加一个条件 $\\alpha \\rightarrow \\beta$是一个平凡trivial的函数依赖 $\\alpha$是R的一个超码 $\\beta - \\alpha$中的每个属性都包含于R的一个候选码中 如果R满足BCNF则，R满足3NF 能确保每个模式都有保持依赖的函数依赖的3NF分解 规范化的goal 函数依赖理论 closure of a set of functional dependencies 逻辑蕴含 给定关系模式r(R)，如果r(R)的每一个满足F的实例也满足f，则R上的函数依赖f被r上的函数依赖集F逻辑蕴含 函数依赖集F的闭包是$F^+$ 我们可以通过反复使用 reflexivity自反律if $\\beta \\subseteq\\alpha$则$\\alpha \\rightarrow \\beta $ augmentation增广律：如果$\\alpha \\rightarrow \\beta$，则$\\gamma \\alpha\\rightarrow\\gamma\\beta$ transitivity传递律：如果$\\alpha \\rightarrow \\beta$并且$\\beta\\rightarrow\\gamma$则$\\alpha\\rightarrow\\gamma$ union合并律：如果$\\alpha \\rightarrow \\beta$并且$\\alpha \\rightarrow \\gamma$，则$\\alpha \\rightarrow \\beta \\gamma$ decomposition分解率：union逆命题 pseudotransitivity伪传递律：如果$\\alpha \\rightarrow \\beta$并且$\\gamma \\beta \\rightarrow \\delta$则$\\alpha \\gamma \\rightarrow \\delta$ 属性集的闭包 如果$\\alpha \\rightarrow B$，我们称属性B被$\\alpha$函数确定（functionally determine)。 要判断集合$\\alpha$是否是超码，需要设计一个算法，用于计算被$\\alpha$函数确定的属性集。 先判断是不是超码 再判断是不是候选码 用途 判断超码：先求$\\alpha^+$，看看是否包含R的所有属性 判断函数依赖是否holds 对于$\\alpha \\rightarrow \\beta$，check $\\alpha^+$中是否有$\\beta$即可 另一种计算$F^+$的方法，对任意$\\gamma \\subseteq R$找出$\\gamma^+$，对任意$S\\subseteq \\gamma^+$，可以输出一个函数依赖$\\gamma \\rightarrow S$ 正则覆盖 canonical cover 无关属性 extraneous attributes 考虑$\\alpha \\rightarrow \\beta$ in F 如果$A \\in \\alpha$，并且F逻辑蕴含$(F-{\\alpha \\rightarrow \\beta}) \\cup{(\\alpha-A) \\rightarrow \\beta}$ 如果$A\\in\\beta$，并且F逻辑蕴含$(F-{\\alpha \\rightarrow \\beta}) \\cup{\\alpha \\rightarrow (\\beta-A)}$ 则A是无关的 判断一个属性是否无关extraneous（使用属性集闭包） 对于F中的$\\alpha\\rightarrow\\beta$是否存在无关属性 $A\\in\\alpha$ 计算$({\\alpha}-A)^+$，使用F 判断其是否包含$\\beta$，有则A是无关属性 $A\\in \\beta$ 计算$\\alpha^+$，使用$\\mathrm{F}^{\\prime}=(F-{\\alpha \\rightarrow \\beta}) \\cup{\\alpha \\rightarrow(\\beta-A)}$ 判断其是否包含A，不包含则A是无关属性 正则覆盖canoncial cover $F_c$是F的正则覆盖，当 F逻辑蕴含Fc Fc逻辑蕴含F Fc中的函数依赖不包含无关属性 Fc中的每个函数依赖的左边都是唯一的。 算法 适用union rule合并dependency 对剩下的去除无关属性 算法结束后，可能union rule需要再次适用。 无损分解 lossless decomposition 用关系代数说明 对于$R=(R_1, R_2)$，我们要求 r=\\prod_{R 1}(r) \\bowtie \\prod_{R 2}(r) $R_1$和$R_2$是属性集，可能有共同的属性 $\\bowtie$是自然连接 这样令R1和R2是R的分解，没有信息损失，该分解是无损分解 用函数依赖说明 如果以下函数任意一个属于$F^+$，则是无损分解 R_1 \\cap R_2 \\rightarrow R_1 \\\\ R_1 \\cap R_2 \\rightarrow R_2 也就是分解后一方含有另一方的超码 超码可以用属性集闭包判断 example 保持依赖 dependency perservation n个R，$R_i$的函数依赖集是$F_i$，如果 \\left(F_{1} \\cup F_{2} \\cup \\ldots \\cup F_{\\mathrm{n}}\\right)^{+}=F^{+} 则分解是依赖保留的 算法 分别对F中的函数依赖使用如下算法 这里的属性闭包是F下的 example 判断BCNF BCNF分解 3NF分解 BCNF不是依赖保持的 检测违反函数依赖的效率很重要 解决方法 定义一个更弱的范式 允许一定冗余 函数依赖可以在单独的关系中检验不用计算连接 design goals 关系型数据库设计 BCNF 无损分解 lossless join dependency preservation 如果不能达到，接收如下之一 缺少函数依赖 3NF var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch14.html":{"url":"database/ch14.html","title":"CH14","keywords":"","body":"数据库第十四章 Transaction concept 一个transaction是一个程序执行的单元unit， sql语句集 存储过程 由高级程序设计语言初始化 由begin transaction和end transaction分隔 example ACID properties Atomcity原子性：事务的所有操作在数据库要么全部正确执行，要么完全不反映 Consistency一致性：隔离执行事务时，保持数据库的一致性 Isolation隔离性：多个事务可能并发执行事务之间感受不到其他事务的并发执行， Durability持久性：一个事务成功后，对数据库的改变必须是永久的 事务状态 Active: 初始状态，事务执行时保持这种状态 Partially committed: 最后一条语句结束后的状态 Failed: 发现正常的执行不能继续后 Aborted:中止的 事务回滚并且数据库已经恢复到事务开始之前的状态 出现这个状态之后，有两个选择 重启事务 kill the transaction Committed: 成功完成后。 并发执行 Concurrent Executions 系统允许多个事务并行 处理器和磁盘利用率的提高，使得事务吞吐率提高 等待时间减少：短事务不必等待长事务 并发控制机制 concurrency control schemes 控制事务之间的交互，防止他们破坏数据库的一致性 调度 schedules schedule——表示指令在系统中执行的时间顺序 一个事务集的调度必须包含这些食物的所有指令 必须保持指令在各个事务中出现的顺序 一个成功完全执行的事务会在最后一条指令后执行一个commit指令 执行失败的事务会在最后一条指令后执行一条abort指令 使用的符号 Database由object(X, Y, Z)组成， Tranactions标记为$T_1, T_2$ 每个transaction在主存中包含局部变量集（其他事务不可访问） 每个事务可以用read()和write()访问数据库 read()命令将数据库object读取到局部变量中 write()命令可以将局部变量写入数据库 Local varibale for read() & write() will not be shown if the context is clear, or if it is unimpoertant 对objects的操作和计算智只能在局部变量上进行，比如，X=X+1不对，但是a1 = a1 + 1可以。 某些情况下，局部操作不展示 Serializable schedule 考虑两个事务 财产转移 利润 对于串行调度serial schedules 如果dividend之前进行transfer X：$100 \\rightarrow 50 \\rightarrow 50.5$ Y: $200 \\rightarrow 250 \\rightarrow 252.5$ transfer之前dividend X：$100\\rightarrow 101 \\rightarrow 50.5$ Y: $200 \\rightarrow 202 \\rightarrow 252$ 两种情况下，$X+Y=300$ 但是如果按照如下方式调度 这种情况下 $X: 100\\rightarrow 50 \\rightarrow 50.5$ Y: $200\\rightarrow 202\\rightarrow 252$ X+Y=302.5 什么造成了上面的问题 资源竞争？ 交叉执行？ 可串行化 serializable 并发执行中，通过保证所执行的任何调度的效果都与没有并发执行的调度效果一样，我们可以确保数据库的一致性。 调度应在某种意义张等价于一个串行调度 四种情形 考虑两条连续指令I,J。 I=read(Q), J=read(Q) 次序可交换，无论怎么读值都一样 I=read(Q),J=write(Q) 不可交换 I=write(Q), J=read(Q) 不可交换 I=write(Q), J=write(Q) 不可交换 总结 只有在两条指令都是读的情况下，执行顺序才无关紧要。 confict 当两条指令在相同数据项上操作，且其中存在write指令，则两个指令是conflict的 考虑之前的调度 尝试对指令执行次序进行交换 （4）指令可以逐步与（i，ii, iii）交换，直到 （5）（6）指令思路相同，（5）与（i，ii，iii）均不冲突，所以可以移动到i之前执行 再看这个调度 （3）无法与i交换；4无法与vi交换 所以不可串行化 总结 一个调度如果可以转变为串行调度则是好的调度（可以达到隔离性） 反之，则不好 冲突可串行化conflict serializable 若一个调度S与一个串行调度冲突等价，则称调度S是冲突可串行化的 优先图 precedence graph 点是事务的有向图 边的含义 $T_i\\rightarrow T_j$表示一下三个条件之一 i写j读：$T_j$执行read(Q)之前$T_i$执行write(Q) i读j写：$T_j$执行write(Q)之前$T_i$执行read(Q) i写j写 如果存在边$T_i\\rightarrow T_j$，则任何等价于S的调度$S^{\\prime}$中，$T_i$必出现在$T_j$之前 冲突可串行化的判断 当且仅当优先图没有环时，调度是冲突可串行化的。因此要判定冲突可串行化，需要构造优先图并调用一个环检测算法。 serializability order串行化顺序 可以通过拓扑排序（topological sorting）得到。 由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。 选择一个入度为0的顶点并输出之； 从网中删除此顶点及所有出边 一般可以获得多个线性顺序。 该调度不可串行化 事务隔离性和原子性 可恢复调度recoverable schedule 如果事务$T_j$读取了前序事务$T_i$写入的数据，那么$T_i$的commit操作必须在$T_j$的commit之前出现 例如 如果$T_8$需要abort，$T_9$将已经读了A并且已经提交无法取消。所以该调度属于不可恢复调度 级联回滚 cascading rollbacks 单个事务失败会导致一系列事务回滚。考虑如下事务，假设还没有事务已经commit 如果$T_{10}$失败了，则T11和T12都要回滚 这样有可能导致大量工作的回滚。 无级联调度 cascadeless schedule 对每对事务$T_i$和$T_j$，如果j读取了i写的数据项，则i应该在j的读操作之前commit。 容易验证，每个无级联调度也都是可恢复的调度 Concurrency control并发控制 数据库提供了一种机制保证所有可能的调度都满足 冲突可串行化 可恢复并且最好是无级联的 同一时刻只有一个事务可以执行的策略无法实现高并发性 并发控制机制在它们允许的并发量和它们产生的开销之间进行权衡 在调度执行之后检验冲突可串行化已经晚了 目标：提出能够保证可串行化的并发控制协议 低等级的一致性 某些应用允许一定的低一致性，他们允许非串行的调度 一个read-only的事务，他试图获取所有账户总余额的近似值 为查询优化计算的数据库统计信息可以是近似的 用精度换性能 事务隔离性级别 可串行化 sericalizable 默认的 可重复读的 Repeatable read 只允许读取已提交的数据。 一个事务两次读取一个数据项期间，其他事务不能更新该数据。该事务不要求与其他事务可串行化。 已提交读 Read committed 只允许读已提交的数据，但不要求可重复读。事务两次读取同一数据期间可能数据已经被修改并提交 未提交读 read uncommitted 允许度未提交的数据，最低级的。 都不允许dirty write 即如果一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作 某些数据库并不保证默认可串行化 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/CH15.html":{"url":"database/CH15.html","title":"CH15 并发控制","keywords":"","body":"数据库第十五章 Lock-based protocol lock 锁是一种控制对数据项并发访问的机制 数据项可以在两种模式下被锁 排他的exclusive(X)mode：如果事务T获得了数据项Q上的排它锁，可以读写 共享的shared：如果事务T获得了数据项Q上的共享锁，则T可读但是不能写 程序猿向并发控制管理器concurrency-control manager发出锁请求。事务只有在请求得到授权后才能继续 锁相容性矩阵 lock-compatibility A transaction may be granted a lock on an item if the requested lock is compatible with locks already held on the item by other transactions. 任何时候，一个数据项可以同时使用任意数量的共享锁 此后的排它锁请求必须一直等到所有共享锁释放 当有X锁时，不能再使用更多的任何锁 如果不能授予锁， 发送请求的事务就等待，直到所有其他事务使用的不相容的锁被释放掉，才能授予该锁 例子 展示A+B 上述方法不足以保证可串行化。如果A和B在ulock(A)和lock-s(B)之间被修改了，则展示出的和会不正确 locking protocol是所有事务在请求和释放锁时遵守的规则集 locking protocol限定了可能的调度集 自动获取锁Automatic Acquisition of Locks 事务$T_i$处理标准 read/write指令时无需显式使用锁调用指令 read(D) if Ti has a lock on D then read(D) else begin if necessary wait until no other transaction has a lock-X on D // 这里只需要确定其他事务没有X锁就行，自己可以有 grant Ti a lock-S on D read(D) end write(D) if Ti has a lock-X on D then write(D) else begin if necessary wait until no other transaction has a lock on D if Ti has a lock-S on D then upgrade lock on D to lock-X else grant Ti a lock-X on D 所有锁在commit或abort后都释放 The two-phase lockign protocol两阶段锁协议 这个锁协议保证了冲突可串行调度 增长阶段 growing phase 缩减阶段 shrinking phase Deadlocks 考虑如下部分调度 不难看出，最后$T_3$和$T_4$都不能继续执行了。 为了进行下去，$T_3$和$T_4$中的一个应该回滚令其锁释放 两阶段锁无法保证无死锁 饥饿 例如：某事务可能在等待某X-lock请求，但是一系列其他事务不断被授予S-lock，这个事务一直得不到X-lock 并发控制管理器可以designed to prevent starvation 大多数封锁协议中存在潜在死锁 当一个死锁发生时，有可能会发生级联回滚 两阶段锁也有可能会发生级联回滚。为了避免，使用strict two-phase locking一个事务必须持有所有的X-lock，直到commit/aborts Rigorous two-phase locking：事务的所有锁都要一直持有，直到commit/abort 锁的实现 lock manager可以实现为一个进程，从事务接收消息并反馈消息。 针对锁请求消息返回 授予锁消息 事务回滚消息 lock manager维护一个lock table来记录被授予的锁和待办的锁 锁表通常实现为内存中的哈希表，索引以被上锁的数据项的名字作为索引项 死锁处理 定义 如果有一个事务集，其中的所有事务都在等待另一个该事务集中的事务，那么该系统死锁 死锁预防 deadlock prevention 死锁预防协议保证系统永远不会进入死锁状态。例如 要求事务在执行前，对所有数据项上锁（预声明） 有两个缺点 事务开始前通常很难预支哪些数据需要封锁 数据项使用率低，有可能许多数据项长时间封锁却用不到 通过对加锁请求进行排序，偏序 每当有可能导致死锁时，进行事务回滚而不是等待加锁 wait-die策略——非抢占式 当事务Ti申请的数据项当前被Tj持有， 仅当Ti时间戳小于Tj的时间戳时，Ti等待， 否则Ti回滚。 wound-wait策略——抢占式 当事务$T_i$申请的数据项当前被$T_j$持有 $T_i$的时间戳大于$T_j$的时间戳时，$T_i$等待。 否则，$T_j$回滚 这两种方法均会发生不必要的回滚 锁超时 lock timeout 申请锁的事务至多当代一段给定的时间若此期间未授予锁，则该事务超时，回滚并重启。 死锁不可能发生 实现简单，但是有可能发生饥饿，不容易确定合适的超时时间 死锁的检测和恢复 如果系统不能保证不产生死锁，则系统必须采用检测和恢复机制。 wait-for等待图 死锁可以用等待图精确描述，由G=(V,E)组成 V：点集，对应所有事务 E：边集 如果存在$T_i \\rightarrow T_j$成立，则表示$T_i$在等待$T_j$释放数据项 如果等待图有环，则系统处于死锁。必须使用死锁检测算法来寻找环。 检测到死锁后 某些事务回滚，选一个代价最低的作为受害者 回滚多少 Total rollback，abort and restart 更高效的做法：只回滚需要的的距离 如果某个事务总是称为受害者，则会出现饥饿 将回滚的次数作为代价的考量来避免饥饿。 基于时间戳的协议 时间戳 对系统中每个事务$T_i$，把唯一一个时间戳和它相联系。此时间戳记为TS(Ti)。 两种方法 使用系统时钟（system lock）作为时间戳 使用逻辑计数器（logical counter）作为时间戳，每赋予一个时间戳，计数器增加计数，事务的时间戳等于该事务进入系统时的计数器值 时间戳决定了串行化顺序 每个数据项与两个时间戳值相关联 W-timestamp表示成功执行write(Q)的所有事务的最大时间戳 R-timestamp表示成功执行read(Q)的所有事务的最大时间戳 时间戳排序协议 保证任何有冲突的read和write操作按时间戳顺序执行。 $T_i$发出read(Q) 若$TS(T_i) 若$TS(T_i)\\geq W-timestamp(Q)$，则执行read操作，R-timestamp(Q)设置为它与TS(Ti)的最大值 $T_i$发出write(Q) 若$TS(T_i) 若$TS(T_i) 其他情况下，系统继续执行，将$W-timestamp(Q)$设置为$TS(T_i)$ 回滚后，Ti被系统赋予新的时间戳 Thomas写规则 多版本机制 multiversion schemes 时间戳版本 多版本机制保留老版本的数据项来提高并发性 多版本时间戳排序 多版本两阶段锁协议 每个成功的write都会导致数据项的新版本 使用时间戳来标记版本 不保证无级联性和可恢复性 两阶段锁 对只读事务和更新事务加以区分 更新事务执行强两段锁协议，即持有他们直到事务结束。因此，他们可以按提交的次序串行化。数据项的每个版本有一个时间戳（ts-counter），这个计数器在提交处理时增加计数。 只读事务，开始执行前数据库系统读取ts-counter的当前值来作为该事务的时间戳。只读事务执行时按照多版本时间戳排序协议。因此Ti发出read（Q)时，返回值是小于TS(Ti)的最大时间戳版本的内容。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/CH16.html":{"url":"database/CH16.html","title":"ch16","keywords":"","body":"CH16 恢复系统 错误分类 Failure Classification 事务错误 逻辑错误 由于内部错误事务无法完成 系统错误 稳定存储器 多个非易失存储介质上以独立故障模式复制所需信息，以受控方式更新信息。 数据访问 数据库系统常驻非易失性存储器，任何时间都只有数据库的部分内容在主存中。 日志记录 log，最广泛的记录数据库修改的结构。 日志是日志记录（log record）的序列。它记录数据库中的所有更新活动。 更新日志记录update log record描述一次数据库写操作 数据标识（transaction identifier) 数据项标识（data-item identifier） 旧值（old value） 新值（new value） 一个更新日志记录表示为$$，表示事务$T_i$对数据项$X_i$进行了一个写操作，写操作前$X_i$的值是V1，之后是V2。 还有其他几个 操作 每次事务执行写操作时，必须在数据库修改前建立该次写操作的日志记录并把它加到日志中。 一旦日志记录已经存在，就可以根据需要将修改输出到数据库中，并且有能力撤销输出到数据库中的修改。 日志必须放到稳定存储器中。 并发控制和恢复 有了并发事务，所有事务共享一个磁盘buffer和一个日志 一个buffer block可以包含一个或多个事务更新的数据项 假定如果事务$T_i$已经修改了一个item，其他事务必须等到$T_i$abort或者commit后才能修改相同的item 未提交事务的更新对其他事务不可见 否则如果T1更新了A，T2又更新了A并提交，然后T1abort了 可以通过严格两阶段锁strict two-phase locking 不同事务的日志记录可能穿插在log中 恢复 当从错误中恢复时 $T_i$需要undo，如果 日志包含 但是不包含commit或abort redo，如果 包含start 包含commit和abort 注意，如果事务$T_i$之前undo过， 例子 检查点checkpoint redo和undo事务记录可能会非常慢 整个log的读取非常耗时 我们可能会进行非必要的redo，有些食物已经将他们的更新输出到了数据库上 通过定期periodically执行检查点来简化恢复过程 把当前主存中所有日志记录输出到主存上 把所有修改过的buffer块输出到磁盘上 写一个日志记录$$到稳定存储器，L是检查点对应时间还在活跃的事务的 检查点执行过程中不允许任何更新动作。 恢复 恢复过程中只需要考虑检查点之前的most recent 事务$T_i$以及$T_i$之后的事务 从log末尾向前扫描来寻找最近的$$ 只有在L中或检查点之后的事务需要redo或undo 检查点之前commit或abort的事务已经将更新输出到了稳定存储器上 例子 恢复算法 logging $$: at transaction start $$ 每次更新 $$事务结束时 事务取消时 事务回滚 回滚$T_i$ 从后向前扫描日志对于$T_i$的每个格式为$$日志记录 undo: 将$V_1$写给$X_j$ 写一个log record$$（注意，只写三项） 称作补偿日志记录 compensation log records 一旦找到$$，停止扫描，写日志$$ 出错回滚(两阶段) redo phase undo phase redo phase 找到最后一个$$记录，设置undo列表L 从检查点向末尾扫描 每当找到一个$\\text { or }$，redo undo phase 从后往前扫描 当找到$$并且其在undo-list中执行undo操作 将$V_1$写给$X_j$ 写一个log record$$ 找到$$，并且$T_i$在undo_list中 写一个log record $$ remove $T_i$ from undo_list 当undo_list为空时，停止 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/about.html":{"url":"computer-network/about.html","title":"计算机网络","keywords":"","body":"《计算机通信与网络》课程总复习知识点 配套《数据通信与网络(Forouzan第四版)》 2021年12月 第一部分 概述 第1章 绪论 数据通信的概念及模型 数据流 连接类型和拓扑结构 网络分类 协议和标准 第2章 网络模型 层次结构、层间接口和封装 OSI参考模型的概念和各层功能 TCP/IP*协议簇和各层的功能 物理地址、逻辑地址和端口地址（何时改变？） 第二部分 物理层和介质 第3章 物理层 数字信号：基带传输、低通通道、宽带传输的概念 传输减损：衰减、失真、噪声和信噪比的概念 数据速率限制：奈奎斯特速率、香农容量定理 性能：带宽、吞吐量、信道利用率、延迟、传播时间、传输时间、排队时间、带宽与延迟的乘积的概念 第4章 数字传输 线路编码：数据元素、信号元素、数据速率、信号速率、最小带宽、最大数据速率、直流分量、自同步 线路编码方案：单极性编码（NRZ）、极性编码（NRZ-L和NRZ-I）、归零码（RZ）、双相码（Manchester和Differential Manchester）、双极性编码（AMI和伪三进制码）、 脉码调制PCM：采样（采样率）、量化等级、量化误差 Delta调制的概念 传输模式：异步传输、同步传输、并行传输、串行传输的概念 第5章 模拟传输 比特率和波特率 数字到模拟转换： `ASK的概念及ASK的带宽 FSK的概念及BFSK的带宽 PSK、BPSK、QPSK和QAM的概念 模拟信号调制： AM、FM和PM的概念 AM带宽、FM带宽和PM带宽 第6章 带宽利用 复用：FDM、同步TDM、统计TDM和WDM的概念 数字层次、T1载波、E1载波 波分和码分的概念 扩频：FHSS和DSSS的概念 第三部分 数据链路层 第10章 检错与纠错 差错的类型 块编码 差错检测的方法 纠错的概念与方法：汉明距离、最小汉明距离 线性块编码：线性块编码的距离、简单奇偶校验编码、两维奇偶校验编码、汉明码 循环冗余编码CRC（不包含硬件实现）、CRC的检错能力分析（检测单个位差错、两个独立的位差错、奇数个差错、突发性差错） 校验和及其计算方法 第11章 数据链路控制 组帧 流量控制和差错控制的概念 停止等待ARQ、后退N帧ARQ和选择重发ARQ HDLC 第12章 多路访问 随机访问：纯ALOHA、时隙ALOHA、CSMA、CSMA/CD（最小帧长）、CSMA/CA 受控访问：预约、轮询、令牌环 第13章 有线局域网：以太网 IEEE标准：LLC和MAC 标准以太网的MAC子层：帧格式、MAC地址、最短帧长、编码和解码、10Base5、10 Base 2、10 Base -T、10 Base -F 桥接以太网、交换式以太网、全双工以太网 快速以太网：MAC子层、拓扑结构、100Base -TX、100Base-FX、100Base –T4 千兆以太网：MAC子层、拓扑结构、1000Base -SX、1000Base-LX、1000Base –CX 第14章 无线局域网 WLAN体系结构与IEEE 802.11标准 802.11 MAC子层、帧结构、CSMA/CA* 802.11 物理层、寻址方式、隐蔽终端和暴露终端 第15章 连接局域网、主干网和虚拟局域网 连接设备：无源集线器、中继器、有源集线器、网桥、透明网桥、生成树、二层交换机、路由器、三层交换机（补充）、网关、冲突域与广播域 虚拟局域网的概念及划分方法 第四部分 网络层 第19章 逻辑寻址 IPv4地址：A、B、C、D和E类地址、掩码、子网和超网的概念 子网划分、子网的地址范围、地址聚合 NAT的概念 IPv6地址 第20章 IP协议 IP分组（数据报）的格式 分片(Identification、Flags、Fragmentation offset）、何处分片和重装 MTU IPv6分组格式 下一个头部相关 IPv4到IPv6的过渡 双协议栈 隧道技术 头部转换 第21章 地址映射、差错报告和多播 ARP：ARP的概念、功能、分组格式、封装、4种操作 DHCP的概念 ICMP：ICMP的概念、报文格式、差错报告、Ping* IGMP的基本概念 第22章 传递、转发和路由选择 转发技术与转发过程 路由表、地址聚合和最长掩码匹配 Dijkstra算法和Bellman-Ford* 算法 单播路由协议：AS的概念、域内、域间路由选择协议、RIP协议路由表生成的过程、OSPF协议的原理 多播的概念和多播路由（了解） 第五部分 传输层 第23章 UDP、TCP和SCTP 端口、套接字 UDP协议：UDP协议的概念、数据报结构、校验和的计算、UDP的操作 TCP：TCP的特点与服务、段格式、三次握手（建立连接和拆除连接）、TCP流量控制（信贷滑窗协议）、TCP差错控制 TCP有关字段和序号（SYN、ACK、seq、ack*）、段序号、字节编号 第24章 拥塞控制和服务质量 TCP拥塞控制（慢启动、拥塞避免、拥塞检测） 发送窗口=min（接收窗口rwnd，拥塞窗口cwnd） 第六部分 应用层 第25章 域名系统 DNS*的工作原理 域名空间 通用域、国家域和反向域 域名解析 DNS报文 第26章 远程登录、电子邮件和文件传输 Telnet的基本概念 电子邮件：电子邮件的架构、邮件报文、SMTP和MIME、POP3和IMAP 文件传输：FTP的架构、FTP的连接、FTP的传输方式、FTP的端口 第27章 万维网与超文本传输协议 URL、Cookies的概念 HTTP的概念、报文结构、HTTP操作 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH1.html":{"url":"computer-network/CH1.html","title":"CH1","keywords":"","body":"总线型 总线拓扑结构是多点连接，由一条较长的线缆作为主干来连接网络上的所有设备 电信（telecommunication）在一定距离上的通信 数据：以任何格式表示的信息，该格式需要创建和使用数据的双方达成共识 数据通信，在两台设备之间通过诸如线缆的某种形式的传输介质进行的数据交换 组件：报文 发送方 接收方 传输介质 协议 数据表示：文本 数字 图像 音频 视频 数据流：单工 半双工 全双工 一、五个组件 报文（message） 发送方 sender source 接收方 receiver destination 传输介质 transmission medium 协议 protocol 管理数据通信的一组规则，表示通信设备之间的一组约定 二、数据的表示 三、数据流 三种 四、网络 network是通信链路连接起来的设备（节点）的集合，一个节点是计算机，打印机或者能够发送、接收由该网络上的其他节点产生的数据的任何其他设备 五、分布式处理 将任务给多台计算机 集中式的反义词、分散的 当前通信系统的流行处理方式 六、网络准则 性能： 吞吐量 throughput 延迟 delay latency 可靠性 Reliablity 故障出现的频率 故障恢复所花费的时间 灾难中的健壮性 安全性 Security 保护数据免受未授权的访问 传输过程中免受攻击 七、物理结构 Physical Topoloy 链路 Link 将设备由一台设备传输到另一台设备的通信通路 连接类型 点到点（point to point）： 多点连接 （multipoint connection, multidrop connection）： 八、拓扑结构 环形 混合型拓扑结构 九、网络模型NetworkModel OSI Open System Interconnection 模型：7层模型 Internet模型：5层模型 十、网络分类 按地理范围划分 名称 英文 缩写 局域网 Local area network LAN 广域网 Wide area network WAN 城域网 metropolitan area network MAN 个人网 personal area network PAN 十一、因特网 internet：互联网：两个或多个可以互相通信的网络 Internet：因特网，I大写 因特网层次结构 十二、协议和标准 协议是规则的同义词，然后讨论标准。 十三、协议 协议 通信内容 通信方式 通信时间 要素 语法syntax 语义semantics 时序timing 标准：达成一致的规则 十四、标准的分类 事实上的标准，TCP/IP 法定的标准，OSI/RM var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH2.html":{"url":"computer-network/CH2.html","title":"CH2","keywords":"","body":"第二章网络模型 ISO是组织，OSI是模型 OSI模型（7层） 跨系统 可理解并设计一个灵活、健壮和可互操作的网络体系结构 OSI模型提供了一个可以用来进行网络系统设计的层次化框架，由7个相互独立但又有互相关联的层次组成 物理层 物理介质上传输位流所需的功能，定义了接口与传送戒指的机械和电气特性 物理层负责位从一跳到另一跳的传递 数据链路层 将物理层的数据无差错地传递给网路层 负责将帧从一跳传递到下一跳 跳到跳的传递 网络层 负责将各个分组从源地址传递到目的地址 逻辑寻址 路由选择 从源到目的地址 物理层和数据链路层都是一跳到下一跳 传输层 报文，从一个进程到另一个进程 报文 进程到进程 端到端可靠运输 服务访问点SAP/端口Port（service access port） 分段Segment和组装 连接控制 流量控制 差错控制 一个报文在进程间的可靠传递 会话层session 对话控制 同步 同步点 经常在套接字中使用 经常在套接字中使用 表示层 翻译 加密 压缩数据 应用层 向用户提供服务 二、TCP/IP协议族 一个是模型 一个是协议族 OSI之前开发的，并不与OSI模型的各层严格对应 三、四个层次 物理层 数据链路层 网络层 传输层 应用层 所谓应用层占据了后三层 传输层是 TCP UDP STCP 网络层是IP（加上其他配套协议） 四、PDU 协议数据单元 PDU是指对等层次之间传递的数据单位。 物理层的——数据位bit 数据链路层——数据帧 网络层——数据报 传输层——数据段 更高层次——数据 五、一些协议 六、寻址 TCP/IP协议簇的应用网络中使用4层地址 物理地址 逻辑地址 端口地址 专用地址 Specific address 各层与地址的关系 七、物理地址 别名 链路地址 硬件地址、 MAC地址 局域网或广域网中定义的节点地址。 包含在数据链路层的帧中 最低级的地址 长度和格式可变，与网络有关。通常以以太网使用的网卡上的48位物理地址。 八、IP地址🌰 图显示了由两个路由器连接三个局域网的互联网的一部分。为了相互的连接，每个设备(计 算机或者路由器)都有一对地址(物理地址和逻辑 地址)。在这个例子中，每台计算机只与一个链路相连，因此只有一对地址。然而，每个路由器和三个网络相连(在图中只显示了两个)。因此每个路 由器有三对地址，一对地址对应一个连接。 九、端口地址🌰 两台计算机通过网络进行通信。 发送方计算机有三个进程正在进行，分别使用端口 a，b，c。同时，接收方计算机有两个进程正在进 行，端口地址分别是 j 和 k。在发送方计算机中的 进程 a 需要和在接收方计算机的进程 j 进行通信。 尽管从跳到跳物理地址会改变，但是逻辑地址和端 口地址从源地址到目的地址均保持不变。 跳到跳过程中物理地址改变，逻辑地址不变 十、专用地址 面向对象应用被设计为专用地址 mail://xxxx ftp://xxxx var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH3数据与信号.html":{"url":"computer-network/CH3数据与信号.html","title":"CH3数据与信号","keywords":"","body":"[toc] CH3 数据和信号 物理层通过传输介质以电磁信号的形式传输数据。 数据要进行传输，必须将其转换为电磁信号 模拟和数字 数据和信号可以是模拟analog的，也可以是数字digital的 数据可以是模拟的也可以是离散的 模拟数据是连续的，采用连续值 数字数据有离散状态，采用离散值 信号signal可以是模拟的也可以是数字的 模拟信号在一定范围内有无穷多个值 数字信号只能有有限个数值 周期信号和非周期信号 模拟和数字信号有两种形式 周期信号 periodic signal 非周期信号 nonperiodic signal 往往使用周期模拟信号和非周期数字信号 周期模拟信号：需要更少的带宽（CH5） 非周期数字信号：可以表示数据的变化 周期模拟信号 简单类型： 正弦波sine wave 复合类型：多个正弦波信号组成 正弦波 由以下三个参数决定 峰值振幅 peak amplitude 频率 frenquency 相位 phase 峰值振幅 最高强度的绝对值，单位v，伏特 周期和频率 f=\\frac{1}{T} 频率单位Hz。 如果信号在短时间内发生变化，则频率高，否则频率低 两个极端 信号持续不变化：频率是0 瞬间变化：频率无穷大。 相位phase 波形相对于时间0的位置 波长wavelength 一个简单信号在一个周期能传播的距离 波长=传播速度\\times 周期 \\\\ \\lambda=\\frac{c}{f} 时域和频率 时域图time-domian plot显示了信号振幅随时间的变化。 为了表示振幅与频率的关系。可以用频域图frequency-domain plot 单个峰值，表示一个完整的正弦波 复合信号 复合信号composite signal由许多正弦波构成 单一正弦波在数据通信中没有用户，我们需要发送复合信号，复合信号由许多简单正弦波组成 傅里叶分析：任何符合信号都是由具有不同频率、相位和振幅的正弦波信号组合而成的 周期复合信号 f: 第一谐波；3f: 第三谐波；9f：第九谐波 非周期复合信号 带宽bandwidth 复合信号包含的频率范围称为带宽 通常是两个数的差值。如果一个复合信号包含1000到5000的频率，那么带宽就是4000 最高频率-最低频率 例子 周期复合信号 非周期复合信号 调幅AM和调频FM 后面会说 黑白电视 电视屏幕像素组成。白或黑。 数字信号 数据可以用数字信号表示。1编码为正电平，0编码为0电平。 一个电平也可以表示为多个位。比如，四个电平情况下，一个电平表示两位 信号有L个电平，则每个电平表示$\\log_2^L$个位 比特率 bit rate 1秒发送的位数，单位bps 🌰 100\\times 24\\times 80\\times 8 /60=256\\text{kbps} 位长 bit length 一个位在传送介质上的距离 位长=传播速度\\times位持续时间 数字信号是一种复合模拟信号 基于傅里叶分析，数字信号是复合模拟信号。带宽无穷大 数字信号的传输 数字信号由0到无穷大的频率组合成的复合模拟信号。 两种不同的方法创术数字信号： 基带传输 宽带传输 基带传输baseband 通过通道发送数字信号。该信号不转换成模拟信号。 需要一个下限是0的低通通道low-pass band 有低通通道就可以进行基带传输 有两种情况 宽带宽 宽带窄 宽带宽 如果真想保持垂直段垂直，水平段水平，则需要发送整个频谱。 如果真的有一个无穷大带宽的介质，是有可能实现的。 但是实际上，频谱边界的频率振幅过小以致于可以忽略不计 只要介质有足够宽的带宽，就可以保留很好地准确性进行通信 有限宽带 将数字信号近似为模拟信号 大致近似 假定数字信号bit rate=N 考虑最坏情况：01010101,10101010，这种情况下频率最高$f=\\frac{N}{2}$。使用该频率的模拟信号 考虑3位的情况 000,111.频率=0 101,010，频率=$\\frac{N}{2}$ 011，100，001，110：$f=\\frac{N}{4}$ 第一谐波：$f=\\frac{N}{2}$ 更好近似 增加频率的更多谐波。 基带传输中，带宽与比特率成正比，如果我们需要更快发送位，需要更大的带宽 🌰如果我们需要用基带传输发送1Mbps，那么低通通道需要的带宽是多少？ 答：取决于准确性： 最小带宽，大致近似：$B=\\frac{bit \\quad rate}{2}$ 第一谐波+第三谐波：$B=3\\times{\\text{500kHz}}=1.5MHz$ 1+3+5：$B=5\\times\\text{500kHz}=2MHz$ 宽带传输（使用调制） 宽带传输或调制就是把数字信号转换成模拟信号传输，调制允许我们使用带通通道bandpass channel 带宽不从0开始 比低通通道更可用 🌰 通过电话线传输计算机数据。电话用户线连接住所到中心电话局。使用有限带宽（0~4kHz）。一般把它看做带通通道， 计算机把数字信号转换成模拟信号 发送模拟信号 安装两个转换器 发送端把数字信号转换成模拟信号 接收端反之 转换器称为调制解调器 🌰数字蜂窝电话 数字蜂窝电话把模拟信号转换成数字信号 主叫方和被叫方之间只有一条带通通道 有效带宽是M 如果有1000人同时交谈 一次通话的有效带宽是$\\frac{W}{1000}$ 所以必须把数字信号转换成复合模拟信号 数字蜂窝电话把模拟音频信号转换成数字信号 再把数字信号转换成模拟信号通过带通通道传输 传输减损 通常有三种类型的减损：衰减、失真和噪声 衰减attenuation 失真distortion 噪声noise 衰减 attenuation 意味着能量的损失，一部分能量转换为热能。 解决方法 使用放大器amplifier放大信号 分贝dB 工程上用于计算两种信号之间相对强度。若信号衰减，则分贝为负值 dB = 10 \\log_{10}\\frac{P_2}{P_1} 失真distortion 信号改变了形态或形状 噪声noise 热噪声、感应噪声、串扰和脉冲噪声 信噪比SNR signal-to-noise ratio SNR=\\frac{平均信号功率}{平均噪声功率} 我们需要考虑平均信号功率和平均噪声功率。因为他们会随时间变化 可以用分贝描述，$SNR_{dB}$定义如下 SNR_{dB}=10log_{10}SNR 🌰 数据速率限制 数据速率取决于三种因素 有效带宽 使用的信号电平 通道的质量（噪声的电平） 两个公式 奈奎斯特：无噪声通道 香农定理：噪声通道 无噪声通道奈奎斯特公式 Nyquist bit rate bit rate = 2\\times 带宽 \\times \\log_2L 带宽：通道带宽 L：同于表示数据的信号电平数量 噪声通道：香农容量定理 Shannon Capacity噪声通道理论上最高数据速率 通道容量=带宽\\times \\log_2{(1+SNR)} 通道容量：通道的传输容量，每秒的比特数 极端情况SNR$\\rarr0$ C=B\\log_2 (1+SNR)=B\\times0=0 与带宽无关。bit rate = 0 🌰 B=3000Hz\\\\ SNR=3162\\\\ C=B\\log_2 (1+SNR)=3000\\times \\log_2 3163 🌰 SNR_{dB}=36\\\\ SNR=10^{3.6}\\\\ B=2\\times 10^6Hz\\\\ C=2\\times{10^6}\\times\\log_2(10^{3.6}+1) 性能 带宽 以Hz衡量带宽 复合信号包含的频率范围或通道能通过的频率范围 以每秒比特数衡量的带宽 100Mbps 通道或链路中位传输的速率 吞吐量 throughput用来衡量通过网络发送数据的快慢 延迟 从源开始发出到整个报文完全到达目标的时间 传播时间propagation time 传输时间transmission time 排队时间queuing time 处理延迟processing delay 延迟=传播时间+传输时间+排队时间+处理延迟 传播时间propagation time 传播时间=\\frac{距离}{传播速度} 传输时间 transmission time 传输时间=\\frac{报文长度}{带宽} 带宽时延积 带宽时延积是能充满链路的位的个数。 为了使用链路的最大容量，我们需要脉冲长度是带宽和延迟乘积的二倍（充满全双工通道） var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/ch10检错与纠错.html":{"url":"computer-network/ch10检错与纠错.html","title":"ch10检错与纠错","keywords":"","body":"ch10检错与纠错 en ZH_CN Types of errors 差错类型 Redundancy 冗余 Dectection Versus Correction 检错和纠错 Forward Error Correction Versus Retransmission 前向纠错和重传 Coding 编码 Modular Arithmetic 模运算 一、差错类型 单比特差错 非常少见 突发性差错 数据单元有两位或多为发生变化 更多 8位突发性差错 不一定连续 二、检错和纠错 为了检测或纠正差错，需要发送除了数据外的额外冗余位 检错：是否发生错误 纠错：哪里发生错误 纠错方法：前向纠错和重传 三、编码和译码 信息+冗余 不可靠传输 校验 编码 块编码 卷积编码 四、块编码BLOCK CODING 模运算 只使用0~(N-1)的整数 在块编码中，把报文分成块，每块k位，称为数据字。并增加r个冗余位使其长度变为n=k+r，形成n位的块称为码字 数据字和码字 下面黄色的，有$2^n$种组合，但是只有$2^k$有效 差错检测 接收方有有效码字列表 原来的码字已改变成无效的码字 如果码字在传输中被破坏，且仍然是有效的码字则差错无法被发现 块编码检测过程 检错码是为某些类型的差错而设计。 只能检测这些类型的差错。其他类型的无法检测 差错纠正 检错：接收方只需知道接收到的码字是无效的 纠错：接收方需要知道发送的原来的码字 纠错更复杂，需要更多冗余位 左边编码器，右边译码器 汉明距离 两个相同长度字的汉明距离是对应位不同的数量。它是差错编码的核心概念 $d(x,y)$总是大于0 计算：对两个字异或后计算1的个数 最小汉明距离 最小汉明距离是一组字中所有可能对的最小汉明距离。 编码方案写成$C(n,k)$和一个单独的$d\\min$表达式，n是码字的长度，k是数据的位数，$d\\min$是最小汉明距离 接收到的码字和发送的码字之间的汉明距离是传输中被破坏的位数 为了保证检测中最多s个错误，块编码中最小汉明距离一定是$d_\\min=s+1$ 为了保证最多能纠正t个差错，块编码中的最小汉明距离是$d_\\min=2t+1$ 🌰 这个方案最多检测3个错误 最多纠正1个差错 需要的最小距离是奇数 线形块编码 所有块编码都属于一个称为线性块编码的子集 在线性块编码中，任意两个有效码字的异或（模2加）生成另一个有效码字 线性块编码的最小汉明距离：具有最小1的个数个非0有效码字中1的个数 简单奇偶校验码 n=k+1，且$d_\\min=2$的单比特检错编码 假设发送方发送数据字1011，生成码字10111 没有差错 单个位差错 两个位差错 三个位差错 能检测出奇数个差错 二维奇偶校验编码 能检测出所有3位或3位以下的错误，此时至少在某行或某列上有一位错误、奇数位错误以及很大一部分偶数位错误 汉明编码 本书只讨论最小汉明距离为$d\\min=3$的汉明码，它最多能检测出2位差错和最多纠正1位差错 选择m>=3的整数，则码字长n、数据字长k和校验位r的关系位 n=2^m-1,k=n-m,r=m 汉明码$C(7,4)$ 逻辑判定 生成器不关心 无差错 奇偶位的差错 矫正子对的值是每个比特值的组合 汉明编码提高突发错误能力 循环码 码字循环移位，结果是另一个码字 循环冗余校验 k位数据字，n位码字 校验和与反码 用校验和进行简单检错的方法常用于Internet 反码 反码算法： n位表示0到$2^n-1$的无符号数 如果这个数组多于n位，最左边的额外位加到最右边的n位 一个数的负数可用该数所有位取反（0变成1，1变成0） 等同$2^n-1$ 🌰 反码4位表示21 10101，最左边的位加到最右边的4位上。 因特网校验和 使用16位校验和。 发送方站点 报文划分为16位字 校验和字的值为0 所有字包括校验和使用反码运算相加 对这个和求反变成校验和 校验和随数据一起发送 接收方，差错检测 报文包括校验和划分为16bit字 用反码加法将所有字相加 对该和求反生成新的校验和 如果校验和是0 接收报文；否则，放弃报文 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/ch11数据链路控制.html":{"url":"computer-network/ch11数据链路控制.html","title":"ch11数据链路控制","keywords":"","body":"3数据链路控制 成帧0 流量控制 差错控制 协议0 无噪声通道 有噪声通道 高级数据链路控制HDLC 点到点PPP PPPoE (了解) 一、成帧 成帧方式 防止混淆 字节填充 位填充 将一组比特位组成帧，一遍帧和帧之间可以识别。 帧 将一条从源端到目的端的报文分离开。 Fixed-size framing Variable-Size Framing 成帧方式 固定大小：ATM网络 可变长度 面向字符 面向位 从上一层来的数据：以字节形式 flag标记一帧的开始和结束 字节填充 当数据中存在一个标记字符（flag）或者换义字符时，添加一个额外字节的过程 流量控制和差错控制 通常一起称为数据链路控制 Flow Control Error Control 流量控制 一系列程序，用来限制发送方在等到确认之前发送的数据数量，使不会超过接收能力 接收方有一定缓存，可以存一部分逐步消费 数据链路层的差错控制基于自动重复请求（ARQ）重传数据 5种协议 两种帧： 确认帧:ACK接收——发送 否定确认帧：NAK——表明确认数据收到但是有错误要求重发 捎带技术 无噪声信道 最简单协议 停止等待协议 不适用差错控制 有噪声信道 停止等待ARQ 回退N帧ARQ 选择重复ARQ 最简单协议 没有流量控制 没有差错控制 发送方 事件：从网络层发出请求 发送好多帧 接收方 事件：网络层传来数据 算法 发送方 while(true){ //永远重复 WaitForEvent(); // 等待事件 if(Event(Request)){ // 包 getData(); //发 MakeFrame(); SendFrame(); } } 接收方 永远重复 等待事件 接受 🌰 发送方不考虑接收方是否接受到 停等协议 没有差错控制 有流量控制 流量控制的实现 发送方发送一帧后，只有收到ACK才会发送下一个 while(true){ canSend = true; WaitForEvent(); if(Event(RequestToSend) and canSend) { GetData(); MakeFrame(); SendFrame(); canSend = false; } WaitForEvent(); if(Event(ArrivalNotification)) { ReceiveFrame(); canSend(); } } 接收方 数据来自物理层 处理 数据交给网络层 🌰 流量图 要求会画，不用这么漂亮 停等ARQ 停止等待 ARQ 自动重发 停等协议没有重发 有差错控制 保留已发送帧的副本 重传定时器到期后重传这个帧实现差错检测 使用序列号为每一个帧编号（差错控制需要） 序列号基于模2运算 ACK确认帧也会丢失，因此也需要序列号 ACK编号是期望收到的下一帧的编号（模2运算） 一次一帧 Sn：窗口 发送方事件 网络层请求 物理层通知：ACK 超时 接收方事件 物理层通知 算法 Sn = 0; canSend = true; while(true){ WaitForEvent(); if(Event(RequestToSend) and canSend){ GetData(); MakeFrame(Sn); StoreFrame(Sn); StartFrame(Sn); StartTimer(); Sn = Sn+1; canSend = false; } WatiForEvent(); if(Event(ArrivalNotication)){ ReceiveFrame(ackNo); if(not corrupted and ackNo == Sn) { stopTimer(); purgeFrame(Sn-1); //清除副本 canSend = true; } } if(Event(Timeout)){ StartTimer(); ResendFrame(Sn-1); } } 序列号不匹配也会发送ACK，但是序号不加1，还是这一帧 这里能看出超时 路上丢失 到了但差错 🌰 都是模2 回退N帧ARQ 序列号模$2^m$，其中m为序列号字段长度 滑动窗口：定义发送方和接收方关心的序列号范围 只有发送窗口内的才能发送 Sn指向下一个发送的帧 窗口大小$2^m-1$ 收到某帧后 左边界右移 右边界右移 发送窗口 Sf Sn Ssize 小于$2^m$一般$2^m-1$ 当有效确认到达时 发送窗口滑动 一个或多个帧时隙 接收窗口 $R_n$定义了一个大小为1的接收窗口 正确的帧到达时，接收窗口滑动到下一个时隙 确认 当一个帧安全有序到达时，接收方发送肯定的确认 如果一个帧被破坏或次序颠倒 接收方不响应 丢弃后来的所有帧 知道收到一个期待帧 接收方不响应使得不被确认帧的定时器过期，发送方从此帧开始重发所有帧 接收方发送一个累积确认 观察左边情况，如果左边窗口大小是$2^m$，则会发送Frame3，然后如果依然超时，则发送Frame0，而此时接收窗口也想要Frame0，这样不行。 所以，发送方窗口必须小于$2^m$ 接收方窗口只能是1 接收方 累积确认 🌰 ACK丢失 丢失的ACK不需要重发 发送帧丢失 问题 接收方只有一个变量，不能解决失序问题 在有噪声信道效率低下，需要重发多个帧 选择重复ARQ 窗口尺寸更小$2^{m-1}$ 接收窗口与发送窗口一样大 选择重传ARQ 发送窗口 接收窗口 窗口大小 $2^{m-1}$ 定时器启动、重启和停止 一组连续帧到达且从窗口起点开始则可以向网络层交付 每个而窗口位置只发送一个NAK，并指向窗口第一个时隙 数据交付到网络层才发ACK 捎带（了解） HDLC高级数据链路控制协议(非重点) High-level Data Link Control 面向位000 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH14 无线局域网WLAN.html":{"url":"computer-network/CH14 无线局域网WLAN.html","title":"CH14 无线局域网WLAN","keywords":"","body":"CH14 无线局域网WLAN 一、IEEE 802.11 IEEE定义的无线局域网规范 涵盖 物理层 数据链路层 体系结构 基本服务集（BSS） 扩展服务集（ESS） 二、基本服务集BSS Basic Service set BSS 无线局域网的积木块 一个基本服务集由 固定的或移动的无线站点 访问点（Access point ，AP）的中央基站 三、扩展服务集 Extend Service Set ESS 两个或更多个带有AP的BSS组成。 通过一个分布式系统（通常是有线局域网将各个BSS连接在一起）。 分布式系统连接到AP， 该分布式系统可以是任何的IEEE局域网 以太网 注意，包含两种类型的站点 移动站点：BSS内的一个普通站点 固定站点：属于有线网络的一部分的AP站点 注意：一个移动站点可以同时属于多个BSS 站点类型 根据站点在无线局域网中的移动性 IEEE 802.11分为三种类型 不迁移：固定的或仅在BSS内部移动 BSS迁移：站点可以从一个BSS移动到另外一个**BSS**，但仅在一个ESS中 ESS迁移：站点可以从一个ESS移动到另一个ESS，不保证通信在移动中是连续的 MAC层 IEEE 802.11定义了两个MAC层 分布式协调功能（DCF） 点协调功能（PCF） 局域网的IEEE标准 分布式协调功能 IEEE在MAC子层定义的两种协议之一称为分布式协调功能（distributed coordination function DCF）。 DCF使用CSMA/CA作为访问方式， Link{@ CH12} 不能用CSMA/CD 为了进行冲突检测：站点必须能够同时发送数据和接收冲突信号 因为隐藏的站点问题：可能检测不到冲突 站点间的距离可以很大：信号衰减会使得一端的站点无法侦听到另一端的冲突 处理流程图 CSMA/CA 为CSMA增加了一个冲突避免（Collision Avoidance） 在使用CSMA/CA的同时还增加使用确认机制 帧交换时序CSMA/CA 在发送一个帧之前，源站点通过检测载波频率的能量级来侦听介质 在通道空闲之前，通道使用带有补偿的持续策略 站点发现通道空闲之后，它等待一个DIFS（分布式帧间间隔）的时间周期，然后发送一个请求发送的控制帧 目的端接收到RTS并等待一个SIFS（short interframe space， SIFS）的短暂时间 目的端向源站点发送一个清除发送（CTS）的控制帧 源端等待一个与SIFS相等的时间，发送数据 目的端收到，等待一个SIFS，发送ACK（在这个协议中，没有任何方法检查数据是否已经成功到达目的站点） CSMA/CD中没有冲突就是向源站点表示数据已经到达 NAV网络分配矢量（冲突避免） 如果一个站点获得访问，那么其他站点需要推迟发送数据 当一个站点发送RTS帧（Request To Send），它包含了需要占据通道的时间。 一个站点发送时，其他站点不能发送 受这一传送所影响的站点建立一个网络分配矢量（network allocation vector NAV）的定时器 NAV指出允许这些站点下次检测还需要多长时间 也就是 每个站点检查物理介质是否空闲之前必须检查NAV是否过期 握手冲突 点协调功能（PCF） Point coordination function ,PCF。它在DCF的上面实现，主要用于对时间敏感的传输 集中式、无竞争轮询方式 AP对可以被轮询的站点进行轮询 站点依次被轮询，将数据发送给AP 有比DCF更高的优先级 定义了另一套帧间间隔（interframe space） PIFS比DIFS端 SIFS与DCF的一样 意味着如果同一个站点想用DCF，一个AP想用PCF，AP有优先权 分段 为什么分段？ 无线环境噪声很多，被毁坏的帧必须重传。将一个大的帧分割为多个更小的帧。 帧格式 MAC层包含9个字段 帧控制（FC）：FC字段为2字节，定义了一个帧的类型和一些控制信息 D：定义了用于设置NAV值的时间间隔时间。在一个控制帧中，这个字段用来定义帧的ID 地址：有4个地址字段，每个6字节。 序列控制：本字段定义帧的序列号，用于流量控制 帧主体：0~2312字节 FCS：4字节 CRC-32差错检测序列 寻址机制 四种情况，由FC字段两个标记定义。每一个标记可能是0或1。 MAC帧的四种地址地址1~4的解释取决于这些标记的值 隐藏站点和暴露站点问题 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH15 连接局域网、主干网和虚拟局域网.html":{"url":"computer-network/CH15 连接局域网、主干网和虚拟局域网.html","title":"CH15 连接局域网、主干网和虚拟局域网","keywords":"","body":" CH15 连接局域网、主干网和虚拟局域网 物理层和数据链路层设备 连接设备 物理层以下：无源集线器 物理层：中继器，有源集线器 物理层和数据链路层：网桥和两层交换机 物理层、数据链路和网络层：路由器、三层交换机 所有五层：网关 无源集线器 Passive Hubs 连接器，连接不同分支的线路 星型拓扑以太网中：来自不同站点的信号冲突点，集线器是冲突点 是介质的一部分。 工作在物理层以下 中继器 仅工作在物理层 扩展局域网的长度 不能连接不同协议局域网 连接的是局域网的两个分段 转发每一帧，没有过滤功能 可重新生成原始的位模式，是再生器，不是放大器 常用语星型结构，可以多级级联 以太网10Base-T有最大长度限制100m，用中继器可以突破该限制 有源集线器 Active Hub 是一个多端口的中继器， 网桥 Bridges 工作在物理层和数据链路层 可以检查MAC地址（源和目的） 过滤 有一个端口地址映射表 检查帧的目的地址，决定是否转发或丢弃。 转发时必须指定端口 不改变帧中包含的物理地址MAC地址 透明网桥transparentbridge 有过滤功能的中继器 站点意识不到其存在 自动建立转发表 避免内循环 转发 动态表 生成树 每个LAN都能通过唯一路径到达其他任何LAN。 成本：最小跳数 网桥到LAN=1 LAN到网桥=0 每个网桥有内置ID。每个网桥广播该ID，选择ID最小的网桥作为根网桥。 这个算法尝试找出从根网桥到其他每个网桥或LAN的最短路径 基于生成树， 属于生成树部分的端口为转发端口（forwarding port） 不属于的端口为阻塞端口（blocking port） 某个网桥移除或更新都要重新更新生成树 实际情况中网桥配置了软件包动态完成该过程 网桥互相发送BPDU，网桥协议数据单元来更新生成树 源路由网桥source routing bridge 另一种防止循环的方法 用网桥连接不同局域网 网桥在数据链路层可以连接不同协议的局域网，如以太网连接到无线局域网 两层交换机 Two-Layer Switches 是一个有许多端口且性能更好的网桥。有少量端口的网桥只可以连接几个局域网。有更多端口的交换机可以一个端口对应一个站点 优点 不同拓扑局域网接入不用进行改变 扩容简单 路由器 Routers 基于分组的逻辑地址路由分组，通常连接LAN和WAN，有一张表用来决策路由。路由表通常是动态的，用路由协议更新。 三层交换机 Three-Layer Switches 是路由器，但是更快更复杂。交换光纤允许更快的表查询和转发。 随着技术的发展，网桥接口日益增多，发展成现在的交换机。 使用交换机组网与集线器组网相比具有以下特点: 端口独享带宽:集线器是共享带宽; 安全:交换机根据MAC地址只转发到目标端口; 全双工通信; 全双工不再使用CSMA/CD协议; 接口可工作在不同速率:交换机使用存储转发技术; 转发广播帧:转发到除了发送端口以外的所有端口。 网关 Gateways 网关通常是工作在因特网全部五层或OSI模型全部7层的计算机。 网关拿到一条应用消息，读取并解释消息。它能作为两个使用不同模型的互联网的连接设备。 主干网 主干网允许连接多个局域网。主干网本身也是使用局域网协议的局域网。 总线型 星型 总线型主干网 10Base5 10Base2 虚拟局域网VLAN 交换机间的通信 表维护 帧标记 时分多路复用 中继器只再生信号不放大信号 检查帧的目的地址，决定该帧是转发还是丢弃，转发必须指定端口。 连接的站点完全意识不到的网桥，网络中增加或移除不需要重新配置 帧必须能从一个站点转发到另一个站点 通过学习网络中帧的传输，自动建立转发表 必须避免系统内循环 将电缆分割成几段，分段间安装中继器 转发端口转发网桥接收到的帧 阻塞端口阻塞网桥接收到的帧 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH19逻辑寻址.html":{"url":"computer-network/CH19逻辑寻址.html","title":"CH19逻辑寻址","keywords":"","body":"第四部分网络层 负责计算机间传输分组 IPv4地址：A、B、C、D和E类地址、掩码、子网和超网的概念 子网划分、子网的地址范围、地址聚合 NAT的概念 IPv6地址 可能经过多个网络，数据链路层负责在同一网络（链路）上两个系统之间传输分组 网络层保证每一分组从源到它的最后目的地 网络层增加一个头部 包含来自上一层分组的发送方与接收方逻辑地址，如果分组经过因特网传输，还需要寻址系统来识别源与目的地址 当若干个独立的网络（链路）连接在一起组成一个互联网时，路由器或交换机对分组进行路由选择到达它的最终目的。 CH19逻辑寻址 网络层上的通信是主机到主机。 [TOC] IPv4地址 是一个32位地址，唯一地与通用地定义了一个连接在因特网上的设备 地址空间 $2^{32}$ 标记法 二进制标记法和点分十进制标价法 分类寻址 地址类和地址块 ABCDE类 A类：为具有大量主机的机构设计 B类：为可能具有数万台主机或路由器的中型组织机构所设计的 C类：为具有少量主机或路由器的小型组织机构所设计的 D类：为多播设计 E类：为将来保留 网络号与主机号 ABC地址分为网络号（netid）和主机号（hosted） 注意：只有ABC有 掩码mask 无类域间路由选择（Classless Interdomain Rounting CIDR） 子网化subnetting 子网化可将这些地址划分为几个类组，并赋予每一组为较小的网络（称为子网，subnet） 在子网掩码中在增加1的个数。 超网化supernetting 一个组织机构能将C类地址构成更大范围的地址空间。一个组织机构能将几个C类块地址构成更大范围的地址空间——超网 需要申请一组C类地址块而不是仅仅一个 比如需要1000个地址，需要4个C类地址块 超网化是在掩码中减小1的个数 无类寻址没有超网化的需要 地址耗尽 AB类耗尽，C类对多数中等规模的组织机构还是太小 无类寻址 classless addressing 没有类但仍提供地址块 地址块 按需分配 限制条件 块中的地址必须连续 一个块中地址的个数是2的整数次次幂 块的起始地址必须能被块的个数整除 掩码 块地址定义：块中任一地址和掩码 一个掩码32位，n位1和32-n位0。 用斜杠（CIDR标记法） 用x.y.z.t/n来定义 地址和/n可以完全定义整个地址块（起始地址、最后地址和地址个数） 🌰 无类寻址.网络地址 块的起始地址，定义该组织机构的网络。 起始地址是路由器用来将报文发送到该组织机构外部的地址。 路由器有两个地址，一个属于获准的块，另一个属于路由器另一端所在的网络 起始地址不分配给任何设备，用做向互联网其他部分表示该网络的网络地址 特殊IP地址 层次结构 IP也有层次结构 二级层次结构x.y.z.t/n，左边n位是网络前缀，后缀是主机地址。 三级层次结构：子网化 多级层次结构 网络地址转换 Network Address Translation NAT 专用地址和全球地址 内部拥有大量的地址，外部只有少量的地址。内部通信用内网地址，外部通信用外网地址。 通过一台运行NAT软件的路由器，站点必须只有一条与全局因特网相连的链路。 专用地址只能用于一个机构内部通信，不能用于和因特网上的主机通信 专用地址只能用做本地地址，因特网路由器上，对目的地是专用地址的数据报一律不转发 采用专用IP地址的网络称为专用互联网、本地互联网或专用网。 专用IP地址也称为可重用地址 地址转换 外发的分组都通过NAT路由器发送出来，该路由器全球NAT地址来替代分组中的源地址。所有输入的分组也要通过NAT路由器， 转换表 使用一个IP地址 运用IP地址池 同时运用IP地址和端口号NAPT（Network Address and Port Translation） 把源IP地址和TCP（或UDP）端口号都进行转换 专用网内不同的源IP地址都转换为同样的公网IP地址 对源主机采用的TCP端口号，都转换为不同的新的端口号 机制的特殊性（与普通路由器的区别） 普通路由器转发时不改变源IP地址和目的地址；NAT路由器会改变源地址或目的地址 普通路由器在转发分组时工作在网络层，NAPT路由器要查看和转换运输层的端口号 IPv6 IPv6地址由16字节（8位组）组成，长度128位。 一个IPv6地址的长度是128位 冒号标记法 缩短 IPv6许多数字是0。一个部分中开始的0可以省略。全0可以移去 地址空间 单播地址unicast address 多播地址multicast address 任播地址anycast address 保留地址 reserved address 未指明地址 unspecified address 环回地址 兼容地址 映射地址 本地地址 本地链路地址 Link local address 192.168.1.2/24 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH20IP协议.html":{"url":"computer-network/CH20IP协议.html","title":"CH20IP协议","keywords":"","body":"CH20IP协议 考点 第20章 IP协议 IP分组（数据报）的格式 分片(Identification、Flags、Fragmentation offset）、何处分片和重装 MTU IPv6分组格式 IPv4到IPv6的过渡 网际互联 网络的物理层和数据链路层在本地运行。这两层共同负责网络相邻节点间的数据传递。 这个互联网由五个网络组成：四个LAN一个WAN。 A发送数据分组到D需要经过三个链路，每个链路包括两个物理层和数据链路层 S1如何知道应该从f3接口发送出去，前两层没有规则帮助R1做出正确决策。而且，帧也没有携带任何路由选择信息。帧中只包含主机A的MAC地址和S1的MAC地址 网络层需求 网络层负责 主机间的传递 通过路由器或交换机对分组进行路由选择 网络层总的思想 源端网络层：将来自另一个协议的输入数据生成一个分组，分组的头部包含源和目的逻辑地址以及其他信息。网络层负责检验路由表寻找路由选择信息。如果分组太大，就要分段。 交换机或路由器中的网络层：当一个分组到达时，路由器或交换机就从他的路由选择表中找到一个必须将其发送出去的接口。改变头部的某些内容后的分组按照路由选择信息再传送给数据链路层 目的端的网络层负责地址验证：确保分组组中的目的地址与主机地址是相同的。如果分组是一个分段，网络层就等待所有的分段到达后再对其进行重组，然后再将重组后的分组交给传输层。 作为数据报网络的因特网 交换可以分为 电路交换 分组交换 虚电路方法 数据报方法 报文交换 在网络层，因特网使用数据报交换方法。它利用网络层所定义的全球地址，从源端到目的端路由分组 因特网的网络层交换是利用数据报分组交换的方法实现的 作为无连接网络的因特网 面向连接的服务 源端首先与目的端建立一个连接 连接建立，分组按照顺序依次沿着相同的路径发送 所有报文的所有分组传递完毕，连接终止 一个连接建立后，对具有相同源和目的地址的分组序列，只会进行一次路由策略。 连接服务 网络层协议独立地对待每个分组，每个分组与其他分组没有联系，每个分组与其他分组没有联系。一个报文（传输层来的）中分组可能会沿着不同的路径到达其目的地。 因特网网络层通信无连接 注:无连接是指交换机或路由器不保存有关连接状态的信息，不需要建 立连接，也不需要拆除连接。 因特网中的网络层交换是利用数据报分组交换的方法实现 分组传递可利用面向连接的服务来实现，也可以利用无连接服务实现 因特网的网络层通信是无连接的 IPv4 网际协议第四版 TCP/IP IPv4是TCP/IP协议中使用的传输机制。 IPv4是一种不可靠的无连接数据报协议——尽力传递。尽力传递这一词是指IPv4协议不提供差错控制或流量控制 IPv4假定底层不可靠 IPv4必须与可靠协议（如TCP结合使用）配合 IPv4也是使用数据报的分组交换网的无连接协议 每一分组独立进行处理 每一分租通过不同路由传递到目的端 有些数据报可能遗失或损坏 数据报 IPv4层的分组称为数据报datagram。 VER版本4位 占4bit，IP协议版本 0010 HLEN首部长度4位 单位长度4字节，头部最小字节20，不能小于5000000000 IP首部长度最大60字节（$15\\times 4$） Service服务类型8位 用来获得更好的服务 Total Length总长度16字节 首部和数据之和的长度，单位为字节。数据报最大长度为65535字节。总长度不能超过最大传送单元MTU 以太网限制帧中数据报的长度在46到1500字节之间，当数据报长度小于46字节，必须进行填充(pading) 数据长度的计算方法 为了找到从上层来的数据长度，可以将总长度减去头部长度。将HLEN字段的值乘以4就可以得到头部长度 数据长度=总长度-头部长度 这个字段16位长，因此IPv4数据报长度限制在65535字节，其中头部占20到60字节，剩下的是从上层来的数据 实际上某些网络不能将65535字节的数据报封装成他们的帧，这样的话数据报必须分段 许多情况下，不用读取这个字段，但是有些时候封装在一个帧中的不仅仅是数据报，还有填充。比如，以太网限制数据字段大小为46~1500，如果数据报长度小于46字节，必须增加填充字节才能符合要求。 一个小的数据封装在以太网帧中 标识Identification 16位 是一个计数器，用来产生数据报的标识。用于分段中 标志flag 3bit 只有最后两位有意义 片偏移fragmentation offset13位 较长分组在分片后某片在原分组中的相对位置，8bit为偏移单位 生存时间Time To Live 8bit 数据报可以在网络中通过路由器的个数的最大值 协议Protocol 8bit 协议(8 bit)字段指出此数据报携带的数据使用何种协议， 以便目的主机的 IP 层将数据部分上交给那个处理过程。 首部检验和Checksum 值检测首部，不包括数据部分。使用简单计算方法 例子🌰 一个IPv4分组的前8位如下 01000010 前4位是版本，后四位为HLEN 版本正确。后四位是2，$2\\times {4}=8$字节数为8，头部字节最小字节数20，最大60 HLEN 头部长度字段的值为1000，问这个分组携带的选项是几个字节。 答：12字节 计算数据长度 IPv4分组，头部长度字段的值为5，总长度字段的值是0x0028，问这个分组携带的数据是多少字节？ 32+8=40\\\\ 40-20=20bytes |VER|HLEN|SERVICE | TOTAL_LENGTH | | IDENTIFICATION |FLAG|OFFSET | |TIME_TO_LIVE|PROTOCOL|HEADER_CHECKSUM | |Source IP Address | |Destination IP Address | TTL 0x45000028000100000102 . . . 01，还能1跳。 PROTOCOL是02，是IGMP 分段 一个数据报可以通过几个不同的网络进行传输 每个路由器将它所接收到的帧拆封称IPv4数据报，对其进行处理，再封装成另一个帧 接收到帧的格式和长度取决于此帧刚刚经过的物理网络所使用的协议 发出去的帧的格式和长度则取决于将要经过的物理网络所使用的协议 例如：如果一个路由器将一个局域网连接到一个广域网 接收到：局域网帧 发送：广域网帧 MTU最大传输单元 每个数据链路层协议都有自己的帧格式，这格式定义的一个字段是数据字段的最大长度。 当数据报封装成帧时，该数据报的总长度必须小于最大数据长度 某些网络的MTU值 超级通道Hyperchannel: 65535 令牌环16Mbps： 17194 令牌环4Mbps：4464 FDDI：4352 以太网：1500 X.25：576 PPP：296 源端通常不对IPv4分组进行分段，传输层将数据分割成适合在数据链路层所用IPv4的长度 当对一个数据报进行分段时，每个分段都有其自己的头部： 头部中的某些部分需要被复制到所有的分段中 修改三个字段 标识 分段偏移 总长度 与分段有关的字段 标识identification：标记一个从源主机发出的数据报，唯一定义这个数据报。 为了保证唯一性，IPv4协议使用一个计数器标识数据报 发送数据报时，就将该计数器的值复制到标识字段中 只要该计数器保存在主存中，唯一性就得到保证 所有分段该字段相同 目的端据此进行重组 标记flag Reserved Dont fragment 1不分段：如果通不过该网络，则丢弃并向源主机发送一个ICMP差错报文 0，根据需要对数据报进行分段 More fragment：多分位段 1：表明不是最后的分段 0：是最后的分段或唯一分段 分段偏移 表示这个分段在整个数据报中的相对位置 8字节为度量单位 校验和 IPv6 地址空间更大 层次结构扩展性强 首部格式灵活 改进的选项 允许协议继续扩种 支持即插即用 支持资源的预分配 支持更多的安全性 首部改为8字节对齐 IPv6数据报头部和有效载荷 版本Version 4bit Version 0110 优先级 4bit Traffic Class 发生通信量拥塞时分组的优先级 可进行拥塞控制的通信量 不可进行拥塞控制的通信量 流标号 24bit Flow Label 流是互联网络上从特定源点到特定终点的一系列数据报，“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有同样的流标号 有效载荷长度 Payload length 16bit 指明IPv6数据报除基本首部以外的字节数 下一个首部 next header 8bit 相当于IPv4的protocol或可选字段 跳数控制 hop limit 跳数限制 数据报格式 4to6过渡 因特网上系统非常多，从IPv4到IPv6的过渡不能突然发生。要使每一个系统从IPv4过渡到IPv6，需要花费相当长的时间， 三种过渡策略 双协议栈 隧道技术 头部转换 过渡.双协议栈 过渡到v6之前，使用双协议栈dual stack 分组发送到目的端时 主机向DNS查询， 如果返回一个IPv4地址，源主机就发送IPv4分组， 如果返回IPv6分组，就发送一个IPv6分组 过渡.隧道技术 当两台使用IPv6计算机互相通信，通过Ipv4区域时，使用隧道技术。 进入时封装成4分组，离开时去掉封装 头部转换 0x45 00 00 54 00 03 00 00 20 06 58 41 7C 4E 03 02 B4 0E 0F 02 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH21.html":{"url":"computer-network/CH21.html","title":"CH21","keywords":"","body":"CH21 ARP：ARP的概念、功能、分组格式、封装、4种操作 DHCP的概念 ICMP：ICMP的概念、报文格式、差错报告、Ping IGMP的基本概念 不重要 概论 网络层主要协议：IP 尽力传递协议 没有流量控制和差错控制 使用逻辑地址从主机到主机 需要其他协议帮助 ARP创建物理地址和逻辑地址的映射 IP分组使用逻辑地址，而这些分组需要封装成帧，帧需要物理地址（节点到节点） =>ARP（Address Resolution Protocol）协议 有时我们还需要逆映射。 ICMP差错控制 网际协议(Internet Protocol)缺少流量控制和差错控制，ICMP提供差错告警。 IGMP多播传送 一个源端，多个目的端 地址映射 从源主机发送的分组到达目的地主机之前可能要经过许多不同的物理网络 网络级上，主机和路由器都用IP地址标记 物理级上，主机和路由器用MAC地址标识 物理地址就是本机地址，它的管辖范围是本地网络，范围内唯一，全局上不必如此。 是由于物理地址是用硬件实现。物理地址的例子是以太网协议中48位MAC地址，被写入到网卡NIC上。 就是说将分组传递到一台主机或路由器需要两级地址，逻辑地址和物理地址。我们需要能将一个逻辑地址映射称它相应的物理地址，反过来映射也需要的。 静态映射static mapping 创建一个表，将一个逻辑地址与物理地址联系起来。这个表存储在网络上的每个机器上。 缺陷： 一个机器可能更换网卡，结果得到了一个新的物理地址 某个局域网中，每当计算机加点，物理地址都改变 移动的计算机可能从一个物理网络转移到另一个物理地址，这引起了物理地址的改变 动态映射（dynamic） 每当一个机器知道两个地址中的一个，就可以用协议将另一个求出 Address Resolution Protocol 逻辑地址到物理地址的映射 任何时候，主机或路由器有 数据报要发送到另一个主机或路由器时，必须有接收方的逻辑地址。 如果发送方是主机，他可以从DNS求得逻辑地址 如果发送发是路由器，可以从路由选择表求得 但是，IP数据报必须封装成帧才能通过物理网络。 也就是说发送方必须有接收方的物理地址 主要步骤： 主机或路由器发送一个ARP查询分组 该分组包括 发送方的物理地址 发送方的IP地址 接收方的IP地址 查询就在网络上广播 网络上每个主机或路由器都接收和处理这个ARP查询分组，只有预期的接受者才识别该IP地址 接收方返回ARP相应分组，单播发送给查询者 高速缓存器 分组格式 硬件类型 Hardware Type 16bit 运行ARP的网络类型，每个局域网指定一个整数。ARP可使用在任何物理网络上 以太网是1 协议类型 Protocol Type 16bit 定义协议字段，对于IPv4，这个字段值是$0800_{16}$。 0800H表示IPv4 硬件长度 Hardware Length 8bit 物理地址长度，单位：字节。 以太网：6 协议长度 Protocol Length 8bit 这是一个字段位，用来定义以字节为单位的逻辑地址的长度 IPv4: 4 操作Operation 16bit 用来定义分组的类型 ARP请求：1 ARP回答：2 发送方硬件地址 Source hardware address 可变长 发送方物理地址，可变长字段 以太网是6字节 发送方协议地址 Source protocol address 可变长 发送方的逻辑地址，可变长字段 目标硬件地址 Destination hardware address 可变长 目标硬件地址，发送ARP请求时全0 目标协议地址 Destination protocol address 可变长 目标逻辑地址 对于IPv4是4字节 封装 ARP分组直接封装在数据链路帧中。 类型字段指出了此帧所携带的数据是ARP分组 ARP主要步骤 IP请求ARP协议产生一个ARP请求报文 发送方物理地址 发送方的IP地址 目标的IP地址 目标物理地址（置0） 将报文发送给数据链路层，封装为帧 发送方物理地址为源物理地址 物理广播地址作为目的地址 每个主机和路由器都接收到帧 这个帧包含广播目的地址，所有站点都收到此报文 除了目标机器，所有的机器都丢弃该分组 目标机器识别该IP地址 目标机器用ARP回答报文进行应答 此回答报文包含它的物理地址 报文使用单播 发送方接收到这个回答报文，获得目标机器的物理地址 发送IP数据报 四种不同情况 同网络一个主机发送给另一个主机，将物理地址映射为逻辑地址，将该逻辑地址作为数据报头部的目的IP地址 主机到路由器 路由器到路由器 路由器到接收方主机 发送方是一个路由器，它已经收到了一个数据报，要将该数据报发送个同一网络上的一个主机。数据报的目的IP地址就是必须映射为物理地址的那个逻辑地址 ARP请求报文是广播发送；ARP回答报文是单播发送 代理ARP（proxy ARP） 用来产生子网化效果。可以代表一组主机的ARP。 DHCP没看 ICMP IP缺少差错控制和辅助机制 IP协议缺少一种主机和管理查询机制，主机有时需要确定一个路由器或另一个主机报文是否是活跃的，有时网络管理员需要从另一个主机或路由器得到信息 Internet Control Message Protocol因特网控制报文协议 特点 为了提高IP数据报交付成功的机会，在网际层使用 因特网控制报文协议ICMP ICMP允许主机或路由器报告差错情况和提供异常情况的报告 ICMP不是高层协议，而是IP层的协议 ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去 ICMP不能纠错，只能报告错误 ICMP分为差错报告报文和查询报文 注意:ICMP 总是向原始的源方报告差错报文。 ICMP-报文类型 差错报告报文Error-reporting message 查询报文query message Error-reporting message 差错报告报文向路由器或主机报告在处理一个IP数据报时可能碰到的一些问题 query message 查询报文成对出现 它帮助主机或网络管理员从一个路由器或另一个主机得到特定的信息 报文格式 头部+可变长的数据部分 差错报文 ICMP总是向原始的源方报告差错报文 规定 携带ICMP差错报文的数据报，不再产生ICMP差错报文 对分段的数据报文，只对第一个分段产生ICMP差错报文 对于多播地址的数据报文，不产生ICMP差错报文 具有特殊地址的数据报文，如127.0.0.0或0.0.0.0不产生 数据字段内容 8字节中包含端口序号等信息，让源端知道出问题的是哪个 有5种差错 类型 含义 Destination unreachabel 1. 当路由器不能找到路由或者主机不能传递数据时，丢弃这个数据报 然后发回目的端不可达报文；2. 有路由器发出，或者由目的主机创建 source quench 1. 补充流量控制；2. 当路由器或者目的主机中产生拥塞时，路由器或目的主机丢弃数据报，发送源端抑制报文给发送方 time exceeded 1. TTL减为0，路由器丢弃数据报；2. 报文的所有分片没有在有限时间内到达，由目的主机发送 Parameter problems 1. IP分组的首部中产生错误或者二义性；2. 路由器或主机丢弃这个分组，然后向源方发送参数问题报文 Redirection 1. 路由更新过程中的问题；2. A想向B发送数据报，R2是有效的路由，但A却选择了R1，R1收到后发现应该发往R2，于是把分组发给R2，同时向A发送重定向报文 重定向 时间超时 差错报告报文各字段的内容 查询报文 IGMP不重要 IP协议可用到两种类型的通信:单播和多播。 因 特 网 组 管 理 协 议 (Internet Group Management Protocol, IGMP) 是其中一个必要的，但不是充分 的协议，多播也包含其他的协议。在IP协议中， IGMP是一个辅助协议。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH22 传递、转发和路由选择.html":{"url":"computer-network/CH22 传递、转发和路由选择.html","title":"CH22 传递、转发和路由选择","keywords":"","body":"CH22 传递、转发和路由选择 转发技术与转发过程 路由表、地址聚合和最长掩码匹配 Dijkstra算法和Bellman-Ford* 算法 单播路由协议：AS的概念、域内、域间路由选择协议 RIP协议路由表生成的过程 OSPF协议的原理 多播的概念和多播路由（了解） 传递 网络层负责用底层物理网0络处理分组，定义这种处理为分组的传递 直接传递direct delivery：分组最终目的端主机是与发送方连接在同一个物理网络上。当分组的源端和目的端都在同一物理网络上，或传递是在最后一个路由器与目的主机之间进行时，就出现直接传递 间接传递indirect delivery：目的主机与发送方不在同一个网络 最后的传递总是直接传递 判别方法：提取出目的端的网络地址与它所连接的网络地址进行比较，相同则传递是直接的 转发 分组路由到它的目的端，转发要求主机或路由器由一个路由表。当主机有分组要发送时， 或是路由器收到一个分组要转发时，就要查找路由表以便求得到达最终目的端的路由 当前Internet中，这种技术不可能应用。 转发技术 简化路由表的技术 下一跳方法与路由方法 特定网络方法与特定主机方法 默认方法 下一跳方法与路由方法 next-hop route method 完整路由信息vs只保存下一跳 特定网络方法与特定主机方法 Network-specific method 仅用一个项目来定义这个目的网络本身的地址，将在同一网络上的所有主机看做是一个项目。 检查路由或提供安全措施等目的 默认方法 default method 仅用一个称为默认的项目（通常0.0.0.0） 转发过程 假定主机和路由器用无类寻址。 分类寻址可以认为是无类寻址的一个特殊情况 路由表对涉及到的每一个地址块都需要有一行信息 掩码(\\n) 网络地址 下一跳地址 接口 掩码（/n） 网络地址 下一跳地址 接口 /26 180.70.65.192 -- m2 /25 180.70.65.128 -- m0 /24 201.4.22.0 -- m3 /22 201.4.16.0 -- m1 其他 0.0.0.0 180.70.65.200 m2 最长掩码匹配 使用CIDR时，路由表中可能会有不止一个匹配结果 应当从匹配结果中选择具有最长掩码的路由 掩码越长，其地址块就越小，因而路由机就越具体 🌰 路由（路由的实际实现） 从某一网路设备触发去往某个目的地所经过的路径。 路由器通过查询路由表为数据报选择转发路径。路由表只存在于终端计算机、路由器及三层交换机中，二层交换机中不存在路由表 直连路由：设备自动发现的路由信息，路由器可自动发现与自己接口直接相连的网络的路由 静态路由：人工输入，无法自动更新 动态路由：可周期更新，适合大型网络 直连路由和静态路由 静态路由只适合小型网络 直连路由：可以周期性更新 动态路由优先级 RIP和OSPF协议 路由汇总 图中可以看出 路由表项很多。可以进行简化 地址聚合 默认路由 单播路由选择协议 路由表可以是 静态或动态的 静态：人工输入 动态路由表：互联网中某处 发生变化就自动进行更新 路由选择协议是一些规则或过程的组合，使得 互联网中的 各路由器 能够彼此互相通知 这些变化 重点 优化原则 域内部和域间路由选择 距离向量路由选择和RIP 链路状态路由选择和OSPF 路径向量路由选择和BGP 动态路由协议的功能 知道有哪些邻居路由器 能够学习到网络中有哪些网段 能够学习到至某个网段的所有路径 能够从众多的路径中选择最佳的路径 能够维护和更新路由协议 优化原则 路由器将分组转发到哪个与其相连的网络，取决于哪个可用路径是最佳路径 度量metric：给网络指定 代价 RIP路由信息选择协议（跳数） 开放最短路径有限协议OSPF 可达性 边界网关协议 自治系统autonomous system 是一个单一的管理结构管辖下的一组网络和路由器。 互联网很大，以致于仅使用一个路由选择协议无法处理更新所有路由器路由表任务。 在自治系统内部的路由选择称为 域内路由选择interadomain routing 一种或多种 自治系统之间的路由选择称为 域间路由选择interdomain routing 只能一种 Routing Information Protocol Open Shortest Path First Border Gate Protocol Routing Information Protocol距离向量路由选择 任何两个节点之间路由最低代价是最小距离的路径 初始化方法 图中的表是稳定的，每个节点都知道如何到达其余任一节点机器代价。 实际不一定如此 每一个节点只知道邻站（immediate neighbor）的距离。 初始化时，不是邻站的距离标为无穷大 共享路由信息 在距离向量路由选择中，每个节点与它的邻站周期性地或有变化时共享它的路由表 更新算法 当一个节点从它的邻站接收第二列的表时，它需要更新它的路由表。 接收节点在表的第二列中的每一个值➕上它与发送节点之间代价的值， 如果接受节点使用来自任一行的信息，接收节点需要把发送节点名加入作为第三列 接收节点将修改过的接收到的表与它的旧表逐行比较 下一跳不同，取代价最小的行 下一跳相同，选取新行：因为有可能是节点更新了，旧的路径已经行不通 需要强调 第一，数+无穷为无穷 第二，修改过的表说明了如何从节点A经过节点C到达节点A 何时共享 周期更新：30s一次 触发更新：节点在路由表发生变化时，向它的邻站发送它的二列路由表 节点接收到邻站的表 节点检测到邻站链路有故障 两个节点循环不稳定性 三种解决方法 定义无穷大：比如100，RIP中是16 分割范围split horizon：发送表的一部分，发送路由表之前，先删除自己路由表的最后一行，第一次更新后，系统稳定 毒性逆转posion reverse： 三个节点不稳定性 二节点可以用 分割策略➕毒性逆转结合避免， RIP路由选择信息协议 Routing Information Protocol 自治系统内部使用的域内路由选择协议。基于距离向量路由选择的协议 一个自治系统中，包括路由器和网络（链路），路由器有路由表，网络没有路由表 路由表中的目的端这一列是 网络 ，这表示它的第一列定义了目的网络地址 RIP所用的度量是跳数（hop count， 到达目的端的链路个数） 16定义为无穷大 在任何自治系统中，任何路径不能大于15 下一节点这一列定义为目的路由器地址 特点 距离是跳数 跳数越少路径越好 最多15，适用于小型互联网 优缺点 算法和上面的一致（除了无穷大的定义） 链路状态路由选择Link state routing 链路状态 类型 状态 代价 建立路由表 按每个节点建立LSP（链路状态分组） 洪泛法Flooding：向其他所有路由器扩散LSP 为每个节点构成一个最短路径树 基于最短路径树计算路由表 生成LSP LSP携带大量信息，节点表示、链路清单、序列号、寿命 生成LSP的情况 区域的拓扑发生变化 周期性产生60mins~2h 周期较长保证不会产生太多通信量 洪泛法Flooding 创建节点的LSP，从每个接口发送LSP副本 收到的LSP的每个节点与已有的副本比较 丢弃旧的，保留新的 节点通过每个接口（接口副本的接口除外），再次转发副本 通信量很大 最短路径树的狗层 Dijkstra算法 OSPF 基于链路状态的 Open Shortest Path First Protocol 区域Area 包含在自治系统中的一些网络、主机和路由器的集合； 一个自治系统可以划分为多个区域 一个区域内，所有路由器都是用洪泛法传递路由选择信息 在一个区域的边界——区域边界路由器area border router将本区域信息概括起来发送给其他区域 主干：所有区域必须连接到主干 主干路由器backbone router 从区域：主干外的其他区域 虚链路（virtual link）： 划分区域的优点 将利用洪泛法交换链路状态信息的范围局限于每 一个区域而不是整个的自治系统，减少了整个网 络上的通信量 在一个区域内部的路由器只知道本区域的完整网 络拓扑，而不知道其它区域的网络拓扑的情况。 OSPF 使用层次结构的区域划分。上层的区域为 主干区域 0.0.0.0，用来连通其它在下层的区域。 度量 OSPF协议允许网络管理员给每一条路由指定一个代价，称为度量metric。可以基于服务类型（最小延迟，最大吞吐量等）。 链路类型 特点 代价灵活，不同服务类型可以计算出不同的路由 多路径间的负载平衡，如果通一个目的网络有多条相同代价路径，可以将通信量分配给这几条路径 保证仅在可信赖的路由器之间交换链路状态信息，鉴别功能 由于一个路由器的链路状态只这几到与相邻路由器的联通状态，与整个互联网的规模无直接关系。因此，当互联网规模很大时，OSPF协议远比RIP要好 支持可变长度的子网划分和五分类编址CIDR 路径向量路由选择协议（考点未标） 基准：可达性 初始化 每个自治系统有一个代言节点，每个代言节点仅能知道它的自治系统内部节点的可达性。 共享 邻站共享 更新 优点 BGP 多播路由选择 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH23.html":{"url":"computer-network/CH23.html","title":"CH23","keywords":"","body":"第五部分传输层 CH23 传输层负责整个报文的进程到进程的传递。 网络层监管独立分组 从源端到目的端 的传递，但是不辨认分组之间的关系。 传输层从源端到目的端的层次中，监管差错控制和流量控制以确保全部报文完整地、按序地到达。 OSI模型中，传输层头部必须包含一个称为服务点地址的地址类型，或在因特网和TCP/IP协议族中的端口号或端口地址。 无连接 面向连接 无连接传输层将每段作为一个独立分组处理，将它传递到目的机器的传输层。 面向连接传输层在传递分组前要与目的机器的传输层建立一个连接。当所有数据传输完成后，要终止这个连接 在传输层，一个报文通常被划分称可传输的段。 无连接协议（如UDP）对每一段独立处理 一个面向连接协议（如TCP）还要用序号生成这些段之间的关系 像数据链路层一样，传输层也负责流量控制和差错控制。 考点 端口、套接字 UDP协议：UDP协议的概念、数据报结构、校验和的计算、UDP的操作 TCP：TCP的特点与服务、段格式、三次握手（建立连接和拆除连接）、TCP流量控制（信贷滑窗协议）、TCP差错控制 TCP有关字段和序号（SYN、ACK、seq、ack*）、段序号、字节编号 进程到进程的传递 Process to Process delivery 任何时刻，源主机上可能运行多个进程。目的主机也可能运行多个进程。 为了完成传递过程，需要一种机制将源主机上运行的某个进程的数据发送到目的主机的对应进程上 客户/服务器模式（client-server paradigm） 常用的进程到进程通信方式。本机上进程称为 客户（client），远程主机称为 服务器（server） 定义 本地主机 本地进程 远程主机 远程进程 寻址 端口号（port number）作为传输层地址 端口号是在0~65535之间的16位整数。 客户程序用端口号定义它自己，这个端口号由运行在客户机上的传输层软件随机选择的，这是 临时端口号 服务器进程也必须用一个端口号定义自己，但是这个端口号不能随机选择。 熟知端口号（well-known port number） IANA范围 因特网号码分配管理局 Internet Assigned Number Authority, IANA。已经把端口编号划分为三种范围：熟知的、注册的和动态的 熟知端口：0~1023 注册端口：1024~49151，IANA不分配也不控制，他们可以在IANA注册防止重复 动态端口：端口号范围 49152~65535，不受控制不用注册，可以由任何进程使用 套接字地址 一个IP地址和一个端口号结合起来称为套接字地址（socket address）。 客户套接字地址唯一定义了客户机进程 服务器套接字地址唯一定义了服务器进程， 也就是说，传输层协议需要一对套接字机制：客户套接字地址和服务器套接字地址。 这四条信息是IP头部和传输层协议头部的组成部分，IP头部包含IP地址，UDP或ICP头部包含端口号 复用与分离 寻址机制，允许通过传输层进行复用和分离 复用 在发送方站点，可能有多个进程要发送分组，因而需要复用。传输层协议接收来自不同进程的报文，按端口号区分。 添加了头部后，传输层把分组发送给网络层。 分离 接收方站点，只有一个传输层协议。但有多个进程可能要接收分组。这是一对多的关系。 因而需要分离。 传输层接收来自网络层的数据报。经过纠错和去除头部以后，传输层根据端口号将每个报文传递到适当的进程。 无连接服务与面向连接的服务 无连接服务 connectionless service 不需要建立连接和释放连接 分组没有编号 可能延迟、丢失或无序到达，也没有确认过程 UDP就是无连接的 面向连接服务 Connection-oriented service 首先在发送方和接收方之间建立一个连接 传送数据 最后释放数据 TCP SCTP 可靠服务与不可靠服务 如果应用层需要可靠性服务 就使用可靠的传输层服务 传输层使用流量控制和差错控制 较慢 更复杂 不需要可靠性服务，使用不可靠性服务 UDP：无连接的和不可靠的 TCP和SCTP：面向连接的和可靠的 传输层保证的是端到端的可靠性 并且因为因特网的网络层是不可靠的（尽力传递），所以传输层必须实现可靠性。 TCP的流量和差错控制是通过滑动窗口协议实现的 三种协议 用户数据报协议UDP User Datagram Protocol 。无连接不可靠传输层协议connectionless， unreliable transport proocol 只添加了进程到进程通信 完成非常有限的差错检验 优点 简单，开销最小 熟知端口号 UDP用户数据报（user datagram） 源端口号 16bit 暂时端口号 由进程请求 源主机上运行的UDP软件进行选择 如果是服务器，则是熟知端口号 目的端口号 16bit 如果是目的主机是服务器，则大多数情况是熟知端口号 如果目的主机是客户端，那么大多数情况下是暂时端口号 长度：用户数据报的总长度，头部+数据 16bit 2^{16}=65535字节 总长度应小于这个值，因为这个值是IP数据报的最大值。 校验和：用来校验整个用户数据报出现的差错 校验和 校验和分为三部分：伪头部、UDP头部和从应用层来的数据 伪头部是IP分组的头部的一部分， var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/application.html":{"url":"computer-network/application.html","title":"应用层","keywords":"","body":"应用层 CH25 CH26 CH27 第25章 域名系统 1. 域名空间，客户端服务器模式 域名解析 DNS 报文 第26章 远程登录、电子邮件和文件传输 Telnet 的基本概念 2. 电子邮件:电子邮件的架构、邮件报文、SMTP 和 MIME、POP3 和 IMAP 3. 文件传输:FTP 的架构、FTP 的连接、FTP 的传输方式、端口 第27章 万维网与超文本传输协议 **1. URL HTTP 的概念、报文结构、HTTP 操作，采用 TCP** 服务的端口 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH25.html":{"url":"computer-network/CH25.html","title":"CH25","keywords":"","body":"CH25 Domain Name System 域名空间，客户端服务器模式 域名解析 DNS 报文 使用DNS服务的例子 名字空间 为了实现无二义性，分配给机器的名字必须从名字空间中仔细选择。该名字空间完全控制对名字和IP地址的绑定。 平面名字空间 一个名字分配一个地址，名字是一个无结构的字符序列。 缺点 必须集中控制才能避免二义性，不能用于大规模系统 层次名字空间 每个名字由几部分组成，分配和控制名字空间的机构可以分散化 域名空间 所有名字由根在顶部的倒置树结构定义。最多有128级 全程域名FQDN和部分域名PQDN FQDN：Fully qualified domain name 最后是点 PQDN: Parially qualified domain name 域 名字空间的分布 一台计算机不足以存储 一台服务器管理的空间称为区域zone 因特网中的DNS 通用域 generic domains 按照行为区分 国家域 country domains 使用两个字母的国家缩写，第二级标号可以是组织结构 反向域 将地址映射为名字，为了确定客户端是否在授权的列表中。 解析 将名字映射称为地址或者将向地址映射称为名字的过程 递归解析 recursive resolution client 向就近服务器发送请求，如果这一服务器是授权服务器，则其检查数据库做出相应，如果不是，则发送给另一个服务器通常是父服务器。 当解析得到响应，响应就向后传送，知道最终到达发出请求的客户机。 迭代解析 iterative resolution 如果服务器是该授权服务器，发送应答； 不是，发送它认为可以解析这个查询的服务器的IP 客户端向下一台发送请求。 高速缓存 缩短查询的时间 映射可能会过期 设置生存时间TTL 要求每台服务器保留一个TTL计数器，到达时间，高速缓存会定期检查，并清除掉TTL已经过期的映射 DNS报文 两种报文 查询报文 query message 响应响应 response message 头部 header identification 客户端使用该字段匹配对查询的响应。 客户端每次发送查询时会使用不同的标识号。 响应时该字段相同 flags标记 子字段的集合。定义了 报文类型 应答类型 期望的解析类型（递归或迭代） 询问记录数 报文中询问部分所含请求的数量。 应答时为0 应答记录数 报文中应答部分所含应答记录的数量 查询时为0 授权记录数 响应报文中授权部分所含授权记录的数量 查询时为0 附加记录数 附加部分所含附加记录的数量 查询时为0 询问部分 一条或多条询问记录构成。两种报文都含有 应答部分 由一条或多条资源记录构成。包含应答内容 授权部分 一条或多条资源记录。给出用于查询的一台或多台授权服务器的信息（域名） 附加消息 给出了有助于解析程序的附加信息 记录类型 DNS使用两种类型的记录。 询问记录question record：从server获取信息 资源记录resource record: 每个域名都与一个资源记录相关量。服务器数据库包含所有的资源记录，服务器还返回资源记录给客户机 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH26.html":{"url":"computer-network/CH26.html","title":"CH26","keywords":"","body":"CH26 远程登录TELNET Terminal Network 标准TCP/IP协议 使用户能够建立一个到远程系统的连接。本地终端连接到远程系统上。 本地远程登录过程 本地登录 local login 远程 电子邮件 架构 第一种情况 发送方与接收方在同一个系统。 仅需两个UA。 Alice发给Bob Alice运行用户代理程序准备报文，在BOb的邮箱中放下该邮件 第二种情况 二者在两个系统上（邮件域名不同）需要用户代理和报文传输代理（message transfer agent MTA） Alice先发给自己的邮件服务器，使用队列存储报文。 Bob可以用UA查看自己的邮件 两个邮件服务器各需要一个Message Transfer Agent，一个是client,一个是server。 需要两个UA和一对MTA 第三种情况 Alice通过广域网连接自己的邮件服务器， 需要两对MTA Message Transfer Agent 第四种情况 用户代理 UserAgent 是一个软件包（程序），组成、读取、回答和转发报文。 邮件格式 信封 envelope包含发件人和收件人地址 报文： header：发信人，收件人，保温主题及其他信息。 body：读取的真正信息 MIME 电子邮件只能发送NVT 7位 ASCII格式的报文。不用用来发送二进制文件或音频，不用使用某些语言 MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 它是一个互联网标准，扩展了电子邮件标准，使其能够支持： 非ASCII字符文本；非文本格式附件（二进制、声音、图像等）；由多部分（multiple parts）组成的消息体；包含非ASCII字符的头信息（Header information）。 头部 MIME版本 内容-类型 内容-传送-代码 内容-标识符 内容-描述 报文传输代理SMTP Simple Mail Transfer Protocol 发送邮件时，发送方必须有MTA，系统必须有服务器MTA。因特网中，定义MTA客户机和服务器的形式化协议 SMTP在发送方与接收方邮件服务器时间和两个邮件服务器之间使用两次。（两对MTA） 邮件传输阶段 连接建立 邮件传输 连接终止 第三阶段 POP3和IMAP$ 邮件服务器到接收方使用pull协议 文件传输 FTP 使用TCP服务，需要两个TCP连接 数据传输 控制信息 21端口用于控制连接，20用于数据连接 控制连接 数据连接 解决异构问题 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH27.html":{"url":"computer-network/CH27.html","title":"CH27","keywords":"","body":"CH27 体系结构 www是一个分布式的客户/服务器服务，客户机用浏览器能够使用服务器提供的服务。提供的服务是分布在许多称为站点的位置上。 url cookies 采用客户端保持状态的方案。在用户端的会话状态存储机制。 WEB文档 静态文档、动态文档、活动文档。 基于文档内容的时间确定分配 静态稳定 基于GGI技术的动态文档 使用服务端脚本的动态文档 使用客户端脚本的活动文档 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/总复习.html":{"url":"computer-network/总复习.html","title":"总复习","keywords":"","body":"《计算机通信与网络》课程总复习知识点 配套《数据通信与网络(Forouzan第四版)》 2021年12月 第一部分 概述 第1章 绪论 数据通信的概念及模型 数据流 连接类型和拓扑结构 网络分类 协议和标准 第2章 网络模型 层次结构、层间接口和封装 OSI参考模型的概念和各层功能 TCP/IP*协议簇和各层的功能 物理地址、逻辑地址和端口地址（何时改变？） 第二部分 物理层和介质 第3章 物理层 数字信号：基带传输、低通通道、宽带传输的概念 传输减损：衰减、失真、噪声和信噪比的概念 数据速率限制：奈奎斯特速率、香农容量定理 性能：带宽、吞吐量、信道利用率、延迟、传播时间、传输时间、排队时间、带宽与延迟的乘积的概念 第4章 数字传输 线路编码：数据元素、信号元素、数据速率、信号速率、最小带宽、最大数据速率、直流分量、自同步 线路编码方案：单极性编码（NRZ）、极性编码（NRZ-L和NRZ-I）、归零码（RZ）、双相码（Manchester和Differential Manchester）、双极性编码（AMI和伪三进制码）、 脉码调制PCM：采样（采样率）、量化等级、量化误差 Delta调制的概念 传输模式：异步传输、同步传输、并行传输、串行传输的概念 第5章 模拟传输 比特率和波特率 数字到模拟转换： `ASK的概念及ASK的带宽 FSK的概念及BFSK的带宽 PSK、BPSK、QPSK和QAM的概念 模拟信号调制： AM、FM和PM的概念 AM带宽、FM带宽和PM带宽 第6章 带宽利用 复用：FDM、同步TDM、统计TDM和WDM的概念 数字层次、T1载波、E1载波 波分和码分的概念 扩频：FHSS和DSSS的概念 第三部分 数据链路层 第10章 检错与纠错 差错的类型 块编码 差错检测的方法 纠错的概念与方法：汉明距离、最小汉明距离 线性块编码：线性块编码的距离、简单奇偶校验编码、两维奇偶校验编码、汉明码 循环冗余编码CRC（不包含硬件实现）、CRC的检错能力分析（检测单个位差错、两个独立的位差错、奇数个差错、突发性差错） 校验和及其计算方法 第11章 数据链路控制 组帧 流量控制和差错控制的概念 停止等待ARQ、后退N帧ARQ和选择重发ARQ HDLC 第12章 多路访问 随机访问：纯ALOHA、时隙ALOHA、CSMA、CSMA/CD（最小帧长）、CSMA/CA 受控访问：预约、轮询、令牌环 第13章 有线局域网：以太网 IEEE标准：LLC和MAC 标准以太网的MAC子层：帧格式、MAC地址、最短帧长、编码和解码、10Base5、10 Base 2、10 Base -T、10 Base -F 桥接以太网、交换式以太网、全双工以太网 快速以太网：MAC子层、拓扑结构、100Base -TX、100Base-FX、100Base –T4 千兆以太网：MAC子层、拓扑结构、1000Base -SX、1000Base-LX、1000Base –CX 第14章 无线局域网 WLAN体系结构与IEEE 802.11标准 802.11 MAC子层、帧结构、CSMA/CA* 802.11 物理层、寻址方式、隐蔽终端和暴露终端 第15章 连接局域网、主干网和虚拟局域网 连接设备：无源集线器、中继器、有源集线器、网桥、透明网桥、生成树、二层交换机、路由器、三层交换机（补充）、网关、冲突域与广播域 虚拟局域网的概念及划分方法 第四部分 网络层 第19章 逻辑寻址 IPv4地址：A、B、C、D和E类地址、掩码、子网和超网的概念 子网划分、子网的地址范围、地址聚合 NAT的概念 IPv6地址 第20章 IP协议 IP分组（数据报）的格式 分片(Identification、Flags、Fragmentation offset）、何处分片和重装 MTU IPv6分组格式 下一个头部相关 IPv4到IPv6的过渡 双协议栈 隧道技术 头部转换 第21章 地址映射、差错报告和多播 ARP：ARP的概念、功能、分组格式、封装、4种操作 DHCP的概念 ICMP：ICMP的概念、报文格式、差错报告、Ping* IGMP的基本概念 第22章 传递、转发和路由选择 转发技术与转发过程 路由表、地址聚合和最长掩码匹配 Dijkstra算法和Bellman-Ford* 算法 单播路由协议：AS的概念、域内、域间路由选择协议、RIP协议路由表生成的过程、OSPF协议的原理 多播的概念和多播路由（了解） 第五部分 传输层 第23章 UDP、TCP和SCTP 端口、套接字 UDP协议：UDP协议的概念、数据报结构、校验和的计算、UDP的操作 TCP：TCP的特点与服务、段格式、三次握手（建立连接和拆除连接）、TCP流量控制（信贷滑窗协议）、TCP差错控制 TCP有关字段和序号（SYN、ACK、seq、ack*）、段序号、字节编号 第24章 拥塞控制和服务质量 TCP拥塞控制（慢启动、拥塞避免、拥塞检测） 发送窗口=min（接收窗口rwnd，拥塞窗口cwnd） 第六部分 应用层 第25章 域名系统 DNS*的工作原理 域名空间 通用域、国家域和反向域 域名解析 DNS报文 第26章 远程登录、电子邮件和文件传输 Telnet的基本概念 电子邮件：电子邮件的架构、邮件报文、SMTP和MIME、POP3和IMAP 文件传输：FTP的架构、FTP的连接、FTP的传输方式、FTP的端口 第27章 万维网与超文本传输协议 URL、Cookies的概念 HTTP的概念、报文结构、HTTP操作 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/报文、报文段等的区别.html":{"url":"computer-network/报文、报文段等的区别.html","title":"报文、报文段等的区别","keywords":"","body":"报文、报文段等的区别 报文message 应用层的信息分组，是网络中交换与传输的数据单元，也是网络传输的单元。 报文包含了将要发送的完整的数据信息，长短不需一致。 传输过程中会封装成 分组packet 包 帧frame 报文段segment 起始点和目的地都是传输层的信息单元 分组/包packet 分组时网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分，在每个部分的前面加上必要的控制信息组成的首部，有时加上尾部，构成了一个分组，起始和目的地是网络层 数据报datagram 面向无连接的数据传输，工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。通常是起始点和目的地都是用无连接网络服务的网络层的信息单元 帧frame 是数据链路层的传输单元，起始点和目的地都是数据链路层 数据单元data unit 服务数据单元（SDU）、协议数据单元（PDU） var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"about/about.html":{"url":"about/about.html","title":"搭建说明","keywords":"","body":"搭建说明 相关教程 基本结构 https://snowdreams1006.github.io/ 一些问题的解决 mathjax安装问题 使用node10.24.1即可 https://www.piginzoo.com/tech/2021/10/15/gitbook#%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6 行内代码无法使用$\\rightarrow$ https://github.com/yunsean/gitbook-mathjax-url 使用插件 https://www.npmjs.com/package/gitbook-plugin-headscript TOC还没解决 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}