{"./":{"url":"./","title":"简介","keywords":"","body":" xinwuyun的笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/CH15.html":{"url":"database/CH15.html","title":"CH15 并发控制","keywords":"","body":"数据库第十五章 Lock-based protocol lock 锁是一种控制对数据项并发访问的机制 数据项可以在两种模式下被锁 排他的exclusive(X)mode：如果事务T获得了数据项Q上的排它锁，可以读写 共享的shared：如果事务T获得了数据项Q上的共享锁，则T可读但是不能写 程序猿向并发控制管理器concurrency-control manager发出锁请求。事务只有在请求得到授权后才能继续 锁相容性矩阵 lock-compatibility A transaction may be granted a lock on an item if the requested lock is compatible with locks already held on the item by other transactions. 任何时候，一个数据项可以同时使用任意数量的共享锁 此后的排它锁请求必须一直等到所有共享锁释放 当有X锁时，不能再使用更多的任何锁 如果不能授予锁， 发送请求的事务就等待，直到所有其他事务使用的不相容的锁被释放掉，才能授予该锁 例子 展示A+B 上述方法不足以保证可串行化。如果A和B在ulock(A)和lock-s(B)之间被修改了，则展示出的和会不正确 locking protocol是所有事务在请求和释放锁时遵守的规则集 locking protocol限定了可能的调度集 自动获取锁Automatic Acquisition of Locks 事务$T_i$处理标准 read/write指令时无需显式使用锁调用指令 read(D) if Ti has a lock on D then read(D) else begin if necessary wait until no other transaction has a lock-X on D // 这里只需要确定其他事务没有X锁就行，自己可以有 grant Ti a lock-S on D read(D) end write(D) if Ti has a lock-X on D then write(D) else begin if necessary wait until no other transaction has a lock on D if Ti has a lock-S on D then upgrade lock on D to lock-X else grant Ti a lock-X on D 所有锁在commit或abort后都释放 The two-phase lockign protocol两阶段锁协议 这个锁协议保证了冲突可串行调度 增长阶段 growing phase 缩减阶段 shrinking phase Deadlocks 考虑如下部分调度 不难看出，最后$T_3$和$T_4$都不能继续执行了。 为了进行下去，$T_3$和$T_4$中的一个应该回滚令其锁释放 两阶段锁无法保证无死锁 饥饿 例如：某事务可能在等待某X-lock请求，但是一系列其他事务不断被授予S-lock，这个事务一直得不到X-lock 并发控制管理器可以designed to prevent starvation 大多数封锁协议中存在潜在死锁 当一个死锁发生时，有可能会发生级联回滚 两阶段锁也有可能会发生级联回滚。为了避免，使用strict two-phase locking一个事务必须持有所有的X-lock，直到commit/aborts Rigorous two-phase locking：事务的所有锁都要一直持有，直到commit/abort 锁的实现 lock manager可以实现为一个进程，从事务接收消息并反馈消息。 针对锁请求消息返回 授予锁消息 事务回滚消息 lock manager维护一个lock table来记录被授予的锁和待办的锁 锁表通常实现为内存中的哈希表，索引以被上锁的数据项的名字作为索引项 死锁处理 定义 如果有一个事务集，其中的所有事务都在等待另一个该事务集中的事务，那么该系统死锁 死锁预防 deadlock prevention 死锁预防协议保证系统永远不会进入死锁状态。例如 要求事务在执行前，对所有数据项上锁（预声明） 有两个缺点 事务开始前通常很难预支哪些数据需要封锁 数据项使用率低，有可能许多数据项长时间封锁却用不到 通过对加锁请求进行排序，偏序 每当有可能导致死锁时，进行事务回滚而不是等待加锁 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}