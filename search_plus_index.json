{"compile-prin/复习纲领.html":{"url":"compile-prin/复习纲领.html","title":"编译原理","keywords":"","body":" 请务必按时完成老师在课堂上布置的练习题、作业题，它们的完成情况将计入课程总评成绩。 建议：你还应当完成教材各章之后的那些【没标星号的】习题，特别是《习题解答》中有解答的。 这里指出你最应当完成的一部分习题之题号（若老师没有明确布置、但你又完成了的话，你可以根据个人意愿请老师帮忙检查，或与老师讨论） 第2章习题： ​ 2.1 2.2 2.3 (2) (4) ​ 2.4 2.5 2.6 2.8 2.9 2.10 第3章习题： ​ 3.1 3.2 3.3 3.4 3.6 (1) (2) ​ 3.9 3.11 3.14 3.17 3.18 3.14 判断LL1文法 第4章习题： ​ 4.1 4.3 4.4 4.5 4.7 4.8 ​ 4.9 4.11 4.14 4.16 4.17 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"./":{"url":"./","title":"简介","keywords":"","body":"xinwuyun的笔记 Summary 简介 大三上笔记 数据库笔记 CH1 CH2 CH3 CH4 CH5 CH6 CH7 CH8 CH9 CH10 CH11 CH12 CH13 CH14 CH15 并发控制 ch16 计算机网络 CH1 CH2 CH3数据与信号 CH4数字传输 CH5 模拟传输 CH6 ch10检错与纠错 ch11数据链路控制 CH14 无线局域网WLAN CH15 连接局域网、主干网和虚拟局域网 CH19逻辑寻址 CH20IP协议 CH21 CH22 传递、转发和路由选择 CH23 应用层 CH25 CH26 CH27 总复习 总复习2 报文、报文段等的区别 搭建说明 搭建说明 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/CH1.html":{"url":"compile-prin/CH1.html","title":"CH1","keywords":"","body":"CH1 从面向机器语言到面向人类的语言 面向机器的语言：机器指令、汇编语言 面向人类的语言：通用程序设计语言、数据查询语言 语言之间的翻译 习惯称法 汇编->机器指令：（交叉）汇编 高级语言->汇编语言或机器指令：（交叉）编译 高级语言之间：转换（预编译、预处理）‘ 逆向：反编译、反汇编 编译器与解释器 语言翻译的两种基本形态（根据工作方式划分） 先翻译后执行 边翻译边执行 比较 特点： 基本功能：二者相同，核心是：完成语言翻译 技术：从翻译的角度来讲，两种方式涉及的原理、方法和技术相似 上面是PPT，下面是课本内容 主要区别 运行目标程序时的控制权在解释器而不再目标程序。解释器的优点 具有较好的动态特性：解释器运行时，由于源程序也参与其中，因此数据对象的类型可以动态改变，并允许用户对源程序进行修改，可提供较好的出错诊断，从而为用户提供了交互式的跟踪调试功能。 具有较好的可移植性，解释器一般也是用某种程序设计语言编写的，因此只需要对解释器重新编译，就可以使解释器运行在不同环境中 缺点：运行效率低 时间上，解释器需要时间检查源程序，例如，每一次引用变量，都要进行类型检查，甚至要重新进行存储空间分配，降低了程序的运行速度 空间上，需要有用户程序的运行空间，且解释器和相应的运行支撑系统也要占据空间 编译器的工作原理与基本组成 通用程序设计语言的主要成分 从语言抽象的演变看： 过程->抽象数据类型->类 共同特点：声明+操作=完整定义 以过程式语言为例 声明性语句：提供操作对象的性质，如数据类型、值、作用于等 操作性语句：确定操作的计算次序，完成实际操作 过程定义=过程头+过程体 编译器对两类语句的翻译 声明性语句：填写符号表，生成相应环境（存储空间等） 操作性语句：生成中间代码，如三地址码，注释树 先声明后引用 以阶段划分编译器 词法分析； 语法分析 语义分析 中间代码生成 代码油画 目标代码生成 各阶段工作归纳 各阶段工作归纳 词法分析：识别记号。记号要分类 语法分析：识别语言结构，以“树”形式表示 语义分析：考察结构正确的句子是否语义合法 目标代码生成 符号表管理 出错处理：报告错误，修复错误 错误分类 词法错误：非法字符或拼写错关键字、标识符 语法错误：语法结构出错，少分号、括号不匹配 x = (a+b*c y = 2*/3; 静态语义错误：类型不一致、参数不匹配 动态语义错误（逻辑错误） 死循环，0作为除数等 编译器的分析/综合模式 前端：语言结构和意义的分析 后端：语言意义的处理 中间代码：前后端的分界 一组前端，一组后端 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/CH3笔记.html":{"url":"compile-prin/CH3笔记.html","title":"CH3","keywords":"","body":"CH3 一、CFG 二、产生式 终结符和非终结符的区分 大小写区分：E->id “”区分： E->\"id\" 用<>区分 本课程中 产生式的缩写，若干个产生式具有相同的左部，可合并为一个产生式。 三、CFG产生语言的基本方法——推导 直接推导 利用产生式产生句子的过程中，将用产生式$A\\rarr \\gamma$的右部替换文法符号序列$\\alpha A \\beta$，记作：$\\alpha A \\beta \\Rightarrow \\alpha \\gamma \\beta$ 若对于任意文法序列$a_1$，$a_2$...$a_n$有$a_1 \\Rightarrow a_2 \\Rightarrow \\ldots \\Rightarrow a_n$ 称此过程为零步或多步推导 四、上下文无关文法 由CFG G所产生的语言L(G)被定义为 L(G)称为上下文无关语言，$\\omega$称为句子。若 则称$\\alpha$为$G$的一个句型 五、最左(右)推导 在推导过程中，若每次直接推导的替换句型中最左边的非终结符，则称为最左推导，由最左推导产生的句型被称为左句型。 六、分析树 根由开始符号所标记 每个叶子由一个终结符、非终结符、或$\\epsilon$标记 每个内部结点由一个非终结符标记 若A是非叶子节点的标记，且$X_1,X_2...X_n$是该节点从左到右所有孩子的标记，则$A\\rarr X_1X_2...X_n$是一个产生式。若$A\\rarr \\epsilon$，则标记为A的结点可以仅有一个标记为$\\epsilon$ 的孩子 七、分析书与语言和文法的关系 每一个直接推导，对应一棵仅有父子关系子树，即产生式左部非终结符出右部的孩子 分析书的叶子，从左到右构成G的一个句型。若叶子仅由终结符标记，则构成一个句子 八、语法树 对CFG G的句型，表达式的语法树被定义为具有下述性质的一棵树 根与内部节点由表达式中的操作符标记 叶子由表达式中的操作数标记 用于改变运算优先级和结合性的括号，被隐含在语法树的结构中 语法树和分析书的根本区别 分析树的内部节点是非终结符 语法树的内部节点是操作符 或者说语法树中省略了反映分析过程的非终结符。 九、二义性是什么 文法G对同一句子产生不止一个树，则称G是二义的。 原因：在产生句子的过程中，某些直接推导有多于一种选择。 根本原因：文法中缺少文法符号优先级和结合性的规定 十、悬空问题 直接来说就是else有两种匹配方式 十一、二义性的消除 改写二义文法为非二义文法 规定二义文法中符号的优先级和结和性，使仅产生一棵分析树 改写为 改写二义文法的关键步骤 引入一个新的非终结符，增加一个子结构并提高一级优先级 递归非终结符在终结符左边，使该终结符具有左结合性，否则具有右结合性 十二、正规式与上下文无关文法 从正规式到CFG的构造方法 构造正规式的NFA 若0位初态，则$A_0$为开始符号 对于$move(i,a)=j$，引入产生式$A_i\\rarr aA_j$ 对于$move(i,\\epsilon)=j$，引入产生式$A_i\\rarr A_j$ 若i是终态，则引入产生式$A_i\\rarr \\epsilon$ 十三、自上而下分析 基本思想：推导 对于任何一个输入序列（记号流），从S开始进行最左推导，直到得到一个合法的句子或者非法结构。 特点： 从左到右扫描输入序列，视图用一切可能的方法，自下而上，自左向右建立输入的分析树 自下而上分析是一种试探的过程，是反复使用不同产生式谋求与输入序列匹配的过程 十四、左递归 直接左递归 文法G中的非终结符A，对某个文法符号序列$\\alpha$存在推导$A\\stackrel{+}{\\Rightarrow}A\\alpha$，则称G是左递归的。 若G中有形如$A\\rarr A\\alpha$的产生式，则称： 该产生式对A直接左递归 十五、消除直接左递归 算法实现 输入：文法G，含直接左递归 输出：不含左递归的G' 方法 对每个产生式A，整理A为如下形式 A \\rightarrow A \\alpha_{1}\\left|A \\alpha_{2}\\right| \\ldots\\left|A \\alpha_{m}\\right| \\beta_{1}\\left|\\beta_{2}\\right| \\ldots \\mid \\beta_{n} $\\alpha_i$非空，$\\beta_j$均不以A开始，然后用如下产生式代替 \\begin{array}{l} A \\rightarrow \\beta_{1} A^{\\prime}\\left|\\beta_{2} A^{\\prime}\\right| \\ldots \\mid \\beta_{n} A^{\\prime} \\\\ A^{\\prime} \\rightarrow a_{1} A^{\\prime}\\left|\\alpha_{2} A^{\\prime}\\right| \\ldots\\left|\\alpha_{n} A^{\\prime}\\right| \\varepsilon \\end{array} 十六、消除左递归（非直接） 输入：无回路文法G 输出：无左递归的等价文法G' 核心思想：将无直接左递归的非终结符展开到其他产生式中 方法： 将非终结符合理排序：$A_1,A_2,A_3,...,A_n$ 十六、提取左因子 当不确定用产生式A产生哪个候选项替换A时，可以重写A的产生式来推迟这种决定，直到看见足够的输入能正确决定所需选择为止。 公共左因子（前缀）：$A\\rarr\\alpha\\beta_1|\\alpha\\beta_2$ A\\rarr\\alpha\\beta_1|\\alpha\\beta_2 替换为： A\\rarr\\alpha A' \\\\A'\\rarr\\beta_1|\\beta_2 十七、递归下降分析器 本质：以程序中的过程调用来模拟最左推导 基本思想： 每个非终结符A对应一个子程序（函数A），过程体中： 产生式右部的非终结符B，对应子程序B的调用 产生式右部的终结符T，与输入记号进行匹配 稳妥方法 构造文法的状态转移图并化简 从转移图转化为EBNF表示 从EBNF构造子程序 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/填空题.html":{"url":"compile-prin/填空题.html","title":"填空题","keywords":"","body":"填空题 编译器和解释器是两种不同的语言翻译形态，其中编译器的优势是目标程序运行效率高，解释器的优势是动态特性及可移植性好 在词法分析中，记号的识别是通过有限自动机完成的，根据其下一状态转移是否确定，可将其分为NFA（不确定的有限自动机）和DFA（确定的有限自动机） 词法分析器返回的完整记号包括类别和属性两部分 一个上下文五官文法所包含的四个部分是终结符集，非终结符集、产生式集和开始符号，其中每个产生式均形如“左部$\\rarr$右部”，左部必然是一个非终结符、而右部是终结符、非终结符或空 在语法分析阶段，可以用树来表示语言句子的结构，其中分析树既反映句子的结构，又反映推导过程，而语法树仅反映句子的结构 规范归约是指在移近过程中，当发现栈顶形成句柄时，就将其替换为相应产生式左部的非终结符 在LL(1)分析中，第一个L表示从左到右扫描输入序列，第二个L表示产生最左推导，数字1表示在确定分析器的每一步动作向前看一个终结符 采用LR方法实现语法分析时，改变格局的动作包括移近、归约、接受和报错 设数组A[1…2,1….5,1…4]以行为主存放，每个元组占4个存储单元。已知数组的首地址为4244，则数组元素A[2,5,3]的存储地址是4396-4399 高级程序设计语言中名字的作用域遵守静态作用域规则和最近嵌套规则 在表达式“x:=y”中，x作为左值使用，y作为右值使用 以阶段划分的编译器中，词法分析阶段阶段以字符流为输入，语法分析阶段以记号流为输入 词法分析识别到的每个记号由类别和属性两部分组成 NFA是一个五元组，其中S0表示初态，move表示状态转移函数，F表示终态集 给定文法$S\\rightarrow Sbc|Sa|\\epsilon$，则串abcabc是该文法的句子 在产生式$A\\rarr abc|ade|f$提取左因子的结果是 不知道 在预测分析中，改变分析格局的四个动作分别是移近、归约、接受和报错 给定文法$G:E\\rarr E or T | T$, $T\\rarr T and F|F$，$F\\rarr not | id$，句型$\\text{T and not， F or id}$中的句柄为 不知道 在正规式，CFG与CSG中，CSG可以描述语言$L_1={a^n,b^n,c^n|n\\geq1}$，正规式则只能描述语言$L3={a^k,b^m,c^n|k,m,n\\geq1}$ 在不同的参数传递形式中，值调用传递的是实参的右值；引用调用传递的是实参的左值 三地址码的三个地址分别是运算符、第一个操作数、第二个操作数 布尔表达式a and (c or not (d and e)) or f的后缀式是：不知道 贯穿编译器各个阶段的工作模块是符号表管理和出错处理 描述以abb结束的ab串的正规式是.... 识别2型文法描述语言的自动机是... 在自上而下的语法分析中，需要消除左递归以避免死循环，需要提取左因子以避免回溯二义性 CFC的定义包括 和。。。 自上而下的分析中，需对输入序列进行规范归约，反复用产生式的左部替换举行中的句柄，最终得到不知道 文法产生二义性的原因是缺少对文法符号优先级和结合性的规定 语义规则的两种表示方式是语法制导定义和不知道 4*4二维数组A每维下界均为1，每个元素占1个单元，若数组A的首地址为a，并且以行为主存储，则元素A[2,4]的地址为a+7 继承属性在分析树上的计算次序与自下而上语法分析形成分析树的过程一致 LR分析的语法制导翻译将语义规则放在产生式右部的最右边，LR分析器在执行规约动作时执行语义动作 赋值语句$x=(a(b+c))$的后缀式是xabc+ 参数传递的方法有 值传递、引用传递、复写恢复、换名调用 c语言中的malloc函数使用的是动态分配策略中的不知道 以阶段划分的编译器中，语法分析阶段以记号流为输入，语义分析阶段以语法树为输入 有正规式$P=a|b$和$Q=cd$，则L(QP)= 答案，$L((P|Q)Q)=$答案 有两个因素使得有限自动机是不确定的，一个是 不知道，一个是。。。。。。 词法分析器有四个作用：1.。。。2.。。。3.。。4.。。。。 一个定义正确的上下文无关文法，非终结符集合和终结符集合交集为空，所有出现在产生式左部的文法符号均是非终结符 编译源程序时，发现函数定义末尾缺少花括号，该情况是语法错误，发现除数是0，该情况是语义错误 推导$\\mathrm{S} \\Rightarrow>? \\mathrm{H}=>? \\mathrm{FTP} \\Rightarrow>\\mathrm{FTc}=>? \\mathrm{Fbc}=>\\text { abc }$是xxxx推导 产生$F\\rightarrow A*F|A$提取左因子的结果为xxxxxxx 对于算术表达式a*b+c当采用预测分析方法时，接受格局中年的“当前剩余输入”应该xxxx，初始格局中的当前剩余输入应该是 xxxx 最左归约是xxxx逆过程，每步直接归约均是用替换右句型中的xxxx，直到规约为文法开始符号 在引用调用的参数传递方式中，调用时穿的是实参的xxxx，要求实参必须是xxxx，过程内部对形参的修改等价于xxxx 假定运算+与都是左结合的，且运算比运算+优先级高，则算术表达式的后缀式是xxxx 拉链回填技术是语法制导翻译过程中使用的一种基本技术，其基本思想是当三地址码的转向不确定时xxxxxxxxxxxxxx，而一旦所转向的地址被确定，则xxxx 符号管理和出错处理是编译程序各阶段都涉及到的工作 在编译器工作过程中，实现语言关键字大小写不敏感的阶段是词法分析，分析语言结构的阶段是语法分析阶段 不确定有限自动机中的有限是指状态的数量是有限的 程序的语义错误可分为静态语义错误和动态语义错误 推导的过程可以用一棵树来表示，被称为分析树 a*-(b+c)的后缀式是abc+-* 程序运行时的内存划分与数据空间的动态存储分配策略有 栈分配、堆分配 当文法的候选项首符集两两不相交时，该文法对应的句子的分析不含有回溯性 在自上而下的语法分析方法中，应先消除文法的直接左递归，再消除文法的 间接左递归 LEX和YACC用于生成 词法分析器和 语法分析器 描述含010的01串的正规式是 (0|1)*010(0|1)* 识别3型文法描述语言的自动机是 有限自动机 在自上而下的语法分析中，需要消除左递归以避免 死循环，需要提取左因子以避免 虚假匹配 CFG的定义包含有非终结符、终结符集合、产生式集合和开始符号 自上而下的分析中需对输入序列进行规范归约，反复用产生式的左部替换句型中的 句柄，最终得到开始符号 文法产生二义性的原因是缺少对文法符号 优先级和 结合性的规定 语义规则的两种表示方式是 语法制导定义和 翻译方案 4*4二维数组A每维下界均为1，每个元素占一个单元，若数组A的首地址为a，并且以行为主存储，则元组A[3,2]的地址是是 a+9 综合属性在分析树上的计算次序与 自下而上语法分析形成分析树的过程一致 LR分析的语法制导翻译将语义规则放在产生式右部的 最右边，LR分析器在执行 归约动作时执行语义动作 赋值语句x=a+(b*c)的后缀式是 xabc*+= CFG无法描述语法中的变量声明与引用，可在语义规则中通过对 符号表的插入、查找等操作实现 参数传递的方法有值调用、引用调用、复写-恢复、换名调用 动态分配策略有 栈分配和 堆分配策略 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/about.html":{"url":"compile-prin/marscat笔记/about.html","title":"marscat笔记","keywords":"","body":"Yet another good compile principle note. 原文链接：https://github.com/marsCatXdu/MyCompilePrincipleNote 感谢李学长！ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记1：概述编译相关的基本知识.html":{"url":"compile-prin/marscat笔记/编译原理笔记1：概述编译相关的基本知识.html","title":"编译原理笔记1：概述编译相关的基本知识","keywords":"","body":"编译原理笔记1：概述编译相关的基本知识 编译器的工作步骤 在开始说任何东西之前，我们先来大致看一下编译器是怎么工作的——从代码到程序，大概要经过下面这样的步骤——这里用粗浅的语言进行解释，先有个印象即可，后面还会提到 词法分析：编程语言的语句，由一堆堆的单词组成——比如变量类型名、变量名、函数名、值、符号等。既然我们要让机器来分析源程序然后编译，那么就需要首先让计算机能够明白我们写的语句是什么意思，而理解语句的第一步就是理解每个词。所谓语法分析，进行的工作就是让计算机识别单词； 语法分析：完成词法分析，就要通过语法分析来识别语句的结构； 语义分析：该步骤的目标，就是确定“某一条语句是什么意思”，检查一下说的有没有不合法的地方； 符号表管理：相当于字典。符号表用于各个阶段查找、填写； 出错处理：在出现错误时的处理。种类可分词法错误、语法错误、静态/动态语义错误； 中间代码（可选）可以为优化提供支持。中间代码接近于目标语言，却又与具体硬件对应的机器指令无关，便于优化和代码生成。中间代码优化是对指令进行等价变化，提高运行效率； 中间代码经过优化，就可以生成目标代码了。比如二进制程序的机器码，或者各种 VM 用的字节码。 词法分析器 Lex 和词法分析器 Yacc： Lex（Lexical Analyzar） 是词法分析器， Yacc（Yet Another Compiler Compiler） 是语法分析器。 虽然从名字上看，这两个东西就已经是“分析器”了，然而实际上并不是，他们是用来生成“分析器”的工具。Lex 是用来生成词法分析器的工具，Yacc 是用来生成语法分析器的工具。 这两个工具可以根据我们输入的词法 / 语法规则，自动生成相应的语法分析器、词法分析器，然后这些分析器就可以帮助我们简单地完成对源代码的词法、语法分析。 因这两样工具的存在，开发编译器、解释器的词语法分析器的难度被极大降低。在现代编译器、解释器的开发中，真正有难度的地方在于语义分析和后期优化。 Lex正规式示例： 在 Lex 中，我们可以使用一种被称为“正规式”的字符串，来简单地定义“某种符号应该长成什么样子”。 我们先直接体验一下。 比如下面这个实际定义 Number 和 Identifier 的例子： Yacc 的产生式示例： Yacc 用如下这种形式来定义“一个表达式应该长成什么样子”： E : E '+' E | E '*' E | id 这段代码说明，一个表达式 E 可以有三种情况组成：最简单的情况就是 id 。一个变量 x ，他自己就是一个表达式，两个表达式相加是一个表达式，两个表达式相乘还是一个表达式。 对于这个产生式，如果我们写x-y就是不合法的——因为我们并没有定义两个表达式可以被 ‘-‘ 连接 例：对于 Yacc 而言，-x–y也是合法的。对于表达式“-2–3”，这里的减号有一元操作也有二元操作，实际计算的情况是这样的：(-2)-(-3 ) 语言之间的翻译 高级语言之间可以实现跨语言的翻译。 预编译的例子：sql、c 混合编程。 sql、c 混合编程，实际上的运行方式是先把 sql 变成 c 语言，再对由 sql 转换来的 c 和本来就是 c 的部分进行整体编译。把 sql 转成 c 的过程就叫“预编译”，Lex、Yacc 就是这样的。 在 UltraGram 中，就可以把我们写的 Lex、Yacc 变成合法的 C 代码。我们就可以把这两份代码和我们自己写的 C 代码一起编译，实现开发自己的解释器/编译器。（lex yacc 就是开发解释器编译器这种东西的工具，将曾需要手工实现的词法语法分析自动化实现）。 对于反汇编，编译器为了防止反汇编会在编译时加入一些无效代码。 编译器与解释器 语言翻译 语言翻译分为两种，分别是先翻译后执行和边翻译边执行。二者基本功能相同。且在翻译的角度来看，两种方式涉及的原理、方法、技术都是类似的 先翻译后执行 比如 C 这种需要编译的语言。特点是效率高、省空间。但交互性、动态性差，可移植性也差。。多数语言都是这种。 边翻译边执行 比如 py、js、java 这种使用解释器工作的语言。跟上面的基本相反。 生成字节码然后运行。从高级语言到字节码实际上是翻译，在运行时再从字节码转化成机器码执行。 编译器的工作原理和基本组成 通用程序设计语言的主要成分 语言都由声明、操作两大部分组成，声明+操作=语言的完整定义。 例：过程式语言： 过程式语言有两种语句：声明性语句和操作性语句。前者提供操作对象的性质（比如数据类型、数据值、对象的作用域）。后者则描述各个操作（比如赋值）的次序，进行实际操作。 编译器对上述两种语句使用不同的方式进行处理。对于声明性的，就是给被声明的对象分配一块空间（称为“环境”）。操作则是生成针对环境的可执行代码序列，比如从某个被声明的空间中取值，进行某些运算后将结果放到某个空间中。 因此，“先声明后引用”的规则，能够方便编译器对语言进行处理，也能提升执行效率。 例如，一些语言支持如下操作： i=10; // 在没有对 i 进行声明的情况下直接赋整数值 i=\"abcdefg\"; // 直接重新赋字符串值 虽然看起来是两行代码，但是在实际执行中，执行过程是：为整型分配空间->写入整数值10->重新分配空间->写入字符串值。将导致效率的降低。 以阶段划分编译器 编译器的工作过程可以大致划分为四步：词法分析、语法分析、语义分析、目标代码生成。 这个图要背下来。。。。 其中，中间代码生成及其之前的步骤，编译器和解释器可以是一致的。 词法分析：相当于识别每个词代表什么。进行的工作就是识别单词。单词至少分为：关键字、标识符、字面量、特殊符号； 语法分析：识别语句的结构。通常以树的形式表示； 语义分析：前两者正确的情况下，语义未必正确。确保“什么语句是什么意思”——检查结构正确的句子是否语义合法，也可以修改语法树的结构； 符号表管理：相当于字典。符号表用于各个阶段查找、填写； 出错处理：在出现错误时的处理。种类可分词法错误、语法错误、静态/动态语义错误； 中间代码（可选）可以为优化提供支持。中间代码接近于目标语言，却又与具体硬件对应的机器指令无关，便于优化和代码生成。中间代码优化是对指令进行等价变化，提高运行效率。 例：编译器各阶段工作： 词法分析：将源程序转化为记号流（记号流是线性结构的），源代码中的变量名在记号流中被替换为id1、id2这样的标识符。若我们只写一个 real x，在词法分析执行完后仍然是正确的——词法分析只看代码中的单词是否符合规则，而不关心结构。但在语法分析中就过不了了； 语法分析：该步骤，我们将记号流分析为两个语法树。因为句子是有层次关系的，树又可以用于描述层次关系，因此我们使用语法树来描述句子的语法结构。右下角语法树的意思是：对 id3 和 60 使用 * 进行运算，再将结果和 id2 使用 + 进行操作…… 最后赋值给 id1； 语义分析：对语法分析生成的两个语法树进行分析。 语义分析这一步，要看语法结构正确的语法树的含义是否正确——这一步也可以做些附加的操作，比如这里对60的转换，这就是编译器为了简化语言而自动进行的附加工作——对类型进行了自动转换。另又如C语言中，我们可以写 1+2.0 这样的式子，与此同理，也是编译器自动在语义分析时进行了类型转换。 中间代码优化：将4条语句转为了两条； 目标代码生成，解决汇编、可重定位、内存形式（Load-and-Go）问题 编译器的分析/综合模式 编译器可分为前后端，前端进行语言结构和意义的分析，后端进行语言意义的处理。 中间代码是前后端的分界。编译器的基础架构就分为前端、源代码的中间表示和后端。 编译器扫描遍数 在编译原理中有个术语，叫做“扫描”，“一遍扫描”是指：在编译的每个阶段中，编译程序将程序代码完整分析一遍的工作模式。 比如： 词法分析阶段，把整个程序转化为记号流，这叫一遍； 词法分析，对记号流（记号流本身就是一种程序的变体）分析得到语法树，这又叫一遍； 语义分析，对语法树（语法树是记号流的变体，也就是程序的变体）进行修改，分析得到中间代码，这又叫一遍； 扫描遍数的影响因素： 软硬件条件：如内存太小或者要做全局优化。想要做比较好的优化就需要全面了解程序，扫描的遍数就要增加； 语言结构：如果先声明后引用，就只需要扫描一遍；但如果先引用后声明，处理起来就比较复杂，需要多扫描一遍； 编译技术，比如拉链-回填 goto lab1; ... goto lab2; ... lab1:... 拉链-回填实际上也是先引用后声明，但只需要扫描一遍——当第一次读到引用时，先把后面的目标位置填个问号，读到多次也都填上问号——因为引用了相同的东西，所以这个问号可以“拉成一条链”。当我们确定了lab1的具体标号位置时，就回头把那一串的内容都填上。这并不是第二次扫描，叫做“拉链-回填” 编译器的编写 直接用语言写； 使用编译器编写工具：包括语法/词法分析工具、语法制导翻译、代码生成、数据流分析等； 基于编译器基础架构的编译器构造系统。也就是开放式编译器，比如LLVM、GCC、SUIF等。这样开发，就是自己用工具搞定词法分析、语法分析，再用这玩意做后端，就能开发出来自己的编译器了 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记2：词法分析基础与模式的形式化描述.html":{"url":"compile-prin/marscat笔记/编译原理笔记2：词法分析基础与模式的形式化描述.html","title":"编译原理笔记2：词法分析基础与模式的形式化描述","keywords":"","body":"编译原理笔记2：词法分析基础与模式的形式化描述 词法分析，是词法分析器将源程序转化为线性记号流的过程。该过程中会对各种符号进行分类，比如将变量名换为标识符。 词法分析的含义： 规定词形成的规则，定义什么词是合法的； 根据规则识别输入的序列（词法分析），识别合法单词、指出非法的输入序列。 词法分析 模式、记号、单词 模式（Pattern）： 产生和识别元素的规则。也就是定义的词法规则； 记号（Token）： 按照某个模式（即，规则）识别出的（一组）元素。进行词法分析时，词法分析器将程序代码中的各个部分转为一个个记号的过程，就是根据规则得到一个记号流的过程； 单词（lexeme）： 被识别出的元素自身的值（一个），也称为词值。可以理解为源程序中一个个的字符串。 上面三个词放一起理解：源程序里面是一个个单词，我们使用“模式”这个规则，对单词进行识别、分类，把它们放到相应的记号里面去。记号是一堆单词，Pascal 语言的记号举例如下： 记号的类别 单词举例 模式的非形式化描述 const（01） const const if（03） if if relation（81） , >, >= id（82） pi, count, D2 字母打头的字母数字串 num（83） 3.1416, 0, 6.02E23 任何数值常数 literal（84） \"core dumped\" 双引号间的任意字符串 comment { x is an integer } 花括号间的任意字符串 id: 标识符记号。这里“字母”需要进行严格的形式化描述； literal：字面量； comment：注释 单词的基本分类 关键字 kw（keyword， reserved word） 标识符 id （identifier） 字面量 literal 特殊符号 ks （key symbol， special symbol） 例： 记号 记号 = 记号的类别 + 记号的属性 例如，mycount > 25，由三个记号组成。类别就是上表中对应的类别编号 词法分析器的作用与工作方式 编译器中只有该部分直接接触源代码，其他的部分都是通过使用之前的工作成果来间接接触源代码。词法分析器要进行的工作包括： 去掉注释、空格一类的无用部分； 处理和平台有关的输入，比如文件结束符的不同表示； 根据模式识别记号，交给语法分析器；（主要功能） 调用符号表管理器/出错处理器，进行相关处理。 工作方式： 词法分析器单独进行扫描，生成记号流。再将整个记号流交给语法分析器； 词法分析器作为语法分析器的子程序进行工作，语法分析器调用词法分析器去读源程序，得到词法分析器返回的记号就拿来构造语法树。然后用掉了这个记号就再去调用词法分析器读新的记号，如此重复； 词法、语法分析器并行工作。两者有一个共享的记号流，前者不停读程序、把记号放入记号流，后者不停取记号流来构造语法树。 模式的形式化描述 字符串与语言 从词法分析角度来看，语言是记号的集合。 语言 L 是有限字母表 Σ 上有限长度字符串的集合，字母表是字符的集合。 字母表中的字符能够组成字符串。 例：字母表 Σ={ a, b, c }，则其上的语言 L = { ε, a, b, c, aa, ab, ac, ba, bb, bc, ... } （ε为空串，长度为0） 字符串的基本概念 术语 示例 \\ S\\ \\ abc\\ = 3 ε \\ ε\\ = 0 S1S2 abc def = abcdef Sn (abc)3 = abcabcabc S 的前缀 X abc 的前缀有：ε, a, ab, abc S 的后缀 X abc 的后缀有：ε, c, bc, abc S 的子串 X abc 的子串有：ε, a, b, c, ... S 的真前缀 abc 的真前缀有：a, ab（去掉空和全） S 的真后缀 （去掉空和全） S 的真子串 （去掉空和全） S 的子序列 X abdf 是 abcdef 的一个子序列（和原序列顺序相同，可去掉一些字母） 术语 意义 Φ 空集合 { ε } 空串是唯一元素 X = L ∪ M 并： X = { s\\ s∈L or S ∈M } X = L ∩ M 交：X = { s \\ s∈L and S ∈M } X = LM 连接： X = { st\\ s∈L and t ∈ M } X = L* (星)闭包：X= L0∪L1∪L2∪... X = L+ 正闭包：X= L1∪L2∪L3∪... 若 L = {a, b}, M = {c, d}, 则 LM = {ac, bc, ad, bd}, L∪M = Φ L* = { ε, a, b, aa, bb, ab, ba, aaa, ... } L+ = { a, b, aa, bb, ab, ba, aaa, ... } 正规式与正规集 正规式是用来描述词法规则的，也就是描述：记号该长成什么样子、数字该长成什么样子之类。 正规式（Regular Expression，也叫正则表达式）是在字母表之上的集合——正规式表示集合。 正规式表示的集合叫做正规集，而正规集是语言，因此正规式表示语言。 比如有个正规式是字母 a，那么正规式 a 表示集合 {a}，集合 {a} 就是语言 L(a)。 正规式表示正规集，正规集是与正规式对应的语言。 这两个概念是词法分析的基础。 正规式和正规集的递归定义 Σ 是有限字母表，则其上的正规式及其表示的集合（即正规集）递归定义如下： ε 是正规式，其表示集合（正规集） L(ε) = {ε} 若 a 是 Σ 上的字符，则 a 是正规式，它表示集合 L(a)={a} 若正规式 r 和 s 分别表示集合 L(r) 和 L(s)，则 r|s 是正规式，表示集合 L(r) ∪ L(s)（“|”在正规式中表示“或”，也可以写作 r + s ） rs 是正规式，表示集合 L(r)L(s)（直接将两个语言拼接起来，也可以写作 r·s） r （正规式是一个星闭包）也是正规式，表示集合(L(r))（L(r)这个语言进行星闭包） (r) 是正规式，表示的集合仍然是 L(r)（也就是说正规式 r 外面括上括号得到的 (r) 仍然是正规式，加括号可以用来改变运算次序） 语言是字母表上字符串的集合，而正规式是语言，因此正规式是字母表上字符串的集合。 可以用正规式描述的语言，就是正规语言或正规集 定义的扩展说明 运算有优先级和结合性 三种运算都有左结合的性质（左结合的意思是，当多个同优先级符号连写时是从左往右算。如果从右往左算就叫右结合） 优先级从高到低：闭包、连接、或 正规式中不必要的括号（去掉了也不影响运算顺序）是可以省略的。 例：正规式： a|b*c 表示的语言有以下两种情况： 表示一个串：a 表示另一个串：以 0 到多个 b 开头，以 c 结尾 正规式的等价 长得不同的正规式可以表示同一个正规集（就像加法中的1+3、2+2都可以表示4一样），即，同一个正规集可以对应多个正规式。 正规式等价 定义：若正规式 P、Q 表示了同一个正规集，则称 P、Q 是等价的，记为 P = Q。 【例】： 设字母表 Σ={a, b, c}， 则 Σ 上有： 正规式 正规集 a, b, c {a}, {b}, {c} a\\ b, b\\ a {a}∪{b} = {a, b} a(a\\ b)* {a, aa, ab, aba, abb, aab, ...}，以 a 为首的 ab 串 Σ* {ε, a, b, c, aa, ab, ac, ba, bb, bc, ...} 【例】：令 L(x) = {a, b}, L(y) = {c, d}      则 L(x|y) = {a, b, c, d}           L(y, x) = {a, b, c, d} 判断等价性，可以根据定义，证明两个正规式是否能表达同一个集合；也可以使用正规式的代数性质进行运算比较： 公理 公理 r\\ s = s\\ r ( r s ) t = r( s t ) r\\ ( s\\ t ) = ( r\\ s )\\ t ε r = r ， r ε = r r ( s\\ t ) = r s \\ r t r* = ( r+ \\ ε ) ( s\\ t ) r = s r \\ t r r** = r* 简言之，就是： |可交换、可结合； · 对 | 可分配； · 可结合； 幂等 记号的说明 先复读一遍模式、记号的概念： 模式（Pattern）： 产生和识别元素的规则，就是定义的词法规则； 记号（Token）： 按照某个模式（或规则）识别出的元素（一组）。进行词法分析时，将程序转为一个个的记号，就是根据规则得到一个记号流； 正规式可以用于严格地规定记号的模式。用正规式说明记号的公式： 记号=正规式 读作“记号定义为正规式” / “记号是正规式”。不引起混淆的情况下，可以直接把说明记号的公式叫做正规式/规则 e.g. id = a ( a | b ) 读作：“id定义为a(a|b)\\”（这里的 id 就是一个标识符了。定义为a开头的ab串） 【例】记号 relation、id、num 分别是 Pascal 的关系运算符、标识符和无符号数，它们的正规式表示如下： relation = | > | >= | = id = (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z) (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|0|1|2|3|4|5|6|7|8|9)* num = (0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)* (ε|.(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*) (ε|E(+|-|ε)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*) 其中，一些东西可以进行简化描述 简化描述 正闭包：r 表示 L(r) 的正规式，那么 r+ 就表示 (L(r))+的正规式。 即：r+ = rr = r\\r, r* = r+|ε 比如：(0|1...|9)(0|1...|9)* 可以化简为 (0|1...|9)+ 可缺省：r? 表示 L(r)∪{ε} 的正规式。 即：r? = r|ε 比如： E(+|-|ε) 可改写为：E(+|-)? 上面这些运算中的 +、? 、* 的结合性、优先级相同。 字符组。字符组是正规式的一种形式：对于只由 | 构成的正规表达式 r，可以改写为[r']： r' 可以枚举：正规式 r = a|b|c 等价于 [abc] r' 可以分段：[0123456789abcdefghijklmnopqrstuvwxyz]等价于[0-9a-z] 非字符组。这里的“非”指的是非运算。也就是去掉某部分： 若 [r] 是字符组形式的正规式，则 [^r] 表示 Σ -L(r) 的正规式，例如： 若 Σ={a, b, c, d, e, f, g}，则 L(^abc)={d, e, f, g} 辅助定义。就是给已有的正规式起个名字，以后可以直接用这个名字指代。 （如果 digits 不加花括号，那 digits 就是“ digittttt.... ”） optional_fraction：可选的小数位。小数点如果不加双引号，在这里表示任意一个字符。 optional_exponent：可选指数 上面的是 id，下面的是 num var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记3：有限自动机.html":{"url":"compile-prin/marscat笔记/编译原理笔记3：有限自动机.html","title":"编译原理笔记3：有限自动机","keywords":"","body":"编译原理笔记3：有限自动机 编译，是把人能看懂的代码翻译成机器能看懂的指令（即，机器语言）的过程，说白了核心任务其实就是搞个翻译，把一堆字符串搞成二进制流罢了。想要翻译，就要先搞懂语言的含义，这就需要进行【词法分析、语法分析、语义分析】这三步。词法分析器要干的，就是这第一步的词法分析——读取并识别我们写下的源代码（其实就是一堆字符串）中各个子串或字符，然后把整个源代码转化为一个记号流，以交给后面的语法分析器进行语法分析。 再复读回忆一下这么几个听起来挺怪的词。。 模式（Pattern）： 产生和识别元素的规则。也就是定义的词法规则； 记号（Token）： 按照某个模式（即，规则）识别出的（一组）元素。进行词法分析时，词法分析器将程序代码中的各个部分转为一个个记号的过程，就是根据规则得到一个记号流的过程； 单词（lexeme）： 被识别出的元素自身的值（一个），也称为词值。可以理解为源程序中一个个的字符串。 源程序由一个个单词组成，词法分析就是要使用“模式”这个规则，对单词进行识别、分类，把它们放到相应的记号里面去。 而，有限自动机，就是词法分析器中用于把单词识别成记号的玩意。 有限自动机分为：不确定有限自动机、确定有限自动机 自动机也叫 FA（Finite Automation），FSA（Finite State Automation） 不确定有限自动机（NFA） NFA的定义 NFA 是个五元组：M=(S, Σ, move, s0, F)。(M：machine） S 是有限个 state 的集合； Σ 是有限个输入字符的集合（包括 ε，也就是字母表）； move 是状态转移函数 move(si, ch) = sj：当前状态 si 下若遇到输入字符 ch 则转移到状态sj； 注意：实际上，这个严格来讲不应该叫函数。因为即使我们的 si、ch 都是确定的，执行该过程也未必会得到相同的 sj ！确定的输入得到确定的输出才能叫函数。 s0 是唯一的初态（开始状态）； F 是终态集合（也叫做接受状态集），其为 S 的子集，包含了所有的终态。 NFA 还可以使用状态转移图、状态转换矩阵来表示。 状态转移图和状态转移矩阵 状态转换图 NFA 中的每个状态，对应转换图中的一个节点； NFA 中每个 move(si, a) = sj，对应转换图中的一条有向边，表示从节点 si 出发进入节点 sj。字符 a（或 ε）是边上的标记。 状态转换矩阵（图例见下图） 每个矩阵元素 M[si, a] 中的内容，是从状态 si 出发，经过字符 a（或 ε）所到达的下一状态 sj； 一般以矩阵第一行所对应的状态为初态，而终态需要单独指出。 转移图的初态用一个单独的箭头表示，终态可以用粗线条的圆圈也可以用两层圆圈 图的关系可以使用矩阵表示。因此我们可以构造这样一个状态转移矩阵。在这个矩阵中： i 状态接受 b 能跳到 j 状态。 出错：“串不被 NFA 接受” 如果在 1 这里接收到了 a ，那就说明出错了，需要到出错处理。也可以专门为错误的跳转增加一个“死状态”（如下图）。如果一个输入的串尝试了所有可能的路径，最后的结果是朝着未定义的方向跳过去了，那就叫做“这个串不被NFA接受” NFA对记号的识别 一般方法（串行）： 【反复试探所有路径，直到到达终态，或者到达不了终态】 简单地说，就是：从初态开始，每接受一个字符跳一下，一条路径跳不到终态就尝试另一个。只要能跳到终态，就说明一个字符串是合法的单词，就把这个记号归入到一个记号里面了。如果无论如何都跳不到终态，那就是这个字符串不合法。 以 (a|b)*abb 的 NFA 为例： 不过，这里存在一个问题：从 0 开始跳，可以跳到 0 和 1 这两个下一状态呀，那么在 0 状态时，接收到 a 是跳 0 还是跳 1 呢？嗯，就是这样的，确实是哪个都有可能——跳哪个完全是随机的。这就是不确定性，即从同一状态出发，对同一个字符可以跳到多个下一状态。 在这个例子中，万一我们第一步没有从 0 跳到 1 而是从 0 到 0（更极端一些，abb都是从 0 跳到 0。。），那就会导致即使把 abb 都跳完了也跳不到终态。如果把所有输入序列都走完了却还没有到达终态，那么 NFA 就不接受这个路径，就要去尝试下一个路径——也就是说，如果选错了走不下去就要后退去换条路重新走，和走迷宫差不多。最后，需要把所有的岔路都走完了才能确定对于这组输入是否能够到达终态。 每次匹配使用的是最长匹配，这种方式被称为【最长识别原则】：如果没有跳完所有的输入字符，即使中途到达了一个终态集中的状态，也不能就此完事。而应该在此之上继续根据连续的输入字符接着往下跳。 【例】：识别下表中 relation、id、num 的转移图 记号的类别 单词举例 模式的非形式化描述 relation（81） , >, >= id（82） pi, count, D2 字母打头的字母数字串 num（83） 3.1416, 0, 6.02E23 任何数值常数 NFA 的 ε 转移也有不确定性 因为任何字符串在中间的任何位置插入一个 ε 后的值仍和原来相等（即，一个字串任何位置插入一个空字串后并不会发生改变。。听起来像废话），因此，我们对于一个可以通过 ε 跳转的边，我们可以选择在任意的时候通过这条边跳走。例如： 如图，我们可以在多个位置选择跳转 ε NFA 存在严重的问题 需要尝试全部的路径才能确定输入的串是否能被接受； 因为要进行大量回溯，所以复杂度会提升。 因此，有了 有限状态机 确定有限自动机（DFA） DFA 也是一种 NFA，但 DFA 要求不能有 ε 状态转移，且对每个状态 s 和每个字符 a 最多有一个下一状态。 DFA 中不存在回溯，无论接受还是不接受一个串，都只会扫描一遍。只需要扫描一次，就能确实是否接受。 对于不同的 DFA，实际使用的识别方法是相同的——无论使用什么样的 DFA 和输入序列，都是一样的要从初态开始随着输入序列去一步步转移，直到输入序列扫描完，判断到没到终态即可。 也就是说，这种识别的运行方式，与具体的 正规式（正规式决定了DFA是什么样子） 和输入序列无关，那么这种运行方式就可以被独立出来，和不同的 DFA 直接一起工作。 这种运行方式可以写成算法，这个算法就叫做”模拟器“（模拟 DFA 的行为）或”驱动器“（用 DFA 驱动的数据驱动分析动作）。算法和 DFA 放在一起，就是词法分析器的核心了，可以识别记号。这里只有 DFA 和模式是有关的，算法和模式没有任何关系。 我们在使用的时候，词法规则是要作为数据输入给算法的。 关于模式、记号、单词、词法分析器，再复读一遍。。 模式（Pattern）： 产生和识别元素的规则，就是定义的词法规则； 记号（Token）： 按照某个模式（或规则）识别出的元素（一组）。进行词法分析时，将程序转为一个个的记号，就是根据规则得到一个记号流； 单词（lexeme）： 被识别出的元素自身的值（一个），也称为词值。可以理解为源程序中一个个的字符串； 记号是一堆单词，其基本可分为：关键字、标识符、字面量、特殊符号这些。一个记号由记号的类别和记号的属性组成。比如程序中有一个变量名 myCount ，它的类别是 id，它的属性就是”myCount“； 语法分析器：相当于识别每个词代表什么。进行的工作就是识别单词； 源程序里面是一个个的单词，我们使用“模式”这个规则，对单词进行识别、分类，把它们放到相应的记号里面去。 算法：模拟 DFA 输入： DFA D 和输入字符串 x(eof)。 D 的初态为 s0，终态集为 F 输出：若 D 接受 x，回答“yes”，否则回答 “no”。 方法：用下述过程识别 x： s:=s0; -- 设置初值 ch:= nextchar; -- 设置初值 while ch!=eof loop -- 循环 s:=mvoe(s, ch); ch:=nextchar; end loop; if s in in F -- 返回结果 then return \"yes\"; else return \"no\"; endif; 对于没有下一状态转移的情况，我们可以给这个没有转移的字符增加一个死状态（就是下图的 d ），然后在死状态无论进行什么跳转都会跳回到死状态自身。 如下图， 若 1 状态出发没有标记为 a 的边，我们就可以给 a 引向一个死状态 有限自动机的等价 如果两个 FA 能识别同一个正规集，那么就说这两个 FA 等价。 正规式、FA 都能表示正规集——正规式能够描述正规集，而 FA 能够识别正规集。 因此，正规式和 FA 能够表示相同的正规集，这时，该正规式和 FA 就是等价的。 可能存在的等价关系： 两个描述相同正规集的正规式等价； 两个识别同一个正规集的NFA等价； NFA、DFA 同上； 其他都差不多是一个意思——两样东西能表示同一个正规集，那这两个东西就是等价的。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记4：从正规式到词法分析器（1）：构造词法分析器的一般步骤、从正规式到 NFA.html":{"url":"compile-prin/marscat笔记/编译原理笔记4：从正规式到词法分析器（1）：构造词法分析器的一般步骤、从正规式到 NFA.html","title":"编译原理笔记4：从正规式到词法分析器（1）：构造词法分析器的一般步骤、从正规式到 NFA","keywords":"","body":"编译原理笔记4：从正规式到词法分析器（1）：构造词法分析器的一般步骤、从正规式到 NFA 一般方法和步骤 用正规式描述模式（描述词法规则）； 为每个正规式构造一个 NFA ，这个 NFA 识别正规式表示的正规集（即，将正规式转成 NFA。正规式和NFA在这里就描述同一个正规集了，他们两个是等价的）； 将上一步得到的 NFA 转换成与之等价的 DFA ，这一步叫做”确定化“； 优化上一步得到的 DFA，使其状态数最少，这一步叫做 ”最小化“； 从 上一步 得到的 DFA 来构造词法分析器。 在上面的步骤中，我们通过 NFA 构造 DFA 而非直接构造 DFA ，是因为有专门的算法工具来一步步完成从正规式->NFA->DFA->分析器的工作。这样我们就可以省略中间的手工劳动步骤。 虚线框内部的，就是 Lex 的工作内容和原理。 我们使用的时候，直接从正规式使用工具转化为词法分析器就可以了。接下来我们从正规式开始一步步搞懂词法生成器是怎么一回事。 从正规式到NFA 先复读一下正规式：正规式是用来描述词法规则的，也就是描述：记号该长成什么样子、数字该长成什么样子之类。 Thompson 算法 它的任务，是将正规式转化为与其等价的 NFA。 也就是说，它可以将任意的字母表 Σ 上的正规式 r ，转化为一个能够接受 L(r) 的 NFA N。 想要构造一个正规式，我们需要从最简单的正规式（也就是 ε 和一个个字母）开始，通过一步步添加运算，逐步把它构造成我们想要的目标正规式。最简单的正规式就是 ε 和字母表上的一个个字符。 NFA 的构造步骤和正规式的构造步骤是相同的，构造两种东西的每一步都可以对应起来。因此，NFA 也要从最开始的小 NFA 开始构造。 每一种 NFA 都能和一个正规式相对应，如下图所示 回忆NFA，再观察上图中的正规式和NFA 3~6 可以发现这样的一个问题： Q：我们知道自动机可以有多个终态，可是 3-6 的这几个自动机直接使用已有的自动机作为自己的一部分，怎么可以假设这些被包含的自动机只有一个终态呢？ A：这是因为图中的 NFA 都是递归构造出来的——也就是说，我们认为上面3-6自动机中的 N(P)、N(Q) 自动机也都是用 Thompson 构造算法构造的，而只要是该算法构造出的 NFA，就一定都是只有一个终态的。 而且，其实对于任意的多终态 NFA，我们都可以把它转化一个单终态NFA——方法非常简单，只需要将它的所有终态引出一条 ε 边，指向一个唯一的新终态即可。 例：用 Thompson 算法构造正规式 r=(a|b)*abb 的 NFA N(r) 先从最小的正规式对应的 NFA 开始构造，再把得到的 NFA 进行组合，得到最终的 NFA 。 注意： 该算法中，NFA 的构造与正规式的构造步骤是一一对应的； 构造一个新的 NFA ，最多会增加两个状态（始、终），对于连接运算，则会减少状态。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记5：从正规式到词法分析器（2）：NFA 记号识别、确定化、并行算法、子集法构造DFA.html":{"url":"compile-prin/marscat笔记/编译原理笔记5：从正规式到词法分析器（2）：NFA 记号识别、确定化、并行算法、子集法构造DFA.html","title":"编译原理笔记5：从正规式到词法分析器（2）：NFA 记号识别、确定化、并行算法、子集法构造DFA","keywords":"","body":"编译原理笔记5：从正规式到词法分析器（2）：NFA 记号识别、确定化、并行算法、子集法构造DFA NFA 识别记号的并行方法 之前的文章中写过的 “用一个输入字符串在一个 NFA 中逐个尝试各种路径、最终找到一条从初态到终态” 的方法被称为“NFA识别记号的串行方法”，然而这种方法效率着实不高——一条路走不通，要退回去重新走（也就是回溯），从而产生大量的无效计算。 为了解决效率问题，我们可以改变思路，实现记号的并行识别——这种方式可以防止由于反复试探产生的回溯。 具体思路是：从起点开始，用同一个输入字符同时去尝试到下一步的所有可行的路径。这样立足于当前，把所有可能的下一步全都跳完一次，再把这些结果收集起来，就可以获得一个”从当前起点开始所有可达的下一点的集合“。 此时我们虽然不知道这个集合中哪一个才是能够满足后续需求的（也就是能最终走向终态的），但至少这个集合中该有哪些元素，已经是确定的了。 接下来，再从上一步得到的集合中的所有点同时出发，每一个状态都按照上面相同的方式去尝试所有可达的下一状态，然后将所有收集到的可达状态再放入一个新的集合——这样我们就获得了从第二个状态出发的可达状态集合……如此往复，走遍所有的状态，最后的终态节点就在最后一个可达状态的集合中。 因为我们在每一步都考虑了下一步所有可能的转移，因此收集到的状态集合，就都是“确定”的了。 我们把一个个不确定下一步收集起来变成一个下一步集合，这样就实现了将不确定的下一状态确定化 NFA 上识别记号的确定化方法 NFA 的不确定性，是由于：1. 从一个状态通过同样的字符可以达到不同的下一状态；2. 允许出现 ε 状态转移。 因此，为了消除这种不确定性就需要以下两个步骤： 消除多于一个的下一状态转移： smove(S, a)，S 是状态集合，a 是字母表里的一个字符（不能是 ε ）； 消除 ε 状态转移：使用函数 ε-闭包(T)，状态集 T 的 ε 闭包 smove(S, a)：从状态集 S 中的每个状态出发，经过标记为 a 的边，直接到达的下一状态的全体； ε-闭包(T)：从状态集 T 中的每个状态出发，经过若干次 ε 转移，到达的状态全体。（经过任意有限次 ε 的都算） 状态集 T 的 ε-闭包(T) 定义：状态集 T 的 ε-闭包(T) 是一个状态集，其满足： T中所有的状态属于 ε-闭包(T)； （经过若干次 ε 转移嘛，当然 0 次也是算的，零次转移所能达到的当然就是所有的自身状态） 如果 t 属于 ε-闭包(T) 且 move(t, ε)=u，则 u 属于 ε-闭包(T)； （比如 t 是之前的 T 的元素经过 n 次空转移到的状态，这里的 u 就是经过 n+1 次空转移到的） 除此之外没有其他状态属于 ε-闭包(T) 所有经过 ε 跳转后抵达的状态都是结果集中的一个元素。 ε-闭包算法 闭包U：是一个集合，其存储闭包计算的结果； 栈：栈中的元素，就是当前还没有考虑的状态节点（需要我们去考虑从该处沿空边出发的节点），没有考虑空边的状态都要入栈，需要考虑更多空边的时候，就从栈里面往出取节点就行了。 function ε-闭包(T) is begin for T中的每个状态t // T 是要计算闭包的集合 loop 将t加入U;// 先加入所有初状态，它们也算闭包运算结果元素 push(t);// t是新加入的，当然没有考虑过它连接的空边，入栈 end loop; while 栈非空 // 考虑经所有的状态引出的空边，能到达哪些状态 loop // 对每一个状态，找空边所能到的所有下一状态 pop(t); // 栈顶的拿出来，考虑从该状态出发的空边转移情况 for 每个u=move(t, ε) //若存在u，可以从t经过空边跳到 loop if u不在U中 then //新跳到的这个 u 并没有被加入 U 将u加入U; push(u);//因为是新来的，故也没考虑过它的空边 end if; end loop; end loop; return U; end ε-闭包 例： 图中的 U 代表我们最终返回的的结果集合，其元素是在整个算法运行的过程中被逐渐添加的；Stack 是上面伪代码中提到的“栈”，用来存储运行时临时保存的待考虑状态（也就是还没被检查所有下一状态的状态）。 NFA 并行算法 输入：NFA N, x(EOF)， s0（NFA的初态），F（NFA的终态集） 输出：若 N 接受 x，打印“yes”，否则\"no\" 方法：用下面的过程对 x 进行识别，其中 S 是一个状态的集合 与前面的 模拟DFA 相比，有如下区别： 模拟DFA 模拟NFA 开始 初态只有一个（s0） 初态是个集合（S） 下一状态转移 得到下一个单一状态 得到下一状态集合 结束 s is in F，即终态在终态集中 S∩F ≠ Ø 但模拟 DFA 与模拟 NFA 也有一个共同点，就是【算法与模式无关】：DFA 和 NFA 都是作为数据（参数）交给算法的，算法的运行与具体的自动机无关。 NFA 并行算法例：识别 abb 和 abab 所用的 NFA 如下图所示 识别 abb： 计算初态集： ε-闭包( {0} ) = {0, 1, 2, 4, 7} 记作集合A 该步骤创建初始状态集 读取到输入字符 a，计算从 A 出发经过 a 到达的状态集：ε-闭包( smove(A, a) ) = {8, 3, 6, 7, 1, 2, 4} 记作集合B，B 的详细计算过程如下，写的比较细，懂的可以直接略过。。 因想要的是从状态集合 A 出发进行经过 a 的状态转移再求个空闭包，因此我们需要对于集合 A 中的每个状态，都进行一次 a 状态转移，再将转移后的结果放入一个新的集合，最后对这个集合整体求一次空闭包。这一步骤，我们一步步来，首先我们建立一个临时集合 T，用于存放 A 集合中经过 a 了转移，却还没有进行闭包运算的状态。 对集合 A 中的状态 0，没有从 0 开始的 a 转移，无事发生，不需要填入集合 T； 对集合 A 中的状态 1，没有从 1 开始的 a 转移，同样不需要填入集合 T； 对集合 A 中的状态 2，其经过一次 a 转移，到达状态 3，将 3 加入 T，现在 T = {3}； 对集合 A 中的状态 4，没有从该状态开始的 a 转移，不填入 T 集合； 对集合 A 中的状态 7，其经过一次 a 转移，到达状态 8，将 8 加入 T，现在 T = {3, 8}； 至此， ε-闭包( smove(A, a) ) 中的 smove(A, a) 计算完成，其结果是 smove(A, a) = T = {3, 8}； 接下来，对 T 进行闭包运算： 3 经过一次空转移，得到 6； 3 向右侧进行一次空转移，得到 7； 3 向左侧进行一次空转移，得到 1，再从这个 1 出发，进行空转移，得到 2、4； 没有从 8 开始的空转移。 至此，ε-闭包( T )，也即 ε-闭包( smove(A, a) ) 计算完成，结果是{3, 8, 6, 7, 1, 2, 4} 读取到输入字符 b，计算从 B 出发经过 b 到达的状态集：ε-闭包( smove(B, b) )={9, 5, 6, 7, 1 , 2, 4}，记为集合 C（计算方法与上一步完全相同）； 读取到输入字符 b，计算从 C 出发经过 b 到达的状态集：ε-闭包( smove(C, c) )={10, 5, 6, 7, 1, 2, 4}，记为集合 D （计算方法与前两步完全相同）； 结束。计算 D∩{10} = {10}，终态集与结果集交际非空，接受。识别的路径为 AaBbCbD 因此，我们可以确定， 初态和终态之间存在一条为 abb 的路径。 但实际上，对abb的识别也可以认为是： 0 ε* A aε* B bε* C bε* D，即，通过一个输入字符进行直接转移后，再经过若干次的空转移，转移到了下一下一状态集。路径上的标记是 ε*aε*bε*bε*，去掉空转移就是 abb 了，即 ε*aε*bε*bε* = abb。 识别 abab 初态集： ε-闭包( {0} ) = {0, 1, 2, 4, 7} 记作 A 从 A 出发经 a 到达：ε-闭包( smove(A, a) ) = {8, 3, 6, 7, 1, 2, 4} ，记作 B 从 B 出发经 b 到达：ε-闭包( smove(B, b) ) = {5, 9, 6, 7, 1, 2, 4} ，记作 C 从 C 出发经 a 到达：ε-闭包( smove(C, a) ) = {8, 3, 6, 7, 1, 2, 4} ，等于 B 从 B 出发经 b 到达：ε-闭包( smove(B, b) ) = {5, 9, 6, 7, 1, 2, 4} ，等于 C 识别路径为：A a B b C a B b C，由于 C ∩ {10} = Ø，所以不接受。 观察上面的两个识别过程可以发现，当我们使用同一个 NFA 去识别两个字串时，产生了大量的重复计算（两个例子的前三步是完全相同的，第二个例子中的 3、5 也进行了完全相同的转移却又重新进行了计算）。 既然会出现对于相同输入的、重复条件下的重复计算，那么我们就可以在这里偷懒了——我们可以在正式使用一个 NFA 之前，对这个 NFA 进行预先的分析和计算，把在各种状态集情况下进行的各种转移情况计算出来，存储在一张表中。这样当我们真正分析输入序列时，就可以根据当前的状态和要进行的转移去查表、得到结果了！ 这就是子集法构造 DFA 的思路——子集法构造 DFA，实际上就是对 NFA 并行识别记号方法的提前计算并记录的过程！ 将 NFA 上的全部路径确定化并记录下来，就能够造出与该 NFA 等价的 DFA 下面举个例子来说明 NFA 到 DFA 的转化 这个例子假设了一个人要从甲地出发到达乙地，如下图左侧部分所示。中间 1、2、3 是途中经过的地点，转移的 c 指汽车，b 指自行车，我们要找出从甲到乙的交通方式的组合。 这个问题的模型实际上是个 NFA，就像图上画的那样。对于该 NFA，我们可以通过预计算的方式，建立一个经过状态转移到达到达状态集的 DFA（DFA 中的每个状态都是一个状态集——以原来的 NFA 中的某些状态为元素组成的集合）。该 DFA 与原 NFA 等效，能够识别 cc、ccb、cbb 识别 cc：甲 _c_ {1, 2} _c_{3, 乙}，接受 识别 cbc：甲 _c_ {1, 2} _b_{3} _c_ ? ，不接受 DFA的优点： 消除了不确定性（将 NFA 的下一状态集合，合并为一个状态） 无需动态计算状态集合（相对于模拟 NFA 算法） 对于有 k 个状态的 NFA，与之等价的 DFA 最多有 2k 个状态（因为 DFA 中的每个状态都是 NFA 所有状态的一个子集，所以 DFA 的最大状态数量就是 NFA 的子集数量） 从 NFA 到 DFA（子集法构造 DFA ） 该算法将从 NFA 的初态开始，生成可达状态机状态之间的转移关系。 输入： NFA N 输出： 等价于 N 的 DFA D。初态 ε-闭包( {s0} )（这个东西的运算结果，就是 NFA 的初态集），终态是含有 NFA 终态的状态集合。 该算法中要用到两个数据结构：Dstates（状态，用于存储生成的 DFA 状态）、Dtran（用于计算 DFA 状态之间的状态转移） 方法：用下述过程构造 DFA： 我们要将字母表中所有的字符都考虑一遍之后，才能说考虑完一个状态和与之相关的状态转移。然后再去考虑其他没有被标记的状态（也就是Dstates中的其他元素），即回到最外层的while，开始新的一轮循环——再去考虑在这个状态下，经过字母表中所有字符能够达到的状态。 最后当 Dstates 中没有剩余元素时，DFA就完全生成了。最终得到的 Dstates 和 Dtran 就是我们最终生成的 DFA （即，我们得到了一个确定的状态转移表） 例：用上述算法构造(a|b)*abb 根据这些运算的结果，我们就可以构造出来如下图所示的自动机： 嗯，这样就完成了我们的 DFA 了。 DFA 可真是个好东西，一旦有了 DFA，我们就可以根据它来简单地识别输入序列了！不用再进行那种粗野的蛮力计算了。 但，我们当前的 DFA 就已经是最优了吗？当然不，还能优化的！ 再观察我们上面画出来的 DFA，不难发现（老师说不难发现，我还真就没看出来。。。），从 A 开始经过a、b能够到达的下一状态，和从 C 开始经过a、b能够到达的下一状态是相同的！（A经过a到达B、A经过b到达C；C经过a到达B、C经过b到达C） 这种情况，我们就说 A、C 是等价的：分别以这两个为初始状态，在经过不同的输入序列转移后达到的效果完全相同。 这样，我们就可以把A、C合并，改写成下面的形式——从A、C出发的都改为从0出发，修改后就能得到新的DFA，减少了一个状态。这就叫最小化 DFA 具体的最小化，下篇博客再说，这个已经太长了。。。。。。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记6：从正规式到词法分析器（3）：DFA最小化、词法分析器的构造、Lex 使用示例.html":{"url":"compile-prin/marscat笔记/编译原理笔记6：从正规式到词法分析器（3）：DFA最小化、词法分析器的构造、Lex 使用示例.html","title":"编译原理笔记6：从正规式到词法分析器（3）：DFA最小化、词法分析器的构造、Lex 使用示例","keywords":"","body":"编译原理笔记6：从正规式到词法分析器（3）：DFA最小化、词法分析器的构造、Lex 使用示例 从 DFA 到最小 DFA 关于星闭包的补充：一个语言被认为是所有可能字的子集。所有可能字的集合可以被认为是所有可能的字符串串接的集合。 DFA 最小化的过程，就是通过某些等效转换减少原 DFA 状态数的过程——这里的“等效转换”，就是对多余的状态进行合并。 那，什么叫多余？这里的多余，指的是对于同样的输入会得到同样的结果——比如在上面NFA转DFA的例子中，我们观察得到的DFA，发现其中的A、C状态对于字母表中任意的输入，都会给出相同的结果。那么这个A和C对任意输入而言就是等效的，它们两个就可以互相替代，我们也就可以把它们合并成一个状态。 将DFA最小化需要去除多余状态，所以如何最小化DFA的问题就转化为了如何找出“多余状态”的问题。我们需要一个方法来帮助我们判断某个状态是否是多余的。这里引入“等价”、“可区分”、“划分”的概念。 等价 定义：设 p、q ∈ S，对于任一输入序列 w∈Σ*，有 move(p, w)∈F 且 move(q, w)∈F，则称状态 p 和 q 等价。否则称 p、q 是可区分的，也就是存在 x∈Σ*，使得move(p, x) 和 move(q, x) 不能同时进入终态。 可区分 对于DFA中的任意两个状态t、s，若从其中一个状态出发能够接受输入字符串 ω，而从另一个状态出发却不能接受 ω，则称 ω区分状态t和s。如果存在某个能够区分状态 t 和 s 的串，那么状态 t 和 s 就是可区分的。 因此，如果我们找到这样一对 t 和 s ，对于从它们两个状态分别出发的任何的输入序列 ω，都能够最终到达相同的结果，那么 t 和 s 就可以合并成一个状态。 因此，最小化 DFA 的本质，就是将 DFA 中的状态分成不同的组，使得同一个组中的状态之间不可区分（也就是等价的），而不同组的状态之间可区分（也就是不等价）。当我们把每个组内的状态都合并成为一个状态后，我们就能够得到一个最小 DFA 了 （其实就是把DFA中的各个状态划分成几个等价类，然后把等价类内的状态进行合并。这样最终得到的最小DFA的状态数就是之前我们划分的等价类数。每一个等价类对应最小DFA中的一个状态） 划分 给定一个DFA，我们可以确定： DFA 的终态和非终态是可区分的；（使用 ε 即可区分终态和非终态。因为 DFA 中不存在 ε 转移。DFA 中的任意状态经过 ε 都不会发生改变） 若分别从 s 和 t 出发，沿着标记为 x 的路径到达的两个状态p、q是可区分的，那么 s 和 t 也是可区分的。 这里的 p、q 是我们已知可区分的——因为对于 p、q，如果有相同的输入序列 y 使得他们分别到达终态和非终态，那么 p、q 就是可区分的了。一旦 p、q 可区分，则 s、t 经过输入序列 xy 就能够分别到达 f、g ，也就随之满足可区分的定义了 算法：最小化 DFA 的状态数（DFA化简） 输入：DFA D = {S, Σ, move, s0, F } 输出：等价的 D' = {S', Σ, move', s0', F' }（D' 的状态数最少） 主要步骤： 进行初始化分，获得终态和非终态； 利用“可区分”的概念，反复分裂划分中的组 Gi，直到不可再分裂； 由最终划分构造 D'，关键是用等价的概念对一些状态进行合并，选出新的代表状态并修改状态转移； 消除可能的死状态的不可达状态。 化简的基本思路，其实就是把原来的状态集按照等价关系进行划分（划分后的子集互不相交），同一子集内元素等价，不同子集元素可区分。将每一个子集中的状态合并成一个状态，就可以得到一个新的状态集 Snew，原初态s0所在子集就成为化简后状态机 Dnew 的新初态 s0new ，原终态所在子集就成为化简后的 Dnew 的一个新终态。 下面用这个算法来化简我们前面的 DFA 每个DFA都能够最小化，这里有个定理： 对于一个 DFA D = {S, Σ, mvoe, s0, F}, 存在唯一一个最小状态（就状态数而言）DFA D' = {S', Σ, move', s0, F'} 与 D 等价。 手写 DFA 建出来了 DFA 的状态转移图，我们就可以通过直接编码的方式来为我们的 DFA 手写词法分析器了。由于操作复杂，故实际应用中不会使用这种方法构造词法分析器，而是会使用 Lex 进行该工作。 此处先略，日后再补。。。（坑） 词法分析器的构造 实际应用中，我们使用工具来生成词法分析器。因为从正规式到词法分析器这个过程中的每一步都有对应的算法来实现。我们构造自己的词法分析器，只需要使用 Lex 就可以了。 Lex 使用示例 点击 Lex 中的 编译按钮 ，将会生成一个 .c 和一个 .h 文件 对于词法解析错误的输入，lex 编译出的程序将会直接把错误的输入回显 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记7：语法分析.html":{"url":"compile-prin/marscat笔记/编译原理笔记7：语法分析.html","title":"编译原理笔记7：语法分析","keywords":"","body":"编译原理笔记7：语法分析（1）语法分析器的任务、语法错误的处理 语法分析器是编译器前端的核心 语法分析器的两项主要任务，分别： 是根据词法分析器提供的记号流，为语法正确的输入构造分析树（或语法树）； 检查输入中的语法 / 词法错误，并调用出错处理程序进行相应的处理。 语法错误的处理 源程序中的错误可以分为词法/语法错误、语义错误两类。前者主要形式是命名不合法、关键字书写错误、语法结构有问题（比如缺分号、该配对的东西不配对）等；后者则可分为静态/动态两种，静态例如类型使用错误、参数使用错误等，动态语义错误则是无穷递归这类逻辑性的问题。 语法错误的处理目标 不多不漏地报告所有错误出现的准确位置； 发现一个错误后能够继续分析，做到一次分析完整个程序，再一次性指出所有错误； 尽量小地降低分析速度（分析速度和扫描遍数有关）。 语法错误的基本恢复策略 紧急恢复：抛弃掉一些输入，直到遇到同步记号； 短语级恢复：对错误进行串替换，纠正错误； 出错产生式：用出错产生式捕捉（预测）错误； 全局纠正：找到和错误输入序列 x 最相近的序列 y，然后用 y 替换掉 x 。 例如： x = a+b y = c+d; 紧急恢复：x = a+b+d; // 丢弃掉 b 后的记号，直到遇到 + 短语级恢复： x = a+b; // 加入分号 在写程序时，要养成减少错误的好习惯：每次用变量、参数时，要在使用之前进行初始化，并在直接使用之前检查一下是否出现值为空等问题，防止出现不可预知的错误 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记8：语法分析（2）上下文无关文法 CFG.html":{"url":"compile-prin/marscat笔记/编译原理笔记8：语法分析（2）上下文无关文法 CFG.html","title":"编译原理笔记8：语法分析（2）上下文无关文法 CFG","keywords":"","body":"编译原理笔记8：语法分析（2）上下文无关文法 CFG 写在前面： 前几篇博客中说到的词法分析，做的是从 【x+y → id+id】 的工作，也就是要将源代码变成一个记号流。语法分析，就是要通过为这个记号流序列（在“龙书”中，该序列被称为“词法单元序列”）构造一棵语法分析树，构造该树的方式就是“推导”（事实上，分析树其实是推导的图形化表示）。 若能够进行这样的推导： E=>E+E=>id+E=>id+id，即由 E 推出了 id+id，与从词法分析器那里得到的 id+id 相同，则说明语法结构正确。 CFG 概述及其四元组表示 CFG 是什么？CFG 是描述语言语法的工具，CFG 通过推导的方式产生语言。我们使用这个工具来对定义我们的语法，然后可以使用一些算法来基于它构造我们想要的词法分析器！这个分析器能够将我们的记号流构造为合法的语法树。  类似于我们在这里学过的很多其他东西，CFG 也一样可以使用四元组表示：  CFG G=(N, T, P, S)  该四元组中的 N、T、P 都是集合，分别是 非终结符（Nonterminals）、终结符（Terminals）、产生式（Productions） 的集合。S（Start Symbol） 是文法的开始符号，是一个特殊的非终结符。 其中： N 和 T 没有交集； P 的形式是 A→a，A∈N，a∈(N∪T)*（终结符或非终结符组成的一个串），箭头左侧的被称为左部，右侧的被称为右部 与 CFG 相对的，还有一种文法叫做“上下文有关文法”即 CSG（Context Sensitive Grammar）， int i; i = 10; // 这就叫CSG，下面 i 的值要和上面声明的相关 下面这种就是 CFG： int i; i = \"abc\"; 然而，CFG 也可以使用符号表来处理上下文有关的情况。例如，当我们读到 \"int i;\" 时，就将 i 放入符号表中存储下来，当我们后面遇到 \"i=10;\" 时，就要到符号表中查找是否有已经声明过的 i 存在。注意，这种处理上下文有关的方式不属于语法分析的方法。 例子：简单的算术表达式的 CFG 表示： 产生式中的 “ → ” 读作“定义为” / “导出为”，例如 “ E→E+E ” 读作 “E 导出为 E+E”，其表示 “算术表达式定义为两个算术表达式相加”。 注意，CFG 一旦定义完成，语法也随之定义完成了。因此，对于一个句子的合法性检查，就要根据我们定义的 CFG 来做。比如，如果按照上面这个例子的语法定义来看，“- - - - - id” 就是一个合法的句子，而 “ id - id ” 却不合法。若想要其合法，我们需要在产生式中追加 “ E→ E - E ” 。 产生式集合表示 CFG 然而，用四元组来表示 CFG 还是太麻烦，因此大佬们提出了这样一个简化的表达方式——只写产生式集合，然后其他的部分我们可以通过一些预先约定好的规定来通过产生式集合求出来。这样一来，我们就可以省略很多东西了，就像下面这个： P: E → E + E (1) E → E * E (2) E → (E) (3) E → -E (4) E → id (4) 使用该表示方法的前提是文法本身没有错误（似乎是废话？）。我们做预先约定好的规定如下： CFG 的开始符号 S ，是第一个产生式的左部——这就把四元组的最后一项 S 定义出来了； N 是可以出现在产生式左边符号的集合——这就把四元组的第一项 N（非终结符） 定义出来了； T 是绝不出现在产生式左边的符号集合——这就把四元组第二项 P 定义出来了。 注意，是只在右面出现的。像下面这种情况： E -> ID ID -> ab 尽管上面的 ID 在第一行出现在了右边，到第二行却出现在左边，因此 ID 也是非终结符。在且仅在产生式右面的符号，才能叫作终结符。 因此，只要我们写出来 P ，整个四元组就都定义出来了——因为四元组中的其他三元都可以根据定义来从 P 中分类找出来 其实也可以写得更简单——就是用 | （或）符号来连接各个产生式，以省略多余的 E 比如： E → E+E |E*E |(E) |-E |id 或 E → E+E|E*E|(E)|-E|id 这种产生式表示也被称为“巴克斯范式”（BNF, Backus Naur Form），其中 → 用 ::= 表示。 这种书写方法中，每个右部的权利是相同的，因为当我们说 “ a 或 b ” 时，并没有同时表达出来 “ a 重要还是 b 重要 ”的意思，我们也不能简单地因为 a 在 b 的前面而推断 a 比 b 更重要。这里的“权利”与文法的二义性有关。 终结符与非终结符还可以用下面的不同写法进行区分： 大小写区分： E → id 用双引号区分：E → \"id\" E → E \"+\" E 用尖括号区分：E → \\ + \\ CFG，用推导，产生语言 推导，实际上就是得到 CFG 所定义的语言的过程。 回忆正规式——写正规式的时候，就已经有“产生”的含义在里面了 在正规式的定义中，我们可以说 a|b是一个正规式，它表示的正规集是：a表示的语言和b表示的语言取并集 ——注意看这句话——正规式表示正规集，正规集是两个语言的并集，那么也就是说正规式表示语言的集合。我们已经在定义正规式的时候把语言定义出来了！ 正规式定义的时候，正规集这个语言就已经随之定义完了；但是在定义 CFG 的时候，我们可没有说“CFG产生的语言”这类的话，也就是说在我们写下 CFG 时，这个语言并没有被随 CFG 定义出来。 因此，我们要单独考虑怎么定义语言——语言，可以由 CFG 通过推导产生，我们通过推导得到 CFG 所定义的语言。 通俗地讲，产生式产生语言的过程，就是从 S 开始，对产生式左部的非终结符反复地使用产生式：将产生式左部的非终结符替换为右部的文法序列（用 => 表示展开产生式），直到得到一个终结符序列。 利用产生式产生句子。左侧是产生式，产生式定义语法。右侧是根据左侧的规则进行的几步推导过程。右边这几行式子的每一行推导符号右侧的符号序列就叫做“文法符号序列”。 直接推导 推导，就是把非终结符按照产生式一步步换成终结符的过程。 利用产生式产生句子的过程中，将产生式 A → γ 的右部代替文法符号序列 αAβ 中的 A 得到 αγβ 的过程，称 αAβ 直接推导出 αγβ ，记作 αAβ => αγβ 若对于任意文法符号序列 α1, α2, ...αn，均有 α1=>α2=>...=>αn，则称此过程为零步或多步推导，记为 α1=*>αn，当 α1=αn 时称为零步推导。 若α1≠αn，即推导过程中至少使用一次产生式，则称此过程为 至少一步推导，记作 α1=+>αn 说白了。。根据产生式所描述的规则进行代入替换，这里分清楚两种箭头就行了：→描述推导可以使用的规则，=>描述推导的过程。 推导有自反性（对任意的 α，都有 α=*>α）和传递性（若 α=*>β， β=*>γ， 则 α=*>γ）。 推导，是一种二元关系 一个元素如果和它自己满足该二元关系，那么它就是自反的 即 aRa 由 CFG 产生语言 由 CFG G 产生的语言 L(G) 定义为： L(G) = {ω | S=+> ω and ω∈ T* } 其中： S=+>ω：开始符号 S 经过至少一步推导，能够推出 ω ω∈ T*：ω 是由终结符组成的一个串 上面这两条合在一起，就可以保证我们能基于这套规则来从开始符号推出词法分析器给我们的那个终结符串。基于此推出来的集合，就是语法规则所描述的语言。 该 L(G) 被称为 上下文无关语言（Context Free Language，CFL），ω 被称为句子。 若 S=+>α ，α∈(N∪T)*，则称 α 为 G 的一个句型 其中： α∈(N∪T)*：推导过程中的 α 时终结符和非终结符组成的一个串。 句型可含终结符、非终结符。而句子只能包含终结符，句子是句型的特例。 （句型，是句子的模型，有句子的结构和特征，是句子的半成品） 在推导的过程中，若每次直接推导均替换句型中最左边的非终结符，则称为最左推导。由最左推导产生的句型被称为左句型。 右句型与之对称，最右推导也被称为规范推导 例如：E => E+E => E+id // 规范推导 在？为啥从右往左叫规范？凭什么歧视左？ 其实这个和语法分析的方式有关。有两种语法分析方式，分别是最左推导的自上而下方式和最右推导的自下而上方式。前者虽然与人的思考方式类似，但其实际的语法分析能力是比较差的，因此实际应用中主要从下向上构造语法树。 下图是自下而上构造分析树，推导方式是自下而上。 总结一下这些奇奇怪怪的东西 推导，就是得到 CFG 所定义的语言的过程。语言是一个集合，集合中的任何一个元素都是一个句子。推导过程中得到的串叫做句型，句型可以包含终结符和非终结符。 语言，是以【从开始符号进行至少一步推导得到的】终结符串为元素的集合； 推导，是 CFG 推导得到语言的过程，CFG 中的核心就是产生式； 产生式，是用于描述非终结符替换规则的式子； 分析语法，需要构造语法分析树； “自上而下”、“自下而上” 都是语法分析的方式； var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记9：语法分析树、语法树、二义性的消除.html":{"url":"compile-prin/marscat笔记/编译原理笔记9：语法分析树、语法树、二义性的消除.html","title":"编译原理笔记9：语法分析树、语法树、二义性的消除","keywords":"","body":"编译原理笔记9：语法分析树、语法树、二义性的消除 语法分析树和语法树不是一种东西。习惯上，我们把前者叫做“具体语法树”，其能够体现推导的过程；后者叫做“抽象语法树”，其不体现过程，只关心最后的结果。 语法分析树 语法分析树是语言推导过程的图形化表示方法。这种表示方法反映了语言的实质以及语言的推导过程。 定义：对于 CFG G 的句型，分析树被定义为具有下述性质的一棵树： 根由开始符号所标记； 每个叶子由一个终结符、非终结符或 ε 标记； 每个内部节点都是非终结符； 若 A 是某节点的内部标记，且 X1、X2...Xn 是该节点从左到右的所有孩子的标记。则：A→X1X2...Xn 是一个产生式。若 A→ε，则标记为 A 的节点可以仅有一个标记为 ε 的孩子。 以 E => -E => -(E) => -(E+E) => -(id+E) => -(id+id) 为例 分析树与语言和文法的关系 每一直接推导（每个产生式），对应一仅有父子关系的子树，即产生式左部非终结符“长出”右部的孩子； 分析树的叶子，从左到右构成 CFG G 的一个句型（T、N两掺的串）。若叶子仅由终结符标记（+ 、- 、* 之类的运算符号也算是终结符），则构成一个句子。 推导，有最左推导和最右推导，这两种推导方式在推导过程中的分析树可能不同，但因最终得到的句子是相同的，所以最终的分析树是一样的。 分析树能反映句型的推导过程，也能反映句型的结构。然而实际上，我们往往不关心推导的过程，而只关心推导的结果。因此，我们要对分析树进行改造，得到语法树。语法树中全是终结符，没有非终结符。而且语法树中没有括号 语法树 定义： 对 CFG G 的句型，表达式的语法树被定义为具有下述性质的一棵树： 根与内部节点由表达式中的操作符标记； 叶子由表达式中的操作数标记； 用于改变运算优先级和结合性的括号，被隐含在语法树的结构中。 说白了，语法树这玩意，就一句话：叶子全是操作数，内部全是操作符，树里没有非终结符也不能有括号。 语法树要表达的东西，是操作符（运算）作用于操作数（运算对象） 举俩例子吧： 【例】： -(id+id) 的语法树： 【例】：-id+id 的语法树： 显然，我们从上面这两个语法树中，直接就能观察出来它们的运算顺序。 【例】：句型 if C then s1 else s2 if-then-else 是个终结符，其是一整个操作符。该操作符有三个操作数：条件 C、真分支 s1、假分支 s2 二义性及二义性的消除 二义性问题 二义性问题：一个句子可能对应多于一棵语法树。 【例】： 设文法 G： E → E+E | E*E | (E) | -E | id 则，句子 id+id*id、id+id+id 可能的分析树有： 在该例中，虽然 id+id+id 的 “+” 的结合性无论左右都不会影响结果。但万一，万一“+”的含义变成了“减法”，那么左结合和右结合就会引起很大的问题了。 我们在这里讲的“二义性”的“义”并非语义——我们现在在学习的内容是“语法分析器”，尚未到需要研究语言背后含义的阶段。 “语法”分析的任务，是确定 “E+E” 这么写是否合法； “语义”分析的任务，是确定 “+” 这个符号到底蕴含着什么信息，即，该怎么解释这个符号。 我们现在讲的“二义性”指的是一个句子对应多种分析树。 优先级、结合性：引起二义性的根本原因 二义性的体现，是文法对同一句子有不止一棵分析树。这种问题由【句子产生过程中的某些推导有多于一种选择】引起。悬空 else 问题就可以很好地体现这种【超过一种选择】带来的二义性问题，示例如下。 【悬空（dangling）else】 问题 看下面这么个例子。。 （其实，我感觉这个其实比较像是“说话大喘气”带来的理解歧义问题。。。）上面的产生式中并没体现出来该咋算分一块，所以两种完全不同的句子结构都是合法的。 二义性的消除 二义性问题是有救的，大概有以下这三种办法： 将二义文法改成非二义文法； 规定二义文法中符号的优先级和结合性； 改变语言的结构或书写方式。 这些办法的核心，其实都是将优先级和结合性说明白。 1. 改写二义文法为非二义文法 核心：把优先级和结合性说明白 既然要说明白，那就不能让一个非终结符可以直接在当次推导中能推出会带来优先级和结合性歧义的东西。（对分析树的一个内部节点，不会有出现在其下面的分支是相同的非终结符的情况。如果有得选，那就有得歧义了。没得选才能确定地一路走到黑） 改写为非二义文法的二义文法大概有下面这几个特点： 需要引入新的终结符，且新引入的非终结符，能够限制每一步推导都只有唯一的选择； 引入新的非终结符后，推到步骤会增多（分析树增高）； 越接近 S 的文法符号优先级越低（重要！！）； 对于 A → αAβ，若 A 在终结符左侧出现（即终结符在 β 中），则 A 产生式具有左结合性； 在语法树中，越在分析树底下的运算符号越先被计算（即，离开始符号越远的越先算）。 改写的关键步骤： 引入新的非终结符，增加一个子结构并提高一级优先级； 若要运算有左结合性，需要让递归非终结符在终结符左边。相对的，递归非终结符在右边则会让运算右结合。 【例】改写下面的二义文法为非二义文法。图右侧是要达成的优先级和结合性 改写的核心其实就两句话： 要引入新的优先级，就需要引入新的非终结符，且距离 S 越近的文法符号优先级越低； 递归非终结符在终结符左边，运算就左结合，反之亦。 所以能够得到非终结符与运算的对应关系（因为不同的运算有不同的优先级，我们想要引入多个优先级就要引入多个新的非终结符。这样每个非终结符就可以负责一个优先级的运算符号，也就是说新的非终结符是与运算有关系的了。因此这里搞出来了“对应关系”四个字）如下： 优先级由低到高分别是 +、*、-，而距离开始符号越近，优先级越低。因此在这里的排序也可以+*-顺序。每个符号对应一层的非终结符。根据所需要的结合性，则可确定是左递归还是右递归，以确定新的产生式长什么样子 【例】：规定优先级和结合性，写出改写的非二义文法 让我们来搞【悬空 else 】罢！ 我们已经掌握了一种叫做【改写】的工具，能让我们消除二义性。接下来我们就要用这个工具来尝试搞搞悬空 else 问题！ 悬空 else 问题出现的原因是 then 数量多于 else，让 else 有多个可以结合的 then。在二义文法中，由于选哪两个 then、else 配对都可以，故会引起出现二义的情况。在这里，我们规定 else 右结合，即与左边最靠近的 then 结合。 为改写此文法，可以将 S 分为完全匹配（MS）和不完全匹配（UMS）两类。在 MS 中体现 then、else 个数相等即匹配且右结合；在UMS 中 then、else 不匹配，体现 else 右结合。 例：用改写后的文法写一个条件语句 经过检查，无法再根据文法写出其他分析树，故已经消除了二义性 2. 规定优先级和结合性 虽然二义文法会导致二义性，但是其并非一无是处。其有两个显著的优点： 比非二义文法容易理解； 分析效率高（分析树高度低，直接推导的步骤少）。 在 Yacc 中，我们可以直接指定优先级、结合性而无需自己重写文法。 %left '+' %left '*' %right '-' left 表示左结合，right 表示右结合。越往下的算符优先级越高。 嗯就这么简单。。。 3. 修改语言的语法 我们其实可以把语言本身定义成没有优先级和结合性的。。然后所有的优先、结合都交由括号进行控制，哪个先算就加括号。把一个过程的结束用明确的标志标记出来。 比如在 Ada 中： if x0 then x:= 5; end if; else x:= -5; end if; 在 Pascal 中，给表达式加括号： (a+b)>(c*d) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记10：语言与文法、正规式转CFG、正规式和CFG的关系.html":{"url":"compile-prin/marscat笔记/编译原理笔记10：语言与文法、正规式转CFG、正规式和CFG的关系.html","title":"编译原理笔记10：语言与文法、正规式转CFG、正规式和CFG的关系","keywords":"","body":"编译原理笔记10：语言与文法，正规式转CFG，正规式和CFG，文法、语言与自动机 对语言进行形式化描述的规则叫文法。 词法规则、语法规则都以形式化的方法对语言进行描述，这样的规则就叫文法。在使用 lex 的时候，我们就可以使用文法来简单地定义和修改语言。 前几篇笔记中我们比较细致地研究了正规式，当时我们用正规式来描述词法规则，然后根据正规式构造可以识别由该正规式表示的语言的自动机。 但其实，CFG 也是可以描述词法的。（但为什么不这么做呢？） 正规式，和 CFG 正规式所描述的语言结构都可以用 CFG 描述，反之不一定。 正规式和 CFG 是有关系的！NFA 是可以转化成 CFG 的！！一个 NFA 的状态和状态转移关系就对应一个产生式！！惊不惊喜？意不意外？？？至于为啥可以咱们暂且不论，先从这里往下看，后面时机成熟，自会解释。（先咕咕咕） 正规式到 CFG 的转换： 构造正规式的 NFA； 若 0 为初态，则 A0 为开始符号； 对于 move(i, a) = j，引入产生式 Ai → aAj； 【从 i 状态经过标记为 a 的边转移到 j 状态。对于这样的状态转移关系，我们可以为其生成对应的产生式 Ai → aAj 】 NFA 中的每个边，即每个状态转移都会生成一个对应的产生式。我们在这里引入 Ai → aAj（这里的 a 是指经过的边），这样一来，我们就用这种方法将 NFA 中的状态以及状态转移关系变成了 CFG 中的产生式。 对于 move(i, ε) = j，引入产生式 Ai → Aj； 为空转移生成与之对应的产生式。 若 i 是终态，则引入产生式 Ai → ε（终态，对应的是空产生式）。 NFA 中有状态和状态间的转移，我们就可以把这些变成一个 CFG 【例】以正规式 r = ( a|b )*abb 的 NFA 构造 CFG。 如果没有最后的 ε，那么无论怎么推导，在推导的下一步总会引入一个新的非终结符，永远得不到一个我们想要的句子。 通过这种方式转化出来的 CFG 也是一种“正规文法”（后续会讲到） 另外，我们也可以使用经验（脑补）的方法来将正规式转化成 CFG。对于上面的正规式 r，我们不难（？）写出： A → HT H → ε | Ha | Hb T → abb 过程： 通过观察，我们发现正规式 (a|b)*abb 是可以分为明显的两部分的，即a或b的星闭包连接上abb。第一部分就是星闭包，第二部分就是abb。因此，我们在构造 CFG 的时候，也就可以一上来就把开始符号拆成两部分，即上面第一行的 H 和 T 我们用前面的非终结符 H 来生成正规式中前半部分的星闭包。a或b的星闭包，就是由a或b构成的长度>=0的一个ab串，于是我们就可以通过 H 本身不限次引入 a、b 来构造星闭包，具体就是第二行的产生式。产生式 H->ε 的作用有二，一是为了满足只有空串的情况，因为星闭包可以为空；二是用来结束 H 的产生式，只有有了 ε，我们才能够结束对 H 的构造，否则这个推导会一路无限递归下去。。。 T 就是给 abb 准备的 万一，如果 H 是正闭包而不是星闭包，那么就可以改成：H→a|b|Ha|Hb 正规式和 CFG 的关系 我们都知道：如果 NFA 能够接受一个串，那就说明在这个 NFA 内部一定存在一条从初态到终态的路径，路径上的链接就是这个串本身。 而，从上面的转化规则和例子，我们可以确定：这样的一个串一定对应CFG里面的一个推导。 也就是说，NFA 中的一个路径一定对应着 CFG 中的一个推导。反过来讲，CFG 中任意一个推导也都对应着 NFA 中的一个路径。 因此，正规式与 CFG 之间是等价的！！ 任意一个正规式所描述的语言，都可用 CFG 来描述。也就是说对任意一个正规式，我们都可以为他构造出来其相应的、和它描述的语言相同的集合的 CFG。 但反过来，就不一定了——并不是所有用 CFG 描述的语言都可以用正规式来描述 既然凡是正规式能描述的，都能用CFG描述，反之则不行。这就说明 CFG 的语言描述能力更强。 可，为什么还用正规式，而非 CFG 来描述词法呢？？？ 为毛不用 CFG 描述词法规则 原因很简洁：对人好，对机器也好（它好我也好）。 对人好：正规式更直观简单，人容易理解。而正规式描述词法恰巧已经够用了（词法无非标识符、关键字、字面量之类，这些都是线性结构，使用正规式就能充分描述）； 对机器好：DFA 构造起来比用于 CFG 分析的下推自动机简单，效率更高。且使用两种不同方式来表示词法和语法，便于对两者进行区分，便于编译器前端的模块划分。 贯穿词法、语法分析始终的思想 语言的描述和识别，是表示一个语言的两个侧面，二者缺一不可； 一般而言，正规式适用于描述线性结构（标识符、关键字、注释等）； CFG 适用于描述具有嵌套（层次）性质的非线性结构，比如不同结构的句子 if-then-else、while-do 等； 用正规式和 CFG 描述的语言，对应的识别方法（自动机）不同。 上下文有关文法 CSG CFG 很棒，但 CFG 文法本身，无法描述上下文有关的结构。 不能用 CFG 描述的语言： 上述的 L1、L2、L3 均是上下文有关的。 与上述 CSL 类似的 CFL 文法、语言与自动机 0型文法： 若文法 G=(N, T, P, S) 的每个产生式 α→β 中，均有 α∈(N∪T)*，且至少有一个非终结符，β∈(N∪T)* , 则称 0 型文法。 产生式两侧的表达式需要含终结符，且是 N、T 元素组成的串。 1型文法： 在 0 型文法的基础上，要求：对 G 的任何产生式 α→β（S → ε 除外），满足|α|≤|β|。 其实就是在 0 型的要求之上，要求产生式左侧表达式必须比右侧的短，也就是说这种语言不会越推越短，一定是越推越长的（毕竟总是要把产生式往产生式里面代入，如果被代入的东西变长了，那么一定就会随着推导的进行整个串都越来越长），而且可以一次性换掉带有终结符的非终结符序列。 2型文法： 在 0 型文法的基础上，要求：G 的任何产生式都要形如 A→β，有 A∈N，β∈(N∪T)* 。 这其实就是在说，产生式左侧必须是一个单独的非终结符，右侧还是和原来一样随便即可。 3型文法： 在 0 型文法的基础上，要求：G 的任何产生式都要形如【 A→ a 或 A → aB （或 A→Ba）】，其中A、B∈N，a∈T 注意啊，这里的【 A→ a 或 A → aB （或 A→Ba）】是指在 “A → a” 或 “ A → aB （或 A→Ba）”这俩里面二选一，而不是“A→ a”、“A → aB”、“A→Ba”之间三选一。意思是说，一个串如果想要填字母就只能往一边续。如果用 A → aB，那就是向右侧延伸，越续越长。选 A→Ba 那就是向左侧延伸，越续越长。 任何一个1型文法，都是一个0型文法 任何一个2型文法，都是一个1型文法，都是一个0型文法 任何一个3型文法，都是一个2型文法，都是一个1型文法，都是一个0型文法。 所有3型文法的集合，是2型文法集合的子集 2型文法的集合，是1型文法集合的子集 1型文法的集合，是0型文法集合的子集 为什么， CSG 叫 CSG？ CFG，左边只有一个非终结符。 CSG 因为左边可以有终结符（即，可以是一个文法符号序列），所以在对非终结符进行展开时，我们需要考虑这个非终结符的左边是什么、右边是什么，也就是说我们要考虑这个非终结符的（已经存在了的）上下文了，因此，叫做上下文有关。 而 CFG 的非终结符完全可以在任何地方随便展开，只需要考虑他自己单独一个非终结符就行了，所以叫上下文无关！ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记11：自上而下语法分析（1）基础概念、左递归和公共左因子处理、递归下降分析（咕咕咕）.html":{"url":"compile-prin/marscat笔记/编译原理笔记11：自上而下语法分析（1）基础概念、左递归和公共左因子处理、递归下降分析（咕咕咕）.html","title":"编译原理笔记11：自上而下语法分析（1）基础概念、左递归和公共左因子处理、递归下降分析（咕咕咕）","keywords":"","body":"编译原理笔记11：自上而下语法分析（1）基础概念、左递归和公共左因子处理、递归下降分析（咕咕咕） 词法分析，是把源程序分析成记号流，识别其中的单词。 语法分析，是要分析词法分析产生的记号流中的语法结构是否正确——对词法分析得到的记号流进行分析，以确认其是不是一个可以由我们定义好的文法推出来的句子。如果语法结构正确，语法分析器最终要为输入序列构造出一棵语法树。 在推导的过程中，我们其实会同时保有两个序列：一个是词法分析器给的输入序列，另一个则是我们自己推导的序列。如果最后两个序列都能够一一匹配上，那么就说明输入序列是符合语法规则的，我们构造出的就是合法的语法树。 语法分析有两种方式，分别是自上而下分析和自下而上的分析。我们在此仅对前者进行简单的学习，重点都放在后者上（各种略……精力实在不够，写不动了）。 自上而下分析有两种方式：【递归下降分析】和【使用预测分析器的预测分析】。无论是哪种，都对文法有一些要求——文法不能有二义性，产生式不能有左递归，也不能有公共左因子。 自上而下分析的一般方法 用推导的方法分析输入序列 词法分析器给我们的记号流，在这里被称为【输入序列】。我们使用边推导边匹配的方法对它进行分析，该方法描述如下： 对输入序列 ω，从 S 开始进行最左推导，直到得到一个合法句子或非法结构。（因为对输入序列的扫描是从左到右的，所以我们的推导也要从左到右进行。在推导的过程中，也总是尝试推导出最左端的终结符，以将其和输入序列中的最左边的记号进行匹配） 从左到右扫描输入序列，自上而下构造这个序列的分析树； 通过推导分析输入序列的过程是一个反复试探的过程，这个过程中会不断尝试使用不同的产生式，尝试让推导与输入序列相匹配。 用推导分析输入序列的过程中，会由于文法产生式的某些“特征”而遇到如下的两个问题，导致推导过程的回溯。 左递归问题及其消除（消除左递归） 左递归产生式形如： A → Aa 左递归会导致分析陷入死循环：我们可以总用 Aa 来替换掉上一层的 Aa 中的 A，无法停下来。想要避免死循环的出现，我们就需要消除左递归。 消除直接左递归 我们通过引入新的非终结符来消除左递归。 给出一般的左递归产生式如下图左侧，要消除该产生式的左递归，只需要将其改写为下图右侧的两个产生式即可。下图产生式中，α1 非空， βj 均不以 A 开始（即不包含左递归） 在修改之前的文法中，总是需要靠这些 β 来终止对 A 的推导，即通过 β 出现在最左端的方式来停止递归。所以现在推出来的序列，一定也要是以 β 们开头的序列，β后面链接新的终结符。由A‘ 推出后面可以重复出现的 α 们。最后再为新增的非终结符加一个 ε 推导的选项，用于最终停止递归推导 下图展示一个简单的左递归产生式改写，及改写产生式在语法分析树上的体现 消除间接左递归 对于一般情况的核心步骤： 对各个在产生式左部的非终结符进行排序：A1, A2 ... An（【合理排序】，自己看着办，排序方法不唯一） 用 Aj → δ1 | δ2 |... | δk 的右部替换 Ai → Ajγ 中的 Aj（也就是将一个非终结符在另一个产生式的非终结符中展开），得到 Ai → δ1γ | δ2γ |...| δkγ 例：消除下面文法中的左递归 S → Aa | b A → Ac | Sd | ε 这里存在两个左递归：A的直接左递归和 S 的间接左递归 消除这样的左递归分两步走： 要把不含有直接左递归的非终结符排在前面，含有直接左递归的N排在后面。因此这里以 S、A 顺序来处理。先把 S 展开到 A 里面，这么一搞，以后就没办法推回来 S 了。这样我们就只留下了一个A A → Ac | Aad | bd | ε 我们把S干掉了，也就已经消除了 S 的间接左递归，接下来腾出手单独处理 A 。按照标准的直接左递归消除方式来处理现在的情况即可，和之前的抽象题型一样了 S → Aa | b A → bdA' | A' A' → cA' | adA' | ε 左递归消除算法 暂略，随缘补 公共左因子问题及其消除（提取左因子） 存在公共左因子的产生式形如：A → αβ1|αβ2 公共左因子会造成不必要的回溯——因为通过推导来分析输入序列是一个反复试探的过程，既然是试探那么就会出现试错了的情况，而显然，公共左因子的存在，就为“试错了”的出现创造了条件。 回溯会出现严重的浪费，所以我们其实可以像解决词法分析的回溯问题一样（有限自动机的确定化），通过将推导“确定化”来避免回溯的产生。具体的方式就是提取左因子。 提取左因子 重复以下过程，直到所有 A 产生式中都不再含有公共前缀： 重排 A 产生式：A → αβ1 | αβ2 |... | αβn| γ 用 A → αA' | γ 和 A' → β1 | β2 | ... | βn 取代原 A 的产生式 对于同时存在左递归和公共左因子的文法，先消除左递归。有时曾经存在的公共左因子会随着左递归的消失而消失 例：消除下面文法（悬空 else 文法）的公共左因子 S → iCtS | iCtSeS | a C → b S → iCtSS' | a S' → eS | ε C → b 递归下降分析 递归下降分析是【确定的自上而下分析】的一种实现方式，能进行自上而下分析的文法必须是非二义、无左递归和公共左因子的。但满足这三个条件的文法也未必能进行自上而下分析。这种分析方法适用范围较小。 递归下降分析是一个【边推导边匹配】的过程，根据产生式写出子程序，通过子程序之间的调用来实现对非终结符的推导——文法产生式的每个终结符都对应着一个子程序，产生式右侧的非终结符对应子程序的调用，遇到右侧的终结符，则将该终结符与输入符号序列的匹配。 具体暂略，随缘补，大概率不补 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记12：自上而下语法分析（2）非递归预测分析器、FIRST & FOLLOW 集合计算.html":{"url":"compile-prin/marscat笔记/编译原理笔记12：自上而下语法分析（2）非递归预测分析器、FIRST & FOLLOW 集合计算.html","title":"编译原理笔记12：自上而下语法分析（2）非递归预测分析器、FIRST & FOLLOW 集合计算","keywords":"","body":"编译原理笔记12：自上而下语法分析（2）非递归预测分析器、FIRST & FOLLOW 集合计算 使用预测分析器的自上而下分析 使用预测分析器进行的自上而下分析是非递归的。预测分析器模型其实是一种 PDA（下推自动机，Pushdown Definite Automata），其结构如下图所示 上图中的“有限状态转移控制”类似于词法分析中的自动机。下推自动机在单纯的自动机旁增加了一个下推栈。将该模型进一步具体化，即得到预测分析器模型，如下图所示。 这里的“驱动器”，是一个能够控制读写头读取输入记号流中记号的算法，该算法要综合读到的记号、下推栈情况和预测分析表的内容，来修改符号栈和控制输出。 PDA 可以识别形如 ：ωcωr 的串，这样的串是 DFA 无法识别的，这类串也无法使用正规式进行描述。（ps. ωr 的意思是终结符序列 ω 的反转形式，比如 ababcbaba）。而对于形如 CSG 那种的 ωcω 串，则 PDA 也无法进行识别。 预测分析器通过【格局与格局的变换】进行分析。 格局 格局是一个三元组 (栈顶元素^top，剩余输入^ip，改变格局的动作)，改变格局的动作通过查表确定，具体动作包括：展开非终结符、匹配终结符、报告分析成功（^top=^ip=#）、报告出错（遇到上述情况之外的其他情况，要调用错误恢复例程） 我们可以将预测分析器看作一个逐步运行（Step）的机器，每一个 step 都会让预测分析器到达一个新的 格局 ，直到到达接收格局为止（或者到达出错格局，即发现语法错误。比如推出来的终结符和读写头读到的终结符不一样，或者栈顶和读写头当前指向的终结符所对应的预测分析表元素为空） 使用预测分析器进行分析的实例 预测分析器需要借助预测分析表来构造语法分析树。 在进行语法分析时，预测分析器根据符号栈（下推栈）栈顶元素和驱动器读写头指向的记号流中的记号来查询预测分析表，根据预测分析表中对应项的情况来决定下一步的操作。预测分析表形式如下： 预测分析表的行首是非终结符，列首是终结符。 当栈顶是非终结符时，展开：需要根据预测分析表查到候选项，然后使用该候选项来展开栈顶的非终结符——弹出栈顶非终结符，将表中的对应项逆序压入到下推栈中（注意顺序，产生式右部是反着压进去的，因为总要保持从左到右推导）。 当栈顶时终结符时，匹配：若此时栈顶的终结符与驱动器读写头读到的终结符相同，则将该栈顶元素弹出，同时读写头向后移动一个记号。 对于消除了左递归和公共左因子的如下 CFG，我们可以根据其来构造一个预测分析表（具体构造方式留到后面再说） L → E;L|ε E → TE' E' → +TE'|-TE'|ε T → FT' T' → *FT'|/FT'|mod FT'|ε F → (E)|id|num 我们根据如下算法，来进行非递归预测分析 其实，就是重复进行这样的操作：根据读写头指向的终结符、栈顶元素查预测分析表，不断把表中查到的元素压入栈顶。因为是从开始符号开始推导的，所以栈中会出现【根据预测分析表查到新的非终结符入栈】的情况。如果推导时栈顶是非终结符，则读写头不需要移动，一直指向之前停下的位置。但随着推导的进行，非终结符终究会推出终结符（这个终结符也要和前面非终结符一样，被压入栈），如果这个推导出来的、当前正好在下推栈栈顶的终结符和读写头指向的符号相同，那么就是【匹配上了】 下图说明了【栈顶是非终结符时，进行展开】的过程，执行非递归预测算法插图中的第二个红色虚线框内的代码： 下图同时说明了【栈顶是非终结符时，进行展开】和【栈顶是终结符时，进行匹配】的过程。对于后一个过程，执行非递归预测算法插图中的第一个红色虚线框内的代码： FIRST、FOLLOW 集合的构造 预测分析表，其实是一个【为我们指明推导的方向】的工具。那么如何构造这个工具呢？ 构造过程分为两步：1. 根据文法给出的产生式构造 FIRST、FOLLOW 集合，2. 根据这两个集合来构造预测分析表。 因此，FIRST、FOLLOW 集合的构造是这里的重中之重。 我们根据下面的块中的产生式来学习这两个集合 L → E;L | ε E → TE' E' → +TE' | -TE' | ε T → FT' T' → *FT' | /FT' | mod FT' | ε F → (E) | id | num FIRST 集合 文法符号序列 α 的 FIRST 集合为： FIRST(α) = { a | α=*> a...，a ∈ T }，若 α=*>ε ，则 ε ∈ FIRST(α) 说白了，FIRST(α) 就是 α 能推出来的所有串（aka. 文法符号序列）中的第一个终结符的集合。如果从某个非终结符开始，一步推不到终结符，那就多推几次。如果直接推出来个 ε，就把 ε 也加入当前 FIRST 集合。 我们以对上面写的产生式求 FIRST 集合为例，来了解怎么求 FIRST 集合。 求 FIRST 集合的过程要顺着我们的一堆产生式从下向上进行，也就是先求 FIRST(F)，最后求 FIRST(L)。对于产生式 F → (E)|id|num，容易看出， F 经过一步推导能推出的所有串的第一个终结符有：(、id、num，因此 FIRST(F) = { (, id, num }； 对于产生式 T' → *FT'|/FT'|mod FT'|ε，T' 经过一步推导能推出的所有串的第一个终结符有：*、/、mod。而又因为 T' 能够直接一步推导出 ε，所以 ε 也要加入到 FIRST(T') 中，即 FIRST(T') = {*, /, mod, ε}； 对产生式 T → FT'，T 没有一步推导就能得到的终结符，所以要继续推导，再推导一步会得到：T=>FT'=>(E)T' 或 T=>FT'=>idT' 或 T=>FT'=>numT'，由此我们可以看到，T 经过两步推导能够推导出的第一个终结符有：(、id、num，（由于 F 推不出 ε，也就是说 F 无法被穿透，因此关于从 T 经过推导推出的第一个终结符就都和 F 的终结符相同了），因此 FIRST(T) = FIRST(F) = { (, id, num }； 对于产生式 E' → +TE'|-TE'|ε ，与上面的 2 同理，可得 FIRST(E') = { +, -, ε }； 对于产生式 E → TE'，与上面的 3 同理，可得 FIRST(E) = FIRST(T) = FIRST(F) = { (, id, num } 对于产生式 L → E;L|ε，要结合上面的 3 和 2 一起理解。首先该产生式可以经过多步推导后得到终结符，这个和 3 同理。然后，该产生式本身也能推出 ε，这与 2 同理。最终可得：FIRST(T) = { ε, (, id, num } 即，最终可得： FIRST(F/T/E) = { ( id num } FIRST(T’) = { * / mod ε } FIRST(E’) = { + - ε } FIRST(L) = { ε ( id num } FOLLOW 集合 非终结符 A 的 FOLLOW 集合如下： FOLLOW(A) = { a | S=*> ...Aa...，a∈T }，若 A 是某句型的最右符号，则 #∈FOLLOW(A) 说白了，就是从开始符号可以导出的所有含 A 的文法符号序列中 A 之后的终结符。 举个例子的话大概是：FOLLOW(A) 是终结符的集合，从开始符号开始，经过多步推导得到的句型中有【Aa】，则FOLLOW集合中的元素就是这些 a。想要真正理解 FOLLOW 集合，建议尝试在脑内画一个下推栈进行推导（如果脑补不出来，那耐心点一步步画在纸上也是不错的选择），这样会简单许多。 我们以对上面写的产生式求 FOLLOW 集合为例，来了解怎么求 FOLLOW 集合。 求 FOLLOW 集合的过程要顺着产生式从上往下进行，也就是先求 FOLLOW(L)，最后求 FOLLOW(F)。首先求第一个产生式 L → E;L|ε 左部的非终结符 L 的 FOLLOW 集合 FOLLOW(L)。 因为我们想要寻找的是在经过推导后跟在 L 后面的终结符，因此我们要首先扫一眼全部的产生式，看看 L 都在哪些产生式中出现过以获取线索。很不幸，只在第一个产生式中出现过……如果选择 E;L 进行推导将导致 L 的递归——也就是说若只用这个产生式进行推导，无论怎么推都永远推不出一个紧随 L （除了#之外）的终结符，最终还是要面对只有 L 的问题。而若选择 ε 展开 L 则会导致 L 的穿透，暴露出文法的结束符号 # ，因此 FOLLOW(L) = {#}； 再来看第二个产生式 E → TE'，这一步我们求该产生式左部的非终结符 E 的 FOLLOW 集合 FOLLOW(E)。 因为我们想要寻找的是在经过推导后跟在 E 后面的终结符，因此我们先来整体看一下所有的产生式。可以发现非终结符 E 在第一行的产生式 L → E;L|ε 和最后一行的产生式 F → (E)|id|num 中都有出现。产生式 L → E;L|ε 说明，从开始符号 L 开始，经过一步推导得到 E;L ，即 L=*>...E;...因此我们要将 ; 加入到 FOLLOW(E) 中 。此外，我们还可以发现在最后一个产生式 F → (E)|id|num 中，E 后面接上了终结符 )，这说明，从开始符号 L 开始，经过多步推导，可以出现某一刻将 F 用 (E) 展开的情况——即：L=*>...(E)...，因此我们要将 ) 加入到FOLLOW(E) 中。除了这两个产生式之外，再也没有其他右部包含 E 的产生式，也就是说我们找完了 E 后面紧跟终结符的所有情况，故得到：FOLLOW(E) = { ;, ) }； 再看第三个产生式 E' → +TE'|-TE'|ε ，这一步求 FOLLOW(E')。 经过观察，我们发现除了这个产生式本身，只有第二行的 E → TE' 中出现了 E' 。通过观察这两个产生式，我们可以发现：下推栈中的 E' 只有一个来源，就是被使用 E → TE' 展开 E 而来。那也就是说，之前在下推栈中【位于 E 下面的非终结符】将被 E‘ “继承“ 因此， FOLLOW(E') = FOLLOW(E) = { ;, ) }； 下面来看第四个产生式 T → FT' ，这一步求 FOLLOW(T)。 我们发现 T 还出现在第二个产生式 E → TE' 中，因此要将 FIRST(E') 加入到 FOLLOW(T) 中。而又因为 E' 可穿透，因此也要考虑 E' 穿透的情况，故要将 FOLLOW(E) 也加入到 FOLLOW(T) 中。另外，因为 FOLLOW 集合中不能包含 ε，故 ε 不能被加入到 FOLLOW(T) 中。最后，FOLLOW(T) = { +, -, ;, ) } 第五个产生式 T' → *FT'|/FT'|mod FT'|ε ，这一步求 FOLLOW(T')。 与上面的 3 同理，FOLLOW(T) 被 FOLLOW(T') ”继承“，得到 FOLLOW(T') = FOLLOW(T) = {+, -, ;, ) } 第六个产生式 F → (E)|id|num ，这一步求 FOLLOW(F)。 由产生式 T' → *FT'|/FT'|mod FT'|ε 可知，FIRST(T') 应被加入 FOLLOW(F)。而 T' 可穿透，故 FOLLOW(T') 也应被加入 FOLLOW(F)。因此，FOLLOW(F) = { *, /, mod, +, -, ;, ) } 即，最终可得： FOLLOW(L) = { # } FOLLOW(E/E’) = { ) ; } FOLLOW(T/T’) = { + - ; ) } FOLLOW(F) = { + - * / mod ) ; } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记13：自上而下语法分析（3）构造预测分析表.html":{"url":"compile-prin/marscat笔记/编译原理笔记13：自上而下语法分析（3）构造预测分析表.html","title":"编译原理笔记13：自上而下语法分析（3）构造预测分析表","keywords":"","body":"编译原理笔记13：自上而下语法分析（3）构造预测分析表、LL(1) 文法 构造预测分析表 预测分析表的作用，是为推导的进行指明方向——我们用当前下推栈栈顶和读写头所指向的符号的组合（即当前的状态），去查询预测分析表，以确定推导的下一步该向着何种方向前进。 推导应该前进的方向，由 FIRST、FOLLOW 集合说明——这两个集合能够说明，我们可以通过怎样的方式来一步步向着终结符靠近。 不懂也能用的构造步骤 预测分析表构造的步骤如下，建议按照例子实操一遍。实在想不通，背下来步骤应该也可以把表构造出来。 看待填行的行首非终结符 A 找到左部是上面看到的这个非终结符 A 的产生式，根据产生式右部的不同，按以下三种情况处理： 如果产生式是以非终结符 B 打头的序列 α ，那么找到 FIRST(B)，将 FIRST(B) 集合中每个元素所在列、非终结符 A 所在行确定的位置填写上序列 α 如果产生式是以终结符 a 打头的序列 β ，那么直接去找终结符 a 所在列，并将 β 填入 A 行 a 列的位置中 如果产生式是 ε，则找到 FOLLOW(A) ，将 FOLLOW(A) 集合中每个元素所在列、非终结符 A 所在行确定的位置填写上 ε 概括来说，就是：根据产生式左部的非终结符确定本次要构造的分析表行。根据 FIRST、FOLLOW 集合，将产生式右部填入分析表，以此确定每行的内容。比如对于产生式 L → E;L|ε，我们需要把产生出来的右部 E;L 和 ε 填入到分析表 L 行的某些位置中。 实例如下： FIRST、FOLLOW 和分析表的原理？ FIRST、FOLLOW 集合都能够说明一些东西，比如， FIRST(L) 集合告诉我们： 如果此时栈顶是 L ，而读写头读到了 id，那么我们应该用 E;L 来进行展开，因为这样可以让推导过程向着【把栈顶元素变为id 】的方向前进。这是因为从 E 开始经过数步推导后，E 能够最终展开为 id 而完成匹配 如果此时栈顶是 L ，而读写头读到了 num ，那么我们应该用 E;L 来进行展开，因为这样可以让推导过程向着【把栈顶元素变为 num】的方向前进。这是因为从 E 开始经过数步推导后，E 能够最终展开为 num 而完成匹配 如果此时栈顶是 L ，而读写头读到了 ( ，那么我们应该用 E;L 来进行展开，因为这样可以让推导过程向着【把栈顶元素变为 (】的方向前进。这是因为从 E 开始经过数步推导后，E 能够最终展开为 ( 而完成匹配 而当产生式右部是 ε 时，根据该产生式左部的非终结符所对应的 FOLLOW 集合来确定这个 ε 该填到哪里——也就是说，仅当某个非终结符的产生式右部为 ε 时，我们才需要考虑 FOLLOW 集合 如果此时栈顶是 T'，而读写头读到了 + ，那么……嗯，T' 可没有展开为 + 的产生式啊，但 T' 可以被穿透，其 FOLLOW 集合 FOLLOW(T') 是包含 + 的； 同理，如果此时栈顶是 T'，而读写头读到了 - ，也可以通过选择将 T' 以 ε 展开而穿透的方式来向着推出 - 的方向前进。 LL(1) 文法 LL(1)，第一个 L ，代表从左到右扫描输入序列，第二个 L 代表推导的过程是最左推导。1 则代表只有一个读写头（也就是每次都只向前看一个终结符） 该文法的分析表的每个格子中只能有一个产生式的右部。该文法必须是非二义的，文法的产生式不能包含公共左因子和左递归。 LL(1) 文法使用范围有限，实际主要使用 LR(1) 文法。LR(1) 文法是 LL(1) 文法的真超集 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记14：自下而上语法分析（1）短语、句柄，规约，移进规约分析器的工作模式.html":{"url":"compile-prin/marscat笔记/编译原理笔记14：自下而上语法分析（1）短语、句柄，规约，移进规约分析器的工作模式.html","title":"编译原理笔记14：自下而上语法分析（1）短语、句柄，规约，移进规约分析器的工作模式","keywords":"","body":"编译原理笔记14：自下而上语法分析（1）短语、句柄，规约，移进规约分析器的工作模式 基本方法 从句子 ω 开始，从左到右扫描 ω，反复用产生式的左部替换产生式的右部、谋求对 ω 的匹配，最终得到文法的开始符号（或，发现错误）（也就是从下往上搞出个树，最后推到根也就是开始符号了） 在分析的过程中，每一步都总是尝试在句型中寻找一个能够被替换为产生式左部的子串。就这样一步步向上去替换，最终变成一个开始符号。 而，由于我们对记号流的扫描是从左到右的，故我们【尝试寻找句型中能够被替换为产生式左部的子串，并不断进行替换】的过程也是从左到右的。这样从记号到开始符号一步进行自下而上分析的逆过程其实就是一个最右推导！ 推导的逆过程，就叫做【规约】。最右推导的逆过程，就是最左规约。 短语、句柄，规范规约，剪句柄 最右推导叫做【规范推导】，因此作为其逆过程的最左规约，也就是【规范规约】了 短语、直接短语和句柄 设 αβδ 是文法 G 的一个句型，若存在 S =*> αAδ ， A =+> β，则称 β 是句型 αβδ 相对于 A 的【短语】。若 A→β ，则称 β 是句型 αβδ 相对于产生式 A→β 的【直接短语】。一个句型的最左直接短语被称为【句柄】。 句型，是一个完整的结构，短语则是句型中针对某非终结符的局部。因此，开始符号 S 是句型而不是短语。 短语形成的要素： S 可推导出 A，即 S=*> αAδ ； 从 A 开始经过至少一次推导推出 β，即 A=+> β。 我个人认为（俺寻思）：进行规约的一大关键点，是怎么在一堆本质上是字符串的符号流中，试图搞明白 “这到底哪几个连在一块的字符算一个符号啊？这到底几个符号连起来能和哪个产生式的右部匹配上啊？” 的问题。而这里的【短语】、【直接短语】、【句柄】概念，其实就是描述产生式右部的组合及边界的方案——回想自然语言中的 “短语”，自然语言中的短语是指由至少两个单词构成的、有序组合起来共同表达某一个含义的有序单词序列——只有特定的单词以特定的顺序组成序列才能被称为一个短语。那么语法分析中的短语也是一样的：语法分析中的短语是指由至少数个终结符或(和)非终结符构成的、有序组合起来的符号序列，这个序列就是某个产生式的右部，也就可以在规约时被规约为一个产生式的左部。 反映在上面定义的例子中，就是： β 是句型 αβδ 相对于 A 的【短语】，那么 αβδ 就可以经过至少一步规约后规约为 αAδ 。而 αAδ 则能够在经过零或多步规约后，最终规约为开始符号 S； β 是句型 αβδ 相对于产生式 A→β 的【直接短语】，那么 αβδ 就可以在经过一步规约后成为 αAδ ； 短语，不一定是包含终结符的序列，也可以是单个的非终结符。在整个规约的过程中，句柄会不断变化：毕竟，根据定义，短语只是【从开始符号 S 可以导出（经过零或多步推导，不导也行。。）的非终结符 A 在经过至少一步推导后得出的句型】。那么在下面这个例子中，从开始符号 S 一定是可以经过推导得到非终结符 T2 的，T2 也能在经过一步推导后展开为 F1。那么，F1 就是 T2 的短语（而且是直接短语，而且是最左直接短语，那么这里的 F1 就是 T2 的句柄了） 短语：以非终结符为根子树中所有从左到右的叶子 直接短语：只有父子关系的树中所有从左到右排列的叶子（树高为2） 句柄：最左边父子关系树中所有从左到右排列的叶子（句柄是唯一的） 规范规约（最左规约） 若 α 是文法 G 的句子且满足下列条件，则称序列 αn, αn-1, ..., α0 是一个最左规约： αn = α α0 = S（ G 的开始符号） 对任何 i(0 例： 文法：(1)S→aABe (2)A→b (3)A→Abc (4)B→d，对句子 abbcde 的最左规约是： abbcde 上面这个过程，从左往右看是最左规约（称为规范规约），从右往左看就是最右推导了 其实，上面的过程是非常简略的，这里有一些关键的细节需要到后面才能逐渐搞明白。比如，第二步到第三步规约的时候，为什么没有把 aAbcde 规约为 aAAcde？（这是因为如果这样规约就无法继续规约下去了）解决这个问题其实就要用到我们前面博客中说过的 FIRST、FOLLOW 集合以及下推栈。 移进-规约 规约，是用产生式左部的非终结符替换序列中和产生式右部相同的子串的过程。因为规约时对输入序列进行的扫描是从左到右的，所以在规约的过程中每次找的都是序列中的最左直接短语（即句柄）进行规约。 在这个规约的过程中，语法分析程序要做的，就是对输入的符号流中的字符进行扫描，并根据扫描到的字符的情况来对其进行相应的处理：如果可以进行规约则进行规约，如果不能进行规约则进行其他操作。 因为显然，规约不可能是从左到右逐个字符进行处理即可，在实际规约的过程中一定会出现暂时无法进行规约（或者出错）的情况，比如上面那个例子中，排在输入序列第一位的 a 直到最后一步规约中才与句型中的其他符号一起被规约为 E。这说明在规约的过程中，会有“先搁置某些符号，待时机成熟再进行处理”的需求。 这也就是说，我们的语法分析程序需要能够将【暂时不能规约的】字符先按照顺序记录下来。在后面规约的过程中，这个（些）暂时无法被规约的符号要一边等着后面其他可以规约的符号进行规约，一边被语法分析程序监视着——语法分析程序需要能够看情况决定是否要在某次规约中把前面存下的符号加入规约。对字符的存储依然使用栈来进行——用一个栈来存储【将要包含句柄的前缀】，然后在后面不断读取输入字符时，判断已经放在栈中的前缀能否进行规约。 语法分析器对能否规约的判断（什么时候规约、用什么产生式进行规约）也都要依靠一个表来进行，这个表叫做移进规约分析表。 上面这个就是【移进规约】的方法：用栈存储将要包含句柄的输入序列的前缀，用分析表确定【何时栈顶已经形成句柄】以及确定【进行规约要用到的产生式】。 在句柄形成前，要不断将字符从输入序列中移动到栈中。待到栈顶形成句柄时，再将这些符号串规约为一个非终结符。 移进-规约的方法，就是不断地判断扫描过的这部分输入序列的前缀，是否能够被成功地转换为栈中的符号序列。能不能把扫描过的输入序列变成一个文法的【活前缀】（这个词后面会解释）。 土味解说：俺寻思，这语法分析器分析语法，其实就和我们理解人说话差不多：我们说的每句话都包含至少一个单词，有些单词和单词之间是有关联的（也就是多个单词组成一个短语，共同表达一个含义，此时这几个组成短语的单词已经相当于一个整体，需要整体考虑来进行理解）。我们在听其他人说话的时候，我们的耳朵在每个时刻就相当于是一个在读取符号的读写头，追着说话人口中输出的符号流进行读取，并用脑子暂存这个人刚刚说过的某个词，准备与接下来听到的新的词进行关联、整体进行理解。 我们把别人说一半的话先存进脑子等待下文，就是移进（把人家说一半的话移动进入脑子）。 我们完整听完了人家的一段话，可以把这段话进行整体的理解、提取归纳为一个含义，就是规约。 移进规约分析器的工作模式 移进规约分析器的模型和预测分析器非常类似，如下图所示 其中的 符号状态栈 能构成对存储符号和状态——不止像之前学过的符号栈一样只存储符号，还要存储和这些符号相关的一个状态值。符号和状态在栈中成对存储。 移进-规约分析表 会告诉我们是否能够进行规约，如果规约的话按照哪个产生式进行规约。该表的种类不唯一，根据该分析表的不同，可以将移进规约分析器分为【算符优先分析器】、【LR 分析器】等种类。这些分析器都属于移进规约分析器的不同实现。 移进规约分析器的工作方法，是一步一步进行从格局到格局的转换。这里的格局也是个三元组 (#栈，当前剩余输入#，改变格局的动作)。每到一个新的格局，分析器都要通过查表来确定下一步的动作——该移进还是该规约，如果是规约那该按照哪个产生式进行规约。 语法分析，就是从某个初始格局开始经过一系列的格局变化，最终达到接收格局（成功）或出错格局（发现语法错误） 栈：存放文法符号和状态，并且符号和状态成对出现； 剩余输入：初始格局时为全部序列；接收格局时剩余输入为空；其他格局时是原输入序列的一个后缀。 动作：驱动器根据当前栈和剩余输入来查找分析表确定相应动作，并根据这些动作来改变栈和剩余输入的内容、进入下一格局。能改变格局的动作列举如下： 移进（ shift ）：将输入序列中的终结符进栈。该动作在当栈顶没有形成句柄时（也就是暂无法规约时）进行； 规约（reduce）：当栈顶形成句柄时，根据产生式来将栈顶句柄替换为对应非终结符； 接受（accept）：语法分析成功； 报错（error）：发现语法错误，调用错误恢复程序。 移进规约分析例： 用移进-规约方法分析 abbcde 如果把【发生变化了的】句型单独拿出来，从下到上看就是一个最右推导的过程（从下到上就是最左规约了） 注意 在最左规约中，句柄总是在栈顶形成的：语法分析器在进行一次规约后，都必须接着移进 0 或多个符号才能在栈顶找到下一个句柄； 栈中总是含有一个右句型的前缀，且该前缀不包含句柄之后的符号。这个前缀就叫做【活前缀】（在推导的过程中，若每次直接推导均替换句型中最左边的非终结符，则称为最左推导。由最左推导产生的句型被称为左句型。右句型与之对称）。 移进规约分析需要解决的两个关键问题： 如何判断栈顶是否形成了句柄； 当形成句柄的时候，如何选择产生式。 说白了，就是要解决：什么时候规约、以及用什么产生式规约的问题 构造分析表，就是构造【识别活前缀的 DFA 】 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记15：自下而上语法分析（2）LR 分析.html":{"url":"compile-prin/marscat笔记/编译原理笔记15：自下而上语法分析（2）LR 分析.html","title":"编译原理笔记15：自下而上语法分析（2）LR 分析","keywords":"","body":"编译原理笔记15：自下而上语法分析（2）LR 分析基础、LR 分析表、LR(0) 分析表 LR分析 LR 分析的特点： 采用最一般的无回溯移进-规约方法； 适用于几乎所有程序设计语言； 能及时发现错误； 分析表复杂，难以手工构造。 LR 分析表和驱动器是 LR 分析的核心。 以下讨论会基于下面的文法进行： E → E-T | T (1)(2) T → T*F | F (3)(4) F → -F | id (5)(6) 上面的文法也能够说明 LR 的适用范围更广： 产生式可以左递归（预测分析不支持） 同一个符号（ - ）可以既是一元的也是二元的（算符优先分析不支持） LR 分析表 分析表分为两个部分，分别是【动作表（Action）】和【转移表（goto）】。 两个表的行首是分析器状态编号，其对应着识别活前缀的 DFA 的状态； 动作表的列首包含终结符和结束符； 转移表的列首是文法中的非终结符，转移表中的数字是状态号。 分析表中： s ： Shift r ： Reduce acc ： Accept 空白 ： 报错 转移表中的数字对应行首的状态编号 格局与动作 开始格局：（#0， ω#， 移进？） 0： 对应分析表左上角的 0 ，其是识别活前缀的 DFA 的初态，任意语法分析都应该从这里开始； ω：全部的输入序列； 改变格局的动作：一般来说刚开始都是要移进的，除非是一开始就查表查到空白的位置然后出错 结束格局：（#0E1， #， 接收） 0E1：# 和 0 是配对的，E 和 1 是配对的。E 后面的 1 是通过查询分析表得到的（0 状态遇到 E ，通过查转移表可知对应的是状态编号 1）； 剩余输入为空，所以只有一个 # ； 接收（acc）：当前栈顶状态编号为 1 ，剩余输入序列中读到 # ，故根据查表可知这个 action[s, 1] 对应着动作表中的 acc ，也就是要执行 acc 这个改变格局的动作了。 把整个文法的符号序列都规约为文法的开始符号 E ，就可以执行接收动作了。 出错格局：（#δ， ω'# ， 报错） 根据栈顶的状态号和读写头指向的下一终结符（也就是剩余输入的第一个符号）读到了空白，则会到达出错格局。 改变格局的动作的含义： action[s, a] = si：根据当前栈顶状态 s 和当前读到的终结符 a 去查表的 s 行 a 列，确定改变格局的动作。s 意味着要进行移进（Shift），并在移进后转向到 i 状态（将 i 入栈，压在刚刚移进的符号的上面，与刚刚移进的符号配成一对）； action[s, a] = rj：用第 j 个产生式的左部替换掉栈中的句柄（Reduce）； action[s, a] = acc：接收 action[s, a] = 空白：报错 转移表含义： goto[s, A] = s' ：指示了非终结符的状态转移。s 表示的是次栈顶的状态，A 表示非终结符。 当我们刚刚执行一个 action[s, a] = rj 时，栈顶的终结符会被弹出并替换为一个非终结符，此时该终结符位于栈顶，与该非终结符配对的状态需要根据栈顶终结符和次栈顶状态来通过查找 goto 表确定，找到后再将该状态值压入栈顶。 完整的规约动作由 action[s, a] = rj 和 goto[s, A] = s' 两个步骤组成 LR 分析器的工作过程其实可以看作是栈的内容和剩余输入序列所组成的二元组的变化过程（改变格局的动作，也是基于这两个东西去查找分析表确定的），分析开始时的二元组为（#0, a0a1...an#），中间每一步的结果就可以表示为（#0X1s1X2s2...Xmsm, aiai+1...an#），栈中的全是文法符号和状态的组合构成的序列。该序列就是一个活前缀，该前缀由 a0~ai-1 规约而成。 移进：当要对 ai 进行移进时，就要先将 ai 入栈，然后根据 sm 和 ai 去查分析表确定下一状态 s，确定后将 s 入栈，读写头指向下一个符号； 规约：每次规约后，都要查找 goto 表，生成与栈顶配对的状态编号 若 action[sm, ai] = 规约A→β，则说明栈顶一段的符号已经形成了 β 文法符号序列，可以进行规约了。 规约需要先将整个 β 出栈（因符号和状态编号配对，故总计需要弹出 2|β| 次。全部弹出完成后暴露出状态 sm-|β|），A 入栈。 此时通过次栈顶 sm-|β| 和栈顶 A 值查找 goto 表，将结果 goto[ sm-|β|, A] = s 入栈。这个 s 就是和 A 配对的状态。 LR 分析算法： 以对 id--id*id 为例，进行举例分析如下： 这时肯定就会有同学说： “啊~~整挺好，这个 r 后面的值是规约用到的产生式编号，但我要怎么知道规约的时候该用哪个产生式对句柄进行规约呢？” 问得好，这是个很关键的问题，但这是为什么呢？这个到下一篇文章中会介绍。 LR(k) 文法 若文法 G 的分析表中不含多重定义的条目，则该文法为 LR(k) 文法，对应分析器即 LR(k) 分析器，对应语言即 LR(k) 语言。 其中，L：从左到右扫描，R：逆序是最右推导，k：为了确定下一动作会向前扫描的终结符个数——当确定栈顶是某个产生式的右部时，要再向后扫描输入序列 k 个符号，才能决定是否用该产生式及逆行规约。一般 k 这个规约过程中向后扫描终结符，是为了解决【规约-规约冲突】的问题——当规约栈顶可用的产生式的选择超过一个时，可以通过扫描输入序列中后面的一个终结符来辅助决定使用哪个产生式进行规约 （解决这个问题，就要用到这几个右部对应的左部非终结符的 FOLLOW 集合进行判断） LR分析器是一类分析器。根据分析表构造的不同，可以分为 LR(0)、SLR(1)、LALR(1)、LR(1) 分析器。这几个分析器的功能和构造难度都依次递增。一般不构造 k>1 的分析器（因为太复杂惹） LR(0) 项目和 LR(0) 项目集规范族 LR(0) 分析表构造步骤： 构造可识别文法 G 中所有活前缀的 DFA； 根据 DFA 构造 LR(0) 分析表 该 DFA 的构造也有两种方式，一种是先构造 NFA 再基于此改为 DFA，另一种则是直接构造 DFA 。 本文剩余部分将先讲解如何构造 NFA 活前缀 文法 G 中，若在符号序列 α 右边增添零或多个终结符后，能够形成一个右句型且 α 不含该句型句柄之后的任何符号，则 α 为 G 的活前缀。 在推导的过程中，若每次直接推导均替换句型中最右边的非终结符，则称为最右推导。由最右推导产生的句型被称为右句型； 句柄，是一个句型的最左直接短语； LR 分析的任何时刻，栈中的序列都是一个活前缀。如果输入的串语法结构正确，则把输入串中的剩余部分匹配到这个活前缀的后面就能够形成一个右句型； 活前缀其实就是一个符号串，一个文法会有很多的活前缀； 只要保证已经扫描过的输入序列都可以规约成一个活前缀，则到目前为止的分析就是正确的。 我觉得，这个活前缀，其实就是说【仍然灵活的前缀】。活前缀首先是一个前缀，然后它又是具有灵活性的（能够被塑造、向着不同的方向变化的） 举例说明活前缀： 构造 LR(0) 分析器的关键：为 G 构造一个识别它的所有活前缀的 DFA 步骤：先构造识别活前缀的 NFA，再通过确定化、最小化转为 DFA。 这个 NFA 就是用来识别所有语法 G 的活前缀的，其从初态到终态路径上的标记就是活前缀。 状态转换图： 其实就是从产生式直接翻译过来的 产生式 E → E + T 说明了 E 其实无非就是【 E 推导出来的符号序列（被规约规约就变成了 E ）】连接上一个加号，再连接上一个【 T 推导出来的符号序列】。 图中的 0 状态表示状态转换图的初态，后面接着的几个状态，要说明的是：在 0 状态开始，期望看到 E+T 推导出来的输入序列。当自动机跳到 0 状态后面连接的 1 状态，表示已经看到了 E 推导出来的输入序列，我们在 1 状态这里期望从 1 开始看到 +T 推导出来的输入序列（也就是读写头将要读的那些符号，应该可以经过规约后变成 +T ）。 也就是说，识别活前缀就是要在 NFA 的状态中记录下【我看到了产生式的哪个部分、没有看到哪个部分】，即，识别活前缀的 NFA 状态中应该包含并体现产生式的信息（直接放在状态转移上即可）、已经看到和还没有看到的信息（接下来会提到，这个 ”进度“ 是通过在产生式右部序列中插入一个圆点来表现的，通过圆点的位置标记我们已经看到了的序列的进度） LR(0) 项目 NFA 的每个状态都应该能够记录 从初态到当前状态，已经看到了哪个产生式右部的多少内容。并基于此来判断下一步该做什么，即：若分析器处于当前状态，则下一步要选择的动作是移进还是规约，如果是规约，那么规约时要用到哪个产生式。 产生式右部加入的点 【 . 】 在右部的位置表示一个 NFA 的状态（这样一个加圆点的产生式就叫做一个【LR(0)项目】）。我们接下来都会用一个 LR(0) 项目表示一个 NFA 状态 一个 LR(0) 项目（简称为项目） 是一个产生式，其右部的某个位置有一个点 “ . ” 。特殊的，对于 A → ε 仅有一个项目 A → . 这样的一个项目就代表 NFA 的一个状态，点前面的表示已经看到的产生式部分，后面的表示没有看到的产生式部分。 比如产生式 A → XYZ 共有四个项目： A → .XYZ 、A → X.YZ 、 A → XY.Z 、 A → XYZ. 项目的意义 项目说明分析过程中每个时刻已经看到了产生式的多大一部分，比如： A → .XYZ 说明希望从后面的输入串中可以看到【能够从 XYZ 推出的符号串】，如果想要看到它则在此处需要移进 A → X.YZ 说明已经从输入串中看到了【可以从 X 推出的符号串】，希望进一步能看到【可以从 YZ 推出的符号串】，如果想要看到则此处需要继续移进 A → XYZ. 说明当前栈顶已经形成句柄了，此时可以进行规约。 比如下面这个例子： 我们接下来的学习路线大概是这样的： 文法 G => 文法 G 的 LR(0) 项目 => 构造识别 G 的所有活前缀的 NFA => 构造识别 G 的所有活前缀的 DFA => 为文法 G 构造 LR(0) 分析表 和词法分析中构造 NFA 的路数比较接近。 由文法的 LR(0) 项目构造识别活前缀的 NFA 每个 LR(0) 项目都是 NFA 的一个状态 Σ：文法符号和 ε 初态：左边为文法开始符号且圆点在右部最左端的项目 终态：NFA 的所有状态（是的，每个状态都是终态，这个和词法分析 NFA 不同） 状态转移关系 move：若状态 i、j 出自同一个产生式，且状态 j 的圆点只落后状态 i 的圆点一个位置（比如状态 i 为 A → X.YZ，状态 j 为 A → XY.Z），则从 i 画一条标记为 Y 的边到状态 j； 若状态 i 圆点后面是非终结符，比如 i：X → α.Aβ，则从 i 画 ε 边到所有 A → .γ 的状态 下面给出一个例子，文法 G： S' → E E → aA | bB A → cA | d B → cB | d （该文法其实是【拓广文法】，原文法的开始符号就是 E ，我们在这里引入一个新的开始符号 S' ，关于【拓广文法】后面会再提到，这里只需要知道：文法经过拓广后才能够构造 NFA 即可） 其项目： 1 S' → .E 2 S' → E. 3 E → .aA 4 E → a.A 5 E → aA. 6 A → .cA 7 A → c.A 8 A → cA. 9 A → .d 10 A → d. 11 E → .bB 12 E → b.B 13 E → bB. 14 B → .cB 15 B → c.B 16 B → cB. 17 B → .d 18 B → d. 方法： 所有的状态都是 NFA 的终态，红圈圈上的是【句柄识别态】，处在该状态时，圆点在整个产生式的最右端，语法分析处于这些状态的时候意味着已经【看到了产生式的完整右部】，自然也就可以进行规约了。 所有的状态都是 NFA 的终态，只要能够在 NFA 中任意找到一条路径，那这条路径的序列就是一个活前缀 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记16：自下而上语法分析（3）构造 DFA、DFA 对下一步分析的指导（有效项目）.html":{"url":"compile-prin/marscat笔记/编译原理笔记16：自下而上语法分析（3）构造 DFA、DFA 对下一步分析的指导（有效项目）.html","title":"编译原理笔记16：自下而上语法分析（3）构造 DFA、DFA 对下一步分析的指导（有效项目）","keywords":"","body":"编译原理笔记16：自下而上语法分析（3）构造 DFA、DFA 对下一步分析的指导（有效项目） 看了前面的内容，我们已经了解到：分析表和驱动器算法，是 LR 分析器的核心。 在分析的过程中，语法分析器总是根据栈顶的状态、当前剩余输入的第一个终结符查询分析表，以确定改变格局的动作并执行，实现对栈和剩余输入的内容的修改，从一个格局转移到另一个格局，如此往复直至分析完毕（或报错）。 下面我们就来研究一下如何从文法构造 DFA —— 这是构造 LR(0) 、SLR(1) 分析表的第一步。 由 NFA 用子集法构造 DFA 前一篇博客中讲解了该如何构造 NFA，有了 NFA 就可以使用子集法构造 DFA 了。 构造方法与词法分析的 NFA 转 DFA 类似，此处不再重复，接下来说一些该 DFA 的特点。 DFA 中的每个状态都是原 NFA 的状态集（因为 DFA 是 NFA 使用子集法构造的）。而又因 NFA 的每个状态都对应一个项目，所以 DFA 中的每个状态又是一个项目集。 DFA 的初态由原 NFA 初态求 ε-闭包得到，DFA 中的所有状态都是其终态。 （类比子集法构造词法分析 DFA——DFA 的终态是包含原 NFA 终态的那些状态，而原来的那个 NFA 本身就已经所有状态均为终态了，也就是说从初态出发到达任何一个状态的路径所标记的连接都是该 DFA 可识别的活前缀。同理，原来的句柄识别态到这里依然是适用的，就是图中的 1、8、10、6、7、11、9 ） 该识别活前缀的 NFA 和原来的词法分析 NFA 有一个重大差别：词法分析 NFA 状态号就只是一个编号，而此处的状态编号却是和项目相对应的——每个编号就对应着一个项目，而且状态的转移关系也是基于这些项目建立起来的。 那么。。其实也可以直接从项目构造 DFA 由 LR(0) 项目直接构造识别活前缀的 DFA LR(0) 项目集规范族：构成识别一个文法活前缀的 DFA 的项目集（状态）的全体，称为这个文法的 LR(0) 项目集规范族。这个规范族提供了建立一类 LR(0) 和 SLR 分析器的基础。 实际上，这个【规范族】就是我们要构造的识别活前缀的 DFA 的状态的全体——上面那个 DFA 中所有的矩形状态加起来就是了。主要是因为 DFA 的每个状态都是一个 LR(0) 项目集，所以就想起来这么个骚名字叫做【LR(0) 项目集规范族】 （如果题目让计算一个LR(0) 项目集规范族，那其实就是要计算识别活前缀的 DFA。有了 DFA 就可以构造 LR(0) 分析表和 SLR(1) 分析表了） 我们先给项目做做分类、起起名字，后面要用到： 圆点在最右端的项目（如 A → α. ，A 不是拓广文法的开始符号）称为”规约项目“，在出现规约项目的状态就可以进行规约动作； 文法开始符号 S' 的规约项目称为”接受项目“（比如 S' → α. ）； 形如 A → α.aβ 的项目称为”移进项目“，a 为终结符。在该状态下，如果下一个输入是终结符 a 则可以进行移进动作； 形如 A → α.Bβ 的项目称为”待约项目“，B 为非终结符。”待约项目“的含义是【等待把 B 规约出来】：若想按照该产生式进行规约，就得先想办法把 B 搞出来，看到 B 之后才能进行后面的规约动作；（B 是非终结符，可是输入序列中么的非终结符啊。。因此，想要用这个产生式进行规约那需要凑齐该产生式的右部——先把输入序列中由 B 推导出来的符号序列规约成 B 就可以了） 构造 DFA 求拓广文法 G' 拓广文法： G' = G ∪ { S' → S } 其实就是先引入一个新的非终结符 S' 作为拓广文法的新的开始符号，并引入新的产生式 S' → S CLOSURE & GO CLOSURE( I )：从项目集 I 不经过任何文法符号到达的项目全体（和词法分析中的 ε-闭包(I) 的含义相同） GO( I, X )：所有从 I 经文法符号 X 能到达的项目全体（只需要到达就好了，不止一步也可以。因此要先计算直接到达的，再在能够直接到达的基础上求闭包。因此显然，GO 和词法分析 NFA 的 smove 的功能不对等：GO 含有闭包计算）。X 只是一个文法符号，终结符、非终结符均可。 例： 对于下面的文法 G，若 I={ S → .E } S' → E E → aA | bB A → cA | d B → cB | d 求 CLOSURE(I) CLOSURE(I) = { S' → .E, E → .aA, E → .bB } 首先，S' → .E 是项目集自身元素，自然不需要经过任何文法符号即可到达。后两个项目则是因为他们均可由初态通过 ε 边即可到达，同样满足【从项目集 I 不经过任何文法符号到达的项目】这一要求。（此处可以脑补一下 NFA 图） 求 GO(I, a) GO(I, a) = { E→a.A, A→.cA, A→.d } 首先， E→a.A 是直接而从 I 中的项目出发经过 a 能够到达的项目。后面两个项目则可由这个 E→a.A 通过 ε 边可到达。这也符合“所有从 I 经文法符号 a 【能】到达的项目全体”这一定义。 构造 DFA 构造下面的文法 G' 的 DFA E' → E E → E-T | T T → T*F | F F → -F | id 首先求 CLOSURE( {E' → .E} )，并将其作为整个 DFA 的初态，即： I0 = CLOSURE( {E' → .E} ) = { E' → .E, E → .E-T, E → .T, T → .T*F, T → .F, F → .-F, F → .id } 将 I0 作为初态，其实也就是像下图左边这样，画一个矩形大方框再把 I0 里面的这些个项目依次写进去。。这整个一个方框就是我们的 DFA 的初态了。接下来就可以从该初态出发，逐步构造 DFA 。这个逐步构造的过程，无非也就是【挨个算一下从初态的各个项目起，经过哪些文法符号可以得到哪些新项目】，新项目自然也就可以形成新的状态，通过转移用的文法符号与原来的状态相连。 使用同样的规则重复操作（摊大饼），最后能得到如下图所示的 DFA 该 DFA 就能够用来识别活前缀了。与词法分析 DFA 不同的是，该 DFA 的任何一个状态都是终态。这也就意味着，从初态开始到任一个状态所形成的路径上面的标记连接起来，都是一个 DFA 能够识别的活前缀。 比如，对于状态3（即 I3），其能够识别的活前缀有 F 和 E-F；状态6能够识别的活前缀只有 E- 现在，我们再回头看一下移进规约的过程就会发现一些有意思的东西 确实，每个时刻，栈中的内容都和分析表、自动机有着关联。我们可以尝试去读栈中任一时刻的元素（从栈底到栈顶），这些状态号、文法符号相间的序列均能在上图左边的 DFA 中和一条路径相匹配。 DFA 指导下一步分析 DFA 每个状态识别的活前缀不同； 对语法结构正确的输入序列进行分析的任一时刻，若此时分析器正处于 DFA 的某状态 i ，则状态 i 识别的活前缀出现在栈中，且状态 i 正位于栈顶。语法分析器正是根据此刻状态 i 中包含的 LR(0) 项目来指导下一步分析的； 状态 i 中出现的 LR(0) 项目对状态 i 能够识别的活前缀有效。 好的，DFA 看起来是个好东西，那么我们现在假设栈顶是 5 状态，此时 DFA 怎么指导下一步的分析呢？ 有效项目 若存在最右推导：S' =*> αAω => αβ1β2ω ，则称项目 A → β1.β2 对活前缀 αβ1 有效。 项目 A → β1.β2 对活前缀 αβ1 有效，作用是说明：在当前活前缀为 αβ1 的情况下，当前状态中的 A → β1.β2 这个项目可以指导下一步的分析动作为： αAω => αβ1β2ω 。 我觉得吧：已经读到并且已经入栈的东西，全都是活前缀。活前缀呢，就是仍然可以活动的前缀——根据其后添加的符号不同，这个活前缀可能会变成某个句柄——也就是说，活前缀能够在后面加入某些新的符号之后成为某个产生式的右部，也就可以被用这个产生式规约掉。 对于符号串 αβ1β2ω ，看起来应该是可以使用 A → β1β2 对其进行规约。读写头在读输入序列的时候是一个一个符号去读，读到了要移进的也是一个接着一个压栈。当栈中是 αβ1 （即当前活前缀是 αβ1 ）时，如果我们已经知道有这么个项目： A → β1.β2 ，那就说明如果下一个读到了 β2 ，栈顶就能够形成该产生式的句柄，我们也就可以利用这个项目的下一步项目 A → β1β2. 进行规约了。 这其实就体现了 DFA 对分析的指导作用。 可知：同一项目集中的所有项目，对此项目集的所有活前缀均有效。即，项目集中的每个项目均有同等权利指导下一步动作。 有效项目的意义： 项目到目前为止的分析均是正确的； 可以指导下一步的分析： A → α.aβ（可移进项）：若当前剩余输入为终结符 a ，则移进 a； B → β. （可规约项）：按产生式 B → β 进行规约。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/编译原理笔记17：自下而上语法分析（4）.html":{"url":"compile-prin/marscat笔记/编译原理笔记17：自下而上语法分析（4）.html","title":"编译原理笔记17：自下而上语法分析（4）","keywords":"","body":"编译原理笔记17：自下而上语法分析（4）LR(0)、SLR(1) 分析表的构造 LR(0) 文法 若一个文法 G 的拓广文法 G' 的识别活前缀的自动机中的每个状态（项目集）均不存在下述情况： 既有移进项目又有规约项目（移进-规约冲突）； 含有多个规约项目（规约-规约冲突）， 则称 G 为一个 LR(0) 文法 （移进项目就是指圆点右边是终结符的项目，规约项目指的就是圆点在右部最右端的项目） 如下图所示就不是一个 LR(0) 文法，红框状态中的项目中均存在移进-规约冲突，且均是上面的项目为规约项、下面的项目为移进项。 LR(0) 文法可以直接通过识别活前缀的 DFA 来构造 LR 分析表 LR(0) 分析表的构造 假定 C = {I0, I1, ... , In} （aka. LR(0) 项目规范族、DFA 状态集） 首先为文法产生式进行编号，拓广文法的产生式要标记为 0（这里就是后面分析表中 rj 的产生式编号 j 的由来） 然后令每个项目集 Ik 的下标 k 作为分析器的状态（行首），包含 S' → .S 的集合下标为分析器的初态（也就是 DFA 的初态，一般都是 0 ）。 下面用一个例子来说明 ACTION、GOTO 子表的构造： 例 对产生式进行编号并画出 DFA (0) S' → E (1) E → aA (2) E → bB (3) A → cA (4) A → d (5) B → cB (6) B → d 根据 DFA 的项目集确定分析器状态，写出分析表的行下标（行首）。并根据分析表的要求写出 ACTION、GOTO 子表的列下标（列首）。ACTION 表列下标是所有的终结符，GOTO 表的列下标是除了拓广文法新加入的非终结符之外的所有其他非终结符 填写表格内容——实际上就是把 DFA 中的各个转移的边都挪进来。具体就是要逐个去看 对于移进项目：从初始的 0 状态出发，有一条标记为 a 的边连接到 2 状态。这就说明，进行语法分析的过程中，当栈顶为 0 状态且剩余输入为 a 时，就需要执行移进动作——将 a 移进栈，并紧接着将 DFA 的状态转移到 2。因此，0 行 a 列填入 s2。同理，0 行 b 列填入 s3。 对于待约项目：对标记为非终结符的边，填写 GOTO 表 。例如，次栈顶为 0、栈顶为 E 时，语法分析器会转移到 1 状态。因此将 1 填写在第 0 行 E 列的位置上。 对于接收状态。接受状态时输入序列全部读完，所以剩余输入是 # 。即，当前栈顶为 1 状态且剩余输入为 # 时可以执行接收动作，因此第 1 行 # 列填入 acc。 对于规约项。用状态 6 举例。当到达状态 6 时，无论剩余输入字符是什么终结符，都可以进行规约了。对于状态 6 中项目所描述的 E → aA.，显然可以用产生式 (1) E → aA进行规约。因此，ACTION 表中第 6 行的所有列均填入 r1 用上面四点的规则填写整张表，最后得到完成的 LR(0) 分析表如下图所示 SLR(1) 文法 SLR(1) 为解决冲突提出了一个简单的方法：通过识别活前缀的 DFA 和【简单向前看一个终结符】构造 SLR(1) 分析表。 如果我们的识别活前缀的 DFA 中存在移进-规约冲突、规约-规约冲突，都可以尝试使用这个方法来解决冲突。（这里说【尝试】，当然是因为 SLR 也只能解决一部分问题，并不是万能的灵丹妙药。。） 这里，我们拿前面那个 LR(0) 解决不了的文法来举例 该文法不是 LR(0) 文法，但是是 SLR(1) 文法。 观察上图 DFA 中的状态2，想象当我们的自动机正处于这个状态：次栈顶已经规约为 T 了，栈顶也是当前的状态 2 ，而当前剩余输入为 *。 如果这个自动机不会【往前多看一步】的话，那么对处于这个状态的自动机来说，看起来状态 2 中的移进项目和规约项目都是可选的。这就是移进-规约冲突。 想要解决这个冲突，就轮到【往前多看一步】上场了——把当前剩余输入考虑进来，辅助进行项目的选择： 如果，按照第一个项目将 T 规约为 E，那么接下来的 就要跟在 E 后面了。而 ∉ FOLLOW(E)，也就是说 * 是不能跟在 E 后面的——这就意味着，如果我们将 T 规约为 E 将出现错误； 如果，按照第二个项目进行移入，那么 被移入后就将跟在 T 后面。而 ∈ FOLLOW(T) ，因此将 * 移入不会引起任何问题 。 这里就能看出 SLR(1) 的缺陷了——如果 * 同时属于 FOLLOW(T) 和 FOLLOW(E) ，那么我们这种判断方式就不灵了，也就是说这种冲突无法被 SLR(1) 解决。 对其他的冲突也使用同样的方法进行判断。 这种冲突性动作的解决办法叫做 SLR(1) 解决办法 SLR 分析表构造 准备工作部分，与 LR(0) 分析表的构造差不多：同样使用每个项目集的状态编号作为分析器的状态编号，也就同样用作行下标；同样使用拓广文法产生式作为 0 号产生式。 填表也和 LR(0) 类似，唯一的不同体现在对规约项的处理方法上：如果当前状态有项目 A → α.aβ 和 A → α. ，而次栈顶此时是 α 且读写头读到的是 a，那么当且仅当 a∈FOLLOW(A) 时，我们才会用 A → α 对 α 进行规约。 如果构造出来的表的每个入口都不含多重定义（也就是如上图中表格那样的，每个格子里面最多只有一个动作），那么该表就是该文法的 SLR(1) 表，这个文法就是 SLR(1) 文法。使用 SLR(1) 表的分析器叫做一个 SLR(1) 分析器。 非 SLR(1) 文法举例 二义文法都不是 SLR(1) 文法 任意的二义文法都不能构造出 SLR(1) 分析表 例：悬空 else A → S S → iCtSS' | a S' → eS | ε C → b 不是二义文法的非 SLR(1) 文法 例： S → L=R | R L → *R | id R → L 这里的 L 可以理解为左值，R 可以理解为右值 经过计算可以确定其 DFA 如下图所示。 在 状态4 中，由于 \"=\" 同时存在于 FOLLOW(L) 与 FOLLOW(R) 中，因此该状态内存在移进-规约冲突，故该文法不是 SLR(1) 文法。 这样的非二义文法可以通过增加向前看终结符的个数来解决冲突（比如LL(2)、LR(2)）但这会让问题更加复杂，故一般不采用。而二义文法无论向前看多少个终结符都无法解决二义性。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"compile-prin/marscat笔记/【早期草稿】编译原理笔记18：语法制导翻译（1）.html":{"url":"compile-prin/marscat笔记/【早期草稿】编译原理笔记18：语法制导翻译（1）.html","title":"【早期草稿】编译原理笔记18：语法制导翻译（1）","keywords":"","body":"编译原理笔记18：语法制导翻译（1） 语法制导翻译生成中间代码 语法和语义 语法：语言的结构（即语言的样子） 语义：语言的意义 语义不能离开语法而存在 同一语言结构可含多种含义，不同的语言结构也可以表达相同含义 语法和语义没有明确的界限 语义分析的两个作用： 检查结构正确的句子表达的意思是否合法 执行规定的语义动作，如： 表达式求值 符号表填写 中间代码生成等 语义分析的方法：语法制导翻译（将语法结构翻译为中间代码或直接执行） 属性与语义规则 比如对 x = y + z，实际上是 id = id + id，符号也是有属性的如 name 和 address 和 type。 语义通过函数执行，函数执行的动作由设计者定义。这样的动作被称作“语义规则” 单个符号的意义蕴含在【属性】中，数个符号构成的整体结构则需要根据语义规则确定 语法制导翻译的基本思想：以语法分析为基础，伴随语法分析的各个步骤，执行相应的语义动作 具体方法： 将文法符号所代表的语言结构的意思，用附着于该文法符号的属性表示 用语义规则规定产生式所代表的语言结构之间的关系（属性和属性之间的关系），即用语义规则实现属性的计算 语义规则的执行：在语法分析的适当时刻（如推导或规约）执行附着在对应产生式上的语义规则，以实现对语言结构语义的处理，如计算、查填符号表、生成中间代码、发布出错信息等（自下而上的分析中，一般在规约时执行语义规则） 属性的抽象表示 .attr 如 E.val ，E.type，E.code，E.place ，分别代表值、类型、代码序列、存储空间 接下来的所有讨论都默认基于二义文法进行，默认已经通过定义的方式解决了优先级和结合性（像是在 yacc 里面直接写上的那种） 属性的定义： 对于产生式 A → α，α 是由文法符号 X1X2...Xn 组成的序列，其语义规则可表示为下面这个关于属性的函数： b := f(c1, c2, ..., ck) 这里用函数表示语义之间的关系。 属性分为综合属性和继承属性 如果 b 是 A 的属性， c1~ck 为 α 中符号的属性或 A 的其他属性，则 b 为 A 的综合属性，适合于自下而上分析 若 b 是 α 中某文法符号 Xi 的属性，c1~ck 是 A 的属性，则 b 是 Xi 的继承属性，适合于自上而下分析 称 属性 b 依赖于 属性 c1~ck 若语义规则符合 f(c1, c2, ..., ck)，则可将其想象为产生式左部符号 A 的一个虚拟属性。属性之间的依赖关系在虚拟属性上也存在 属性的依赖关系，实际上反映了属性计算的先后次序。即所有属性 ci 被计算后才能计算 b 例：将中缀形式的算术表达式转换为后缀表示。其语法制导定义和翻译方案可分别定义如下。其中 print(E.post) 是 L 的虚拟属性，可以想象为 L.p := print(E.post)。翻译方案中的 .lexval 表示词法分析返回的记号 num 的值 语法制导定义是算法，翻译方案的程序实现不唯一 LR 分析翻译方案设计 LR 分析中的语法制导翻译实际上是对 LR 语法分析的扩充 扩充 LR 分析器的功能：当执行规约产生式的动作时，也执行相应的语义动作。由于是规约时执行语义动作，限制语义动作仅能放在产生式右部的最右边； 扩充分析栈，增加一个与分析栈并列的语义栈，用于存放栈中文法符号所对应的属性值 语法分析同时进行语法制导翻译，语法分析结束，值也就算出来了 因为不关心加号是什么含义，所以语义栈中加号的位置就没有值，用一个问号表示 中间代码简介 中间代码有后缀式、三地址码、树表示的中间代码三种。这三种中间代码表示可以相互转换 后缀式 三地址码 三地址码的具体写法：三元式、四元式 三元式实际上还是四元式，前面的序号意味着“把三元式的结果放到序号的位置去”，不光是表示其是第几条，还是要保存一个值的 比如这个，前面的序号就相当于存了一个值，说明括号内运算的结果放在该序号中 树表示的中间代码 符号表 符号表是连接声明与引用的桥梁，记住每个符号的相关信息（如作用域、绑定），帮助编译的各个阶段正确有效地工作。（用语义的方法解决语法无法描述的结构） 符号表设计的基本要求：合理存放信息、快速准确查找 符号表中的每一条称为一个条目，每个声明的名字在符号表中占据一栏，存放名字和相关信息 内容有保留字、标识符、特殊符号（算符、分隔符等） 不同符号可以放在不同子表中，如变量名表、过程名表、保留字表 声明语句的翻译 这里 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/about.html":{"url":"database/about.html","title":"数据库笔记","keywords":"","body":"数据库笔记 CH1 CH2 CH3 CH4 CH5 CH6 CH7 CH8 CH9 CH10 CH11 CH12 CH13 CH14 CH15 并发控制 ch16 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch1.html":{"url":"database/ch1.html","title":"CH1","keywords":"","body":"第一章 一、Data Models and Databases 抽象层次 Levels of Abstraction 物理层Phsical Level：描述数据如何存储 逻辑层Logical Level：描述数据库中存储什么数据以及数据间的关系。 物理数据独立性（phicial data indepentdence） 视图层View Level：描述整个数据库的某个部分 例子 定义如下记录 type instructor = record ID: char(5) name: char(20) dept_name: char(20) salary: numberic(8, 2) end; 物理层：instructor记录可能被描述为连续存储位置组成的存储块。 逻辑层：定义了这些记录类型的相互关系 程序设计人员正式在这个抽象层次上使用某种程序设计语言进行工作。 数据库管理员也是在这个抽象层次工作。 视图层：计算机用户看见的是为其屏蔽了数据类型细节的一组应用程序 视图层上定义了数据库的多个视图，数据库用户看到的是这些视图。 提供了防止用户访问数据库的某些部分的安全性机制 二、实例和模式 实例 特定时刻存储在数据库中的信息的集合称作数据库的一个实例。 模式 数据库的总体设计 物理模式 physical schema 物理层描述数据库的设计 逻辑模式 logical schema 在逻辑层描述数据库的设计 视图层模式 有若干种，有时称为子模式（subschema） 描述了数据库的不同视图 逻辑层最重要，物理模式隐藏在逻辑模式下，通常可以轻易被更改应用程序如果不依赖与物理模式，他们就被称为具有物理数据独立性 三、数据模型 data model 是一个 描述数据 数据联系 数据语义 以及一致性约束 的概念工具集合 提供了一种描述 物理层 逻辑层 视图层 的数据库设计的方式 关系模型 rational model 关系模型用表的集合来表示数据和数据间的联系。 实体-联系模型 entity-relationship model ER模型，基于对显示世界的这样一种认识 现实世界由一组称作实体的基本对象以及这些对象间的联系构成。实体是现实世界中可区别于 基于对象的数据模型 object-based model ER模型增加了封装、方法和对象标识等概念后的扩展。 半结构化数据模型 semistructured data model（XML） 允许那些相同类型的数据项含有不同的属性集的数据定义。XML被广泛用来标识半结构化数据。 四、关系数据库 关系数据库包括DML和DDL。 表 所有数据都存放在若干表中 数据操纵语言 DML Data-Manipulation Language DML中设计信息检索的部分称作查询语言（query language）。通常把查询语言和数据操纵语言作为同义词 非过程化的，以几个表作为输入，总是仅返回一个表。 数据定义语言 DDL Data-Defination Language 可以定义表、完整性约束、断言和授权等。 元数据：metadata，关于数据的数据。只能由数据库系统本身来访问和修改 五、Database Design 设计过程 初始阶段：全面刻画预期的数据库 概念设计**conceptual-design**：描述数据以及他们之间的关系 ER模型 规范化算法，将所有属性集所谓输入，生成一组关系表 逻辑设计阶段：将高层的概念模型映射到要使用的数据库系统的实现数据模型上 物理设计阶段指定物理特性，包括文件组织的形式以及内部的存储结构 六、数据库引擎 存储管理器（storage manager） 查询处理器（query processing） 事务管理（transaction manager） 存储管理器 storage manager 存储管理器在数据库中存储的底层数据与应用数据以及向系统提交的查询之间提供接口的部件； 存储管理器负责与文件管理器进行交互，原始数据通过操作系统提供的文件系统存储在磁盘上； 存储管理器将各种DML语句翻译为底层文件系统命令。 存储管理器负责数据库中数据的存储、检索和更新 权限及完整性管理器 事务管理器 文件管理器 缓冲器管理器 实现了几种数据结构 数据文件：数据库自身 数据字典：关于数据库结构的元数据，尤其是数据库模式 索引：针对数据项的快速访问 查询处理器 DDL解释器（DDL interpreter），解释DDL语句并将这些定义记录在数据字典里 DML编译器（DMLcompiler），将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令 一个查询通常可被翻译成多中等价的具有相同结果的执行方案的一种，DML编译器还进行查询优化，从几种选择汇总选出代价最小的一种 查询执行引擎（query evaluation engine），执行由DML编译器产生的低级指令。 事务管理 原子性 atomicity 一致性 consistency 持久性 durability 事务transaction是数据库应用中完成单一逻辑功能的操作集合。 每个事务是一个具有原子性和一致性的单元。我们要求单元不违反任何数据库的一致性约束。但是执行过程中，必要时允许暂时的不一致。 原子性和一致性是恢复管理器recovery manager的职责。 为了保证原子性，失败的事务必须对数据库状态不产生任何影响，数据库必须被恢复到该失败事务开始执行之前的状态。这种情况下数据库系统必须进行故障恢复failure recovery。 并发控制管理器concurrency-control manager，控制并发事务间的相互影响，保证数据一致性 事务管理器transaction manager包括并发控制管理器和恢复管理器 数据库体系结构 数据库架构很大程度上取决于所运行的操作系统 集中式 客户端-服务器的 并行的 分布式的 数据库史 50~60年代 磁带用于数据存储，只能顺序读取。 60年代末~70年代 摆脱了顺序访问的限制，可以将表和数保存在磁盘上。 关系模型和查询数据的非过程化方法出现。关系型数据库诞生 80年代 关系型数据库真正应用，取代了网状和层次型数据库。 程序猿只需要考虑逻辑层的工作。 90年代初 许多厂商推出了并行数据库产品。 90年代 互联网的爆发式发展。数据库系统需要提高事务处理速度和高可靠性，提供对数据的web接口 2010年前 XML兴起。开源数据库系统应用显著增长——PostgreSQL和MySql 至今 用于数据分析的数据库。 按列存储的列存储数据库 高度并行的数据库 分布式数据库 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch2.html":{"url":"database/ch2.html","title":"CH2","keywords":"","body":"第二章 关系模型 [toc] 一、Structure of relational database 关系数据库的结构 关系数据库由表的集合组成，每个表有唯一的名字。 关系——表 元组——行 属性——列 关系实例——一个关系的特定实例 域——属性的取值范围 数据库模式 需要区分数据库模式和数据库实例（database） 前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照。 关系实例的内容经常变化，关系模式不经常变化。 码keys 一个元组的属性值必须能够唯一区分元组。 一个关系中没有两个元组在所有属性上取值相同 超码 superkey 一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地确定一个元组。 形式化描述：设R表示关系r模式中的属性集合，如果R的一个子集K是r的一个超码，则关系r中任意两个不同元组不会在K的所有属性上取值完全相等。 超码中可能包含无关紧要的属性。如果K是一个超码，则K的任意超集也是超码。 最小超码称为候选码 candidate key，他们的任意真子集 主码 primary key 表示被数据库设计者选中，用来在关系中区分不同元组的候选码。 外码 foreign key 一个关系模式$r_1$可能在它的属性中包括另一个关系模式$r_2$的主码。 关系$r_1$也称为外码依赖的参照关系（referencing realtion），$r_2$称为外码的被参照关系（referenced relation）。 参照完整性 referential integrity constraint 要求在参照关系任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值 二、关系查询语言 查询语言（query language）是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化和非过程化的 过程化语言（procedural language） 用户指导系统对数据库执行一系列操作以计算出所需结果。 非过程化语言（nonprocedural language） 用户只需描述所需信息，不用给出获取该信息的具体过程 三、关系运算 关系运算是过程化语言，有如下6个运算 select（选择）：$\\sigma$ project（投影）：$\\pi$ union（并）：$\\cup$ set difference（集合差）：$-$ cartesian product（笛卡尔积）：$\\times$ rename：$\\rho$ select 选择 $\\sigma_{p}(r)$ $p$是选择谓词 \\sigma_{p}(r)=\\{t \\mid t \\in r \\text { and } p(t)\\} project 投影 Union并 按行并 r和s必须有相同的属性 属性的domain必须是compatible可兼容的 笛卡尔积 $r\\times s$ $\\rho$ 四、例子 五、额外操作符 set intersection（集合交） natural join（自然连接） division（除法） 集合交 与union同等级 r \\cap S=\\{t \\mid t \\in r \\wedge t \\in S\\} r \\cap s=r-(r-s)$ 连接 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch3.html":{"url":"database/ch3.html","title":"CH3","keywords":"","body":"第三章 SQL [TOC] 一、SQL查询语言概览 SQL包含一下部分 数据定义语言（data-defination language，DDL）：提供定义关系模式、删除关系以及修改关系模式的命令 数据操纵语言（data-manipulation language，DML） 插入元祖 删除元组 修改元组 完整性（integrity） DDL包括定义完整性约束的命令 破坏完整性约束的更新是不允许 视图定义（view defination） DDL定义视图的命令 事务控制（transaction control） SQL包括定义事务的开始或结束的命令 嵌入式SQL和动态SQL（embedded SQL and dynamic SQL） Embedded sql and dynamic sql如何嵌入到通用编程语言，如C、C++和java 授权（authorization） DDL包括定义对关系和视图的访问权限命令 基本类型 每种类型都可能包含一个被称作空值的特殊值。 该值可能存在但并不为人所知，可能根本不存在 create table construct create table r(A1D1, A2D2, ..., AnDn, integrity-constraint1, ... integrity-constraintk) integrity constraints完整性约束 not null Primary key($A_1, ..., A_n$) Foreign key($A_m,...,A_n$) references r create table instructor( ID char(5), name varchar(20) not null, dept_name varchar(20), salary varchar(20), salary numeric(8,2), primary key(ID), foreign key(dept_name) references department); primary key自动保证字段为not null Integrity Constraints in Tables表的完整性约束 完整性约束保证数据库的修改不会导致数据一致性的丢失 primary key foreign key [not] null unique default check assertion update insert insert into instructor values(.....) delete delete from student where... drop table alter alter table r add A D A是attribute D是domain alter table r drop A SQL查询的基本结构 结果也是一个关系 执行顺序 select语句 大小写不敏感 \\text { Name } \\equiv N A M E \\equiv \\text { name } 结果的元组重复 allow duplicates in relations as well as in query results. 允许query结果中存在重复元组 force elimination of duplicates, 在select后添加distinct select distinct dept_name from instructor 使用all关键字显示保留重复值 select all dept_name from instructor 星号 asterisk asterisk * 表示all attributes select * from instructor 属性可以是字面值 没有from语句 select '457' 结果是一个一行一列的表，值为'457' 可以给列命名 select '233' as FOO 使用from语句 select 'A' from instructor 结果一列n行（n是instructor表的行数） 每一行的值都会“A” 可以使用算术表达式 select ID, name, salary/12 from instructor 返回的relation中salary属性的值均除以12 可以对该字段进行重命名 select ID, name, salary/12 as monthly_salary where语句 from语句 rename operation select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name = 'Comp.Sci' 自连接例子 find the supervisor of the supervisor of \"Bob\" select S.supervisor from emp_super as T, emp_super as S where T.person = 'Bob' and T.supervisor = S.person like percent%：匹配任意子串 underscore_：匹配任意字符 Find the names of all instructors whose name includes the substring \"dar\" select name from instructor where name like \"%dar%\" 如果匹配字符串“100%” like '100\\%' escape '\\' Esacpe '\\'指定转义字符 是大小写敏感的 排序 select distinct name from instructor order by name 指定顺序逆序 desc 降序 asc 升序 order by name desc 根据多个属性排序 order by dept_nam, name 重复 集合操作 union：并 intersect：交 except：差 上述操作默认消除重复元组，使用union\\intersect\\except all保留重复 集合操作例子 题目：找出最高的工资 找出工资不是最高的instructor的工资 select distinct T.salary from instructor as S, instructor as T where T.salary 用总体的减去上述结果 (select distinct salary from instructor) except (select distinct T.salary from instructor as T, instructor as S where T.salary Null values null表示未知值或不存在的值 任何包含null的数学表达式的结果都是null is null可以用来检查null值 example Find all instructors whose salary is null select name from instructor where salary is null unknown 三个逻辑值 true false unknown 任何与null值进行的比较都返回unknown example：5 null or null = null 对于上述操作，令unknown为true或false，如果得到结果一致，则结果是对应结果，如果结果不一致，则结果是unknown 聚合函数 avg min max sum count group by 找出每个学院教师的平均工资 select dept_name avg(salary) as avg_salary from instructor group by dept_name 注意：在group by中出现的属性，必须在select中出现，不能出现其他属性（除了聚合函数） having语句 找出所有平均工资超过42000的学院 select dept_name, avg(salary) from instructor group by dept_name having avg(salary) > 42000 having语句中是在group by之后进行的 null值和聚合 select sum(salary) from instructor 上述语句忽略空值 如果没有非空值则查询结果是null 除了$count(*)$，所有聚合函数都忽略在被聚合属性上是空值的元组 嵌套子查询 where语句中的嵌套子查询 set成员 set比较 set基数 membership Find courses offered in Fall 2009 and in Spring 2010 select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id in (select course_id from section where semester='Spring' and year = 2010) Find courses offered in Fall 2009 but not in Spring 2010 select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id not in (select course_id from section where semester='Spring' and year=2010); 可以考察更多属性的membership select count(distinct ID) from takes where (course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year from teaches where teaches.ID=10101); comparison——\"some\" 找出收入高于生物学院的instructor select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name='Biology'; 等同于用some select distinct name from instructor where salary > some(select salary from instructor where dept_name='Biology'); comparison——all Comparison——'exists' 当子查询不是空集时，exists返回true 找出选了生物学院的所有课程的学生 select distinct S.ID, S.name from student as S where not exists((select distinct course_id from course where dept_name='Biology') except (select course_id from takes where S.ID=takes.ID)); Comparison——unique 考察子查询结果中是否存在重复元组，是则返回false，否则返回true 找出2009年最多开展一次的课程 select T.course_id from course as T where unique(select S.course_id from course as S where S.course_id=T.course_id and S.year=2009); from子句中的子查询 with语句 with子句提供了定义临时关系的方式，这个临时关系只能在当前语句中使用 例子：找出预算最多的院 with max_budget(value) as (select max(budget) from department) select department.name from deparment, max_budget where department.budget = max_budget.value 例子：找出总收入大于所有院平均总收入的院 with dept_total(dept_name, value) as (select dept_name, sum(salary) from instructor group by dept_name), dept_total_avg(value) as (select avg(salary) from instructor) select dept_name from dept_total, dept_total_avg where dept_total.value > dept_total_avg.value; select中的嵌套子查询 一个语句必须只得到一个值 例子：列出所有department和院中的教师数 select dept_name, (select count(*) from instructor where instructor.dept_name=department.dept_name) as num from department; 如果这个查询返回超过一个元组，则报错。 修改数据库 删除 插入 更新 条件语句 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch4.html":{"url":"database/ch4.html","title":"CH4","keywords":"","body":"CH4 views 某些情况下，不是所有用户都想看到整个逻辑模型。 创建方法 create view v as \"query expression\"是一个合法的SQL表达式，视图名是v Once a veiw is defined, the view name can be used to refer to the virtual relation that the view generates. A view defination causes the saving of an expression; the expression is substituted into queries using the view. 使用了视图的queris中，view会替换为expression create view faculty as select ID, name, dept_name from insturctor create view departments_total_salary(dept_name, total_salary) as select dept_name, sum(salary) from instructor group by dept_name; 使用view定义其他view create view physics_fall_2009 as select course.course_id, sec_id, building, room_number from course, section where course.course_id = section.course_id and course.dept_name='Physics' and section.semester='Fall' and section.year='2009' 使用上面的view创建其他view create view physics_fall_2009_watson as select course_id, room_number from physics_fall_2009 where building='Watson'; view展开为如下： create view physics_fall_2009_watson as (select course_id, room_number from (select course.course_id, building, room_number from course, section where course.course_id=section.section_id and section.semester='Fall' and section.year='2009') where building='watson'); view更新 向faculty视图中添加值 insert into faculty values('30765', 'Green', 'Music') 某些更新无法uniquely翻译 create view instructor_info as select ID, name, building from instructor, department where instructor.dept_name=department.dept_name 插入一行 insert into instructor_info values('1000', 'wzr', 'watson'); 如果一个建筑中有多个department，就无法确定这个老师是哪个院的，并且如果该建筑中没有department。 满足如下条件view可以 From语句中只涉及一个关系 select语句只包含属性名，不包含任何表达式、聚合函数和distinct 任何没有在select中列出的属性都可以设为null 没有group by和having 物化视图 Materialized Views 允许存储视图关系（物理上） 如果视图中使用的关系更新了，物化视图的结果就会过时 需要通过更新视图来维护视图 alter table table-name add constraint Integrity Constraints完整性约束 not null primary key unique check(P)，P是个谓语 not null name varchar(20) not null, budget numberic(12, 2) not null unique($A_1, A_2, ..., A_m$) 表示属性集A_1, A_2, ..., A_m构成候选码 与主键不同，候选码可以使null（控制不等于其他任何值） check子句 check(P)，关系中每个元组都必须满足谓词P check ( semester in ('Fall', 'Winter', 'Spring', 'Summer')) 参照完整性 referential integrity 保证一个关系中给定属性集上的取值也在另一个关系的特定属性集的取值中出现称为 referential integrity 令关系$r_1$和$r_2$的属性集分别为$R_1$和$R_2$，主码分别为$K_1$和$K_2$。如果$r_2$任意元组$t_2$，均存在$r_1$中元组$t_1$使得$t_1.K_1=t_2.\\alpha$，我们称$R_2$的子集$\\alpha$为参照关系$r_1$中$K_1$的外码（foreign key） 这种关系称为参照完整性约束（referential-integrity constraint）或子集依赖（subset dependency）。 $r_2$中$\\alpha$上的取值集合必须是$r_1$中$K_1$上的取值集合的子集 $\\alpha$和$K_1$必须是相容的属性集 $\\alpha$ 等于$K_1$ 二者属性数相同，且对应属性的类型必须相容 create table course( course_id char(5) primary key, title varchar(20), dept_name varchar(20) references department ) create table course ( ... dept_name varchar(20), foreign key(dept_name) references department on delete cascade on update cascade, ... ) 级联删除on delete cascade：如果删除department中的元组导致参照完整性被违反，则删除不被系统拒绝，course中参照了被删除元组的元组被删除 在插入一个人之前先插入爸爸和妈妈 先把爸爸和妈妈设为null，插入所有人之后在设置爸爸和妈妈 延迟约束检查 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch5.html":{"url":"database/ch5.html","title":"CH5","keywords":"","body":"第五章 高级SQL 有两个重点 使用程序设计语言访问数据库 如何允许数据库与普通程序交互，C还是JAVA 如何处理SQL和C、JAVA中数据类型的不同 如何处理被很多短时进程共享的数据库连接 三种不同类型的可编程SQL embedded sql API ODBC JDBC procedure SQL 函数和过程 Functions and Procedural Constructs 过程 Procedure 使用create procedure创建，使用call语句调用 procedure没有返回值但是可以通过修改参数供调用者稍后检查，它也可以生成结果集。 参数 proc_parameter: [IN|OUT|INOUT] param_name type 每个参数默认是IN参数，可以在参数名前面指定IN OUT 这个关键字（IN|OUT|INOUT）只对PROCEDURE有效 对于FUNCTION，参数都是IN，过程中有可能会改变这些值，但是修改不会对调用者产生影响 OUT参数会将值传送到调用者 INOUT参数由调用者进行初始化，传送一个值到procedure再返回给调用者，对参数的任何修改对调用者都会生效。 delimiter命令，设定分隔符。 delimiter //表示之后如果一行命令以//结束，则执行命令，否则不执行 函数 Function 使用create function使用起来类似内置函数。可以在表达式中调用，它会在表达式执行过程中返回一个值。 定义一个函数，返回一个院内教师人数 create function dept_count(dept_name varchar(20)) returns integer begin declear d_count integer; select count(*) into d_count from instructor where instructor.dept_name=dept_name return d_count; end 内容组成 复合语句：begin...end 可能包含多个SQL语句 returns——指出返回值的类型 return——指出返回值，作为函数调用的结果 SOL 函数实际上是泛化的参数化视图 BEGIN [statement_list] END dept_countfunction也可以procudure代替。 declare statement local variables conditions and handlers cursors declare var_name [, var_name] ... type[DEFAULT value] set variable = expr [, variable=expr]... create procedure sql (x varchar(5)) begin declear xname varchar(5) default 'bob'; declear newname varchar(5); declear xid INT; select xname, id INTO newname, xid from table1 where xname = xname; select newname; end; 流程控制语句 IF CASE LOOP ITERATE LEAVE LOOP WHILE REPEAT RETURN if create funtion xxxx (n INT, m, INT) returns varchar(50) begin declare s varchar(50); if n=m then set s = 'equal'; else if n>m then set s = 'greate'; else set s='less'; end if; end if; set s=concat(n, ' ', s, ' ', m, '.'); return s; end// delimiter ; case语句 case case_value when when_value then statement_list [when when_value then statement_list] [else statement_list] end case 或 case when search_condition then statement_list [when search_condition then statement_list] [else statement_list] end case delimiter | create procedure p() begin declare v int default 1; case v when 2 then select v; when 3 then select 0; else begin end; end case; | delimiter ; LOOP LOOP statement_list END LOOP ITERATE 只能在LOOP REPEAT和WHILE statements中使用，表示\"Start the loop again\" LEAVE 离开循环。 例子 create procedure doiterate(p1 INT) BEGIN l1: loop set p1 = p1 + 1; if p1 while [begin_label]while search_condition do statement_list end while end_label create procedure dowhile() begin declare v1 int default 5; l1: while v1 > 0 do ... set v1 = v1 - 1; end while l1; end repeat create procedure dorepeat(p1 INT) begin set @x = 0; l1: repeat set @x = @x + 1; until @x > p1 end repeat l1; end; cursor游标 mysql支持在存储程序中使用游标，只能单向遍历 create procedure curdemo() begin declare done int default false; declare a char(6); declare b, c int; declare cur1 cursor for select id, data from test.t1; declare cur2 cursor for select i from test.t2; declare continue handler for NOT FOUND SET done = truel open cur1; open cur2; read_loop: LOOP fetch cur1 into a, b; fetch cur2 into c; if done then leave read_loop; end if; if b create procedure curdemo() begin declare dont int default false; declare a char(16); -- 事先声明 declare b, c int; declare cur1 cursor for select id, data from test.t1; declare cur2 cursor for select i from test.t2; declare continue handler for not found set done = true; open cur1; open cur2; read_loop: loop fetch cur1 into a, b; fetch cur2 into c; if done then leave read_loop; end if; if b Condition handling 可以定义handlers，来应对诸如warning、exceptions或者特殊的条件，比如特定错误码 可以给特定条件设定名字并在handlers中引用 declare .. condition statement declare .. handler statement declare condition_name condition for condition_value declare continue handler for 1051 begin -- body of handler end; 通过声明条件的名字，handler的目的是更容易看到 declare condition declare no_such_table condition for 1051; declare continue handler for no_such_table; begin -- body of handler end; declare handler DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement handler_action: { CONTINUE | EXIT | UNDO } condition_value: { mysql_error_code | SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING | NOT FOUND | SQLEXCEPTION } create procedure handlerdemo() begin declare continue handler for sqlstate '23000' set @x2 = 1; set @x = 1; insert into test.t values(1); set @x = 2; insert into test.t values(1); set @x = 3; end triggers event insert delete update create trigger trigger-name trigger-time trigger-event on table-name for each row trigger-action trigger-time$\\in${BEFORE, AFTER} trigger-event$\\in${INSERT, DELETE, UPDATE} 两个值 old row：for deletes and updates new row：for inserts and updates 创建一个触发器，当雇佣新的雇员时更新deparment的总收入 delimiter | create trigger udpate_salary after insert on employee for each row begin if new.dno is not null then update deptsal set totalsalary = totalsalary + new.salary where dnumber = new.dno; end | delimiter ; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch7.html":{"url":"database/ch7.html","title":"CH7","keywords":"","body":"CH7 ER图 [toc] design process 第一个阶段是完整刻画未来数据库用户的数据需求 概念设计阶段选择数据模型 完整的概念模式还指明企业的功能需求。在功能需求规格说明（specification of functional requirement），用户描述将在数据上进行的各类操作（事务） 从抽象数据模型到数据库实现 逻辑设计logical design 物理设计physical design design approaches ER图 规范化理论 建模 ER数据模型的提出旨在方便数据库的设计，它是通过允许定义代表数据库全局逻辑结构的企业模式实现的 ER模型在将现实世界企业的含义和交互 映射到概念模型上非常有用 三个概念 实体集 联系集 属性 实体集 Entity set Entity是现实生活中区别于其他对象的事务 entity set是类型属性相同的实体的集合 实体由一组属性表示；即描述性属性。实体集的所有成员都拥有。 insrtructor=(ID, name, street, city, salary) course=(course_id, title, credits) 实体集属性的一个子集构成primary key，唯一标识（uniquely identify）集合中的成员 关系集 Relationship set Relationship是若干实体之间的联系 例子 advisor 描述性属性 descriptive attribute 属性也可以和联系集相关联 比如，advisor有一个时间 degree of relationship set 联系集的度 二元关系 binary relationship 涉及两个实体集的联系集 度>2的联系，一般联系都是二元的 映射基数 mapping cardinality 表示一个实体通过一个联系集能关联的实体的个数 对于二元联系，一定是如下 一对一 一对多 多对一 多对多 复杂属性 简单simple和复合compsite属性 单值single和多值multivalued属性 派生derived属性 冗余属性 弱实体集 考虑section，由 course_id, semester, year 和 sec_id唯一标识 显然，section实体与course实体相关，假设我们创建一个sec_course联系来联系section和course 弱实体集的存在依赖于另一个实体（标识 identifying）或属主实体集owner entity set。 我们使用标识实体和额外属性（discriminator 分辨符）来唯一标识弱实体，非弱实体集叫强实体集 section的分辨符是sec_id、year和semester existence dependent 弱实体集存在依赖于标识实体集 标识实体集拥有（own）弱实体集 ER图 实体集 矩形代表实体集 矩形中列出属性 下划线指出主码 联系集 菱形代表联系集 描述性属性 角色role 映射基数cardinality constraints 全部和部分参与 total and partial participation 全部参与 total participation 每个学生都必须有一个instructor 部分参与partial participation 某些实体可能没有参与联系集中的所有联系 有些instructor没有参与advisor 复杂属性的表示 instructor ID name —— 复合属性 frist_name middle_initial last_name address ——复合属性 street street_number street_name apt_number city state zip {phone_number} ——多值属性 date_of_birth age()——派生属性 弱实体集 ER图中，用双矩形表示weak entity set 分辨符（discriminator）用虚线下划线标出 联系集用双菱形标出 简化为关系模式 实体集和关系集可以统一表示为表示数据库内容的关系模式。 一个符合ER图的数据库可以由模式的集合表示 对于每个实体集和联系集，都有唯一的模式对应 每个模式有多个列，每个列有唯一的名字 reduction——表示实体集 Strong entity set reduces to a schema whith the same attribute 强实体集变成模式时属性名不变 student(ID, name, tot_cred) Weak entity set 变成一个表，包含标识强实体集的主键和分辨符 section(course_id, sec_id, sem, year) 复杂属性 复合属性：为每个子属性创建独立的属性 多值属性：对于多值属性M，实体集中不包含该属性，构建关系模式R，该模式包含一个对应于M的属性A。 instructor_phone(ID, phone_number) 映射 一对多和多对一联系集 many side是total participation的情况下，直接在many side添加one side的主码 instructor(ID, name, salary, dept_name) 对于一对一联系 任何一边可以作为many side 弱实体集 section(course_id, sec_id, semester, year) n元联系集 以三元联系集为例 最多一个箭头 如果超过一个箭头则有多重解释 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch8.html":{"url":"database/ch8.html","title":"CH8","keywords":"","body":"CH8 好的设计的特点Features of Good Relational Design A combined schema without repetion 没有重复的组合模式 更小的模式 对于inst_dept。decompose it into instructor and department dept_name是候选码 表示为函数依赖 dept_name → building, budget 在inst_dept中，因为dept_name不是候选码，building和budget可能会出现重复 不是所有的分解都是好的 lossy decomposition有损分解 如果有多个同名的kim，则无法分辨 lossless decomposition 无损分解 ⚛原子域和第一范式1NF domain is atomic if its elements are considered to be indivisible units 如果域中的元素是不可分割的称域为原子域 如果R的所有属性的域都是原子的，则称该关系模式是第一范式（first normal form, 1NF） goal目的——为下列内容设计一个理论 决定关系R是否是好的范式 当R不是good form时，把它分解成{$R_1, R_2, R_3...$}，其中 每个关系都是good form 分解必须是无损连接分解 理论基于 函数依赖 多值依赖 Functional Dependency Theory 合法关系集的约束 要求关系中有候选码 函数依赖是key的泛化 R是个关系模式 Relation Schema \\alpha \\subseteq R \\text { and } \\beta \\subseteq R 与码的关系 key 当$K\\rightarrow R$时，$K$是超码。 当$K\\rightarrow R$，并且不存在$\\alpha \\subset K, \\alpha \\rightarrow R$，则K是候选码 不存在K的子集，使得函数依赖$\\alpha \\rightarrow R$成立 Function Dependencies允许我们表达不能使用超码表达的约束 考虑如下模式 inst_dept(ID, name, salary, dept_name, building, budget) 使用函数依赖表示 $dept_name\\rightarrow building \\text{ } and \\text{ } ID\\rightarrow building$ we use funcional dependencies to 实例：判定关系的实例是否satisfies给定函数依赖集F satisfies：模式r满足函数依赖集F 模式：说明合法关系集上的约束。如果模式R上满足函数依赖集F的关系，则F在r(R)上成立 注意：一个关系模式的实例可能satisfy一个函数依赖即使这个函数依赖在模式上并不成立。 平凡trivial函数依赖 如果一个函数依赖在一个关系的所有实例上都成立，则它是平凡的 ID, name \\rightarrow ID \\\\ name \\rightarrow name 函数依赖集闭包 closure of a set of functional dependencies 给定函数依赖集F，可以推断出一些其他的函数依赖也成立 例如 $if \\; A \\rightarrow B \\; and \\; B \\rightarrow C$ 可以推出$A \\rightarrow C$ 能够从给定函数依赖集F推导出的所有函数依赖是F的闭包（closure） 写作$F^+$ $F^+$是F的超集 BCNF范式 消除所有基于函数依赖能够发现的冗余 具有函数依赖集F的关系模式R属于BCNF的条件是，对$F^+$中所有函数依赖$\\alpha \\rightarrow \\beta$，下列至少一项成立 是平凡的函数依赖 或者$\\alpha$是超码 数据库属于BCNF的条件是，构成该设计的所有关系模式都属于BCNF 将一个模式分解为BCNF 假设我们有一个关系模式R和非平凡函数依赖，不满足BCNF decompose it into $(\\alpha \\cup \\beta)$ $R-(\\beta - \\alpha)$ BCNF和依赖保留 Dependency Preservation 依赖保留，有时我们希望进行BCNF分解后，某些依赖仍然保留。 但是往往BCNF和依赖保留不能两全。 所以我们提出3NF，它比BCNF更弱。 3NF，第三范式 BCNF基础上再加一个条件 $\\alpha \\rightarrow \\beta$是一个平凡trivial的函数依赖 $\\alpha$是R的一个超码 $\\beta - \\alpha$中的每个属性都包含于R的一个候选码中 如果R满足BCNF则，R满足3NF 能确保每个模式都有保持依赖的函数依赖的3NF分解 规范化的goal 函数依赖理论 closure of a set of functional dependencies 逻辑蕴含 给定关系模式r(R)，如果r(R)的每一个满足F的实例也满足f，则R上的函数依赖f被r上的函数依赖集F逻辑蕴含 函数依赖集F的闭包是$F^+$ 我们可以通过反复使用 reflexivity自反律if $\\beta \\subseteq\\alpha$则$\\alpha \\rightarrow \\beta $ augmentation增广律：如果$\\alpha \\rightarrow \\beta$，则$\\gamma \\alpha\\rightarrow\\gamma\\beta$ transitivity传递律：如果$\\alpha \\rightarrow \\beta$并且$\\beta\\rightarrow\\gamma$则$\\alpha\\rightarrow\\gamma$ union合并律：如果$\\alpha \\rightarrow \\beta$并且$\\alpha \\rightarrow \\gamma$，则$\\alpha \\rightarrow \\beta \\gamma$ decomposition分解率：union逆命题 pseudotransitivity伪传递律：如果$\\alpha \\rightarrow \\beta$并且$\\gamma \\beta \\rightarrow \\delta$则$\\alpha \\gamma \\rightarrow \\delta$ 属性集的闭包 如果$\\alpha \\rightarrow B$，我们称属性B被$\\alpha$函数确定（functionally determine)。 要判断集合$\\alpha$是否是超码，需要设计一个算法，用于计算被$\\alpha$函数确定的属性集。 先判断是不是超码 再判断是不是候选码 用途 判断超码：先求$\\alpha^+$，看看是否包含R的所有属性 判断函数依赖是否holds 对于$\\alpha \\rightarrow \\beta$，check $\\alpha^+$中是否有$\\beta$即可 另一种计算$F^+$的方法，对任意$\\gamma \\subseteq R$找出$\\gamma^+$，对任意$S\\subseteq \\gamma^+$，可以输出一个函数依赖$\\gamma \\rightarrow S$ 正则覆盖 canonical cover 无关属性 extraneous attributes 考虑$\\alpha \\rightarrow \\beta$ in F 如果$A \\in \\alpha$，并且F逻辑蕴含$(F-{\\alpha \\rightarrow \\beta}) \\cup{(\\alpha-A) \\rightarrow \\beta}$ 如果$A\\in\\beta$，并且F逻辑蕴含$(F-{\\alpha \\rightarrow \\beta}) \\cup{\\alpha \\rightarrow (\\beta-A)}$ 则A是无关的 判断一个属性是否无关extraneous（使用属性集闭包） 对于F中的$\\alpha\\rightarrow\\beta$是否存在无关属性 $A\\in\\alpha$ 计算$({\\alpha}-A)^+$，使用F 判断其是否包含$\\beta$，有则A是无关属性 $A\\in \\beta$ 计算$\\alpha^+$，使用$\\mathrm{F}^{\\prime}=(F-{\\alpha \\rightarrow \\beta}) \\cup{\\alpha \\rightarrow(\\beta-A)}$ 判断其是否包含A，不包含则A是无关属性 正则覆盖canoncial cover $F_c$是F的正则覆盖，当 F逻辑蕴含Fc Fc逻辑蕴含F Fc中的函数依赖不包含无关属性 Fc中的每个函数依赖的左边都是唯一的 算法 适用union rule合并dependency 对剩下的去除无关属性 算法结束后，可能union rule需要再次适用。 无损分解 lossless decomposition 用关系代数说明 对于$R=(R_1, R_2)$，我们要求 r=\\prod_{R 1}(r) \\bowtie \\prod_{R 2}(r) $R_1$和$R_2$是属性集，可能有共同的属性 $\\bowtie$是自然连接 这样令R1和R2是R的分解，没有信息损失，该分解是无损分解 用函数依赖说明 如果以下函数任意一个属于$F^+$，则是无损分解 R_1 \\cap R_2 \\rightarrow R_1 \\\\ R_1 \\cap R_2 \\rightarrow R_2 也就是分解后一方含有另一方的超码 超码可以用属性集闭包判断 example 保持依赖 dependency perservation n个R，$R_i$的函数依赖集是$F_i$，如果 \\left(F_{1} \\cup F_{2} \\cup \\ldots \\cup F_{\\mathrm{n}}\\right)^{+}=F^{+} 则分解是依赖保留的 算法 分别对F中的函数依赖使用如下算法 这里的属性闭包是F下的 example 判断BCNF BCNF分解 3NF分解 BCNF不是依赖保持的 检测违反函数依赖的效率很重要 解决方法 定义一个更弱的范式 允许一定冗余 函数依赖可以在单独的关系中检验不用计算连接 design goals 关系型数据库设计 BCNF 无损分解 lossless join dependency preservation 如果不能达到，接收如下之一 缺少函数依赖 3NF var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch11.html":{"url":"database/ch11.html","title":"CH11","keywords":"","body":"CH11 不考大题，考选择 基本概念 索引机制用来加速访问数据 Search key搜索码：索引文件中用来查找记录的属性或属性集 index file: 索引文件由index entries索引项组成 索引文件一般比普通文件小很多 两种索引 顺序索引 ordered indices：搜索码按顺序存储 哈希索引 hash indices：搜索码使用哈希函数hash function均匀分布在桶buckets中 索引评估指标 evaluation metrics 访问类型 access type：能有效支持的访问类型 访问时间 access time: 在查询中使用该技术找到一个特定数据项或数据项集所需的时间 插入时间 insertion time: 插入一个新数据项所需的时间 删除时间 deletion time 空间开销 space overhead 顺序索引 clustering index/primary index 聚集索引/主索引 搜索码一般是主码，有时也不是。 non-clustering index/secondary index 搜索码指定的顺序与文件中记录的物理顺序不同的索引。 索引顺序文件 稠密dense索引和稀疏sparse索引 稠密索引 dense index 在稠密聚集索引中， 文件中的每个搜索码值都有一个索引项。 索引项包括 搜索码值 指向具有该搜索码值的第一条数据记录的指针 稠密非聚集索引 索引必须存储指向所有具有相同搜索码值的记录的指针列表 只包含某些搜索码值 稀疏索引 sparse index：只为搜索码的某些值建立索引项 必须是聚集索引 To locate a record with largest search-key value Search file sequentially starting at the record to which the index record points. 找到块的第一个搜索码（找到记录中小于该搜索码的最大搜索码Find index record with search-key value 从这个index record所指的文件记录开始顺序搜索 dense和sparse的比较 更少的空间和插入删除的维护开销 sparse可以指向data block的第一个 辅助索引 secondary indices Index record points to a buckert that contain pointers to all the actual records with that particular search-key value. 必须是dense index 聚集索引和辅助索引 为记录搜索提供了实质性的好处但是 数据库被修改，每个索引都要更新。 使用聚集索引进行顺序扫描很高效，但是在辅助索引上使用顺序扫描消费很高 每个记录有可能在磁盘的新块中 多级索引 把primary index当做一个磁盘上的顺序存储文件，在它上面构建索引。 outer index——聚集索引的稀疏索引 inner index——聚集索引文件 索引更新：删除 如果删除的记录是文件中唯一的记录，则搜索码从索引中删除 （单层single-level）索引项删除 稠密索引：搜索码的删除类似文件记录的删除 稀疏索引： 如果搜索码在索引中存在索引项，则用下一个搜索码替代 如果下一个搜索码有索引项，则原索引项删除 索引更新：插入 单层索引 稠密索引：如果搜索码在索引中没有，则插入一个 稀疏索引：如果如果索引存储了文件的所有块，则不需要改变任何索引；如果创建了新块，则需要更新索引——将新块的第一个搜索码插入到index中 多层索引的插入和删除 单层索引的简单扩展 辅助索引 如果搜索码是非候选码，连续值可能不是连续存放的。则可以用辅助索引。 B+树🌲 背景 索引顺序文件的缺点 随着文件的增大，索引性能会下降，因为会创建溢出的块 需要定时重组文件 B+树索引文件的优点🌲 在插入和删除时，面对小的局部的修改可以自动重组。 不需要重组文件来维护性能 B+树缺点 额外的插入和删除性能开销和空间开销 定义 满足如下条件 从root到所有叶子节点的长度一致 每个非根节点或非叶子结点含有$\\lceil n / 2\\rceil 到 n$个孩子结点 叶子节点包含$\\lceil (n-1) / 2\\rceil 到 n-1$个值 如果子节点不是叶子，至少有两个孩子 如果子节点是叶子，可以有0~（n-1）个值 查询 处理重复 handling duplicates 如果存在重复的搜索码 在叶子和内部节点 不能保证$K1{n-1}$ 但是可以保证$K{1} \\leq K{2} \\leq K{3} \\leq \\ldots \\leq K{n-1}$ $P_i$指向的子树 均$\\leq K_i$，但是不一定都小于$K_i$ 假设搜索码V在两个叶子节点$Li$和$L{i+1}$中都有，那么父节点$K_i$一定等于V 查询方法 即使$V=K_i$，也遍历$P_i$ 到达叶子节点后，检查C是否值都小于V 是则令C等于C的右兄弟 插入操作 找到搜索码应该出现的叶子节点 如果搜索码已经有了 向文件中添加记录 如果需要，向桶中添加指针 如果没有 2.a 2.b 如果叶子结点还有空间，则直接把键值对插入到叶子结点 否则，分裂节点 分裂的方法 对节点按顺序排列，把前$\\lceil \\frac{n}{2} \\rceil$个键值对放到原始节点中，剩下的放到新节点中 新节点为p，令k为p中最小搜索码。把（k,p)插入（insert）到父节点 最差情况下，有可能根节点需要进行分裂，进而使高度+1 如果一个非叶子节点已经满了 看PPT和书吧。太理解性了 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch14.html":{"url":"database/ch14.html","title":"CH14","keywords":"","body":"数据库第十四章 Transaction concept 一个transaction是一个程序执行的单元unit， sql语句集 存储过程 由高级程序设计语言初始化 由begin transaction和end transaction分隔 example ACID properties Atomcity原子性：事务的所有操作在数据库要么全部正确执行，要么完全不反映 Consistency一致性：隔离执行事务时，保持数据库的一致性 Isolation隔离性：多个事务可能并发执行事务之间感受不到其他事务的并发执行， Durability持久性：一个事务成功后，对数据库的改变必须是永久的 事务状态 Active: 初始状态，事务执行时保持这种状态 Partially committed: 最后一条语句结束后的状态 Failed: 发现正常的执行不能继续后 Aborted:中止的 事务回滚并且数据库已经恢复到事务开始之前的状态 出现这个状态之后，有两个选择 重启事务 kill the transaction Committed: 成功完成后。 并发执行 Concurrent Executions 系统允许多个事务并行 处理器和磁盘利用率的提高，使得事务吞吐率提高 等待时间减少：短事务不必等待长事务 并发控制机制 concurrency control schemes 控制事务之间的交互，防止他们破坏数据库的一致性 调度 schedules schedule——表示指令在系统中执行的时间顺序 一个事务集的调度必须包含这些食物的所有指令 必须保持指令在各个事务中出现的顺序 一个成功完全执行的事务会在最后一条指令后执行一个commit指令 执行失败的事务会在最后一条指令后执行一条abort指令 使用的符号 Database由object(X, Y, Z)组成， Tranactions标记为$T_1, T_2$ 每个transaction在主存中包含局部变量集（其他事务不可访问） 每个事务可以用read()和write()访问数据库 read()命令将数据库object读取到局部变量中 write()命令可以将局部变量写入数据库 Local varibale for read() & write() will not be shown if the context is clear, or if it is unimpoertant 对objects的操作和计算智只能在局部变量上进行，比如，X=X+1不对，但是a1 = a1 + 1可以。 某些情况下，局部操作不展示 Serializable schedule 考虑两个事务 财产转移 利润 对于串行调度serial schedules 如果dividend之前进行transfer X：$100 \\rightarrow 50 \\rightarrow 50.5$ Y: $200 \\rightarrow 250 \\rightarrow 252.5$ transfer之前dividend X：$100\\rightarrow 101 \\rightarrow 50.5$ Y: $200 \\rightarrow 202 \\rightarrow 252$ 两种情况下，$X+Y=300$ 但是如果按照如下方式调度 这种情况下 $X: 100\\rightarrow 50 \\rightarrow 50.5$ Y: $200\\rightarrow 202\\rightarrow 252$ X+Y=302.5 什么造成了上面的问题 资源竞争？ 交叉执行？ 可串行化 serializable 并发执行中，通过保证所执行的任何调度的效果都与没有并发执行的调度效果一样，我们可以确保数据库的一致性。 调度应在某种意义张等价于一个串行调度 四种情形 考虑两条连续指令I,J。 I=read(Q), J=read(Q) 次序可交换，无论怎么读值都一样 I=read(Q),J=write(Q) 不可交换 I=write(Q), J=read(Q) 不可交换 I=write(Q), J=write(Q) 不可交换 总结 只有在两条指令都是读的情况下，执行顺序才无关紧要。 confict 当两条指令在相同数据项上操作，且其中存在write指令，则两个指令是conflict的 考虑之前的调度 尝试对指令执行次序进行交换 （4）指令可以逐步与（i，ii, iii）交换，直到 （5）（6）指令思路相同，（5）与（i，ii，iii）均不冲突，所以可以移动到i之前执行 再看这个调度 （3）无法与i交换；4无法与vi交换 所以不可串行化 总结 一个调度如果可以转变为串行调度则是好的调度（可以达到隔离性） 反之，则不好 冲突可串行化conflict serializable 若一个调度S与一个串行调度冲突等价，则称调度S是冲突可串行化的 优先图 precedence graph 点是事务的有向图 边的含义 $T_i\\rightarrow T_j$表示一下三个条件之一 i写j读：$T_j$执行read(Q)之前$T_i$执行write(Q) i读j写：$T_j$执行write(Q)之前$T_i$执行read(Q) i写j写 如果存在边$T_i\\rightarrow T_j$，则任何等价于S的调度$S^{\\prime}$中，$T_i$必出现在$T_j$之前 冲突可串行化的判断 当且仅当优先图没有环时，调度是冲突可串行化的。因此要判定冲突可串行化，需要构造优先图并调用一个环检测算法。 serializability order串行化顺序 可以通过拓扑排序（topological sorting）得到。 由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。 选择一个入度为0的顶点并输出之； 从网中删除此顶点及所有出边 一般可以获得多个线性顺序。 该调度不可串行化 事务隔离性和原子性 可恢复调度recoverable schedule 如果事务$T_j$读取了前序事务$T_i$写入的数据，那么$T_i$的commit操作必须在$T_j$的commit之前出现 例如 如果$T_8$需要abort，$T_9$将已经读了A并且已经提交无法取消。所以该调度属于不可恢复调度 级联回滚 cascading rollbacks 单个事务失败会导致一系列事务回滚。考虑如下事务，假设还没有事务已经commit 如果$T_{10}$失败了，则T11和T12都要回滚 这样有可能导致大量工作的回滚。 无级联调度 cascadeless schedule 对每对事务$T_i$和$T_j$，如果j读取了i写的数据项，则i应该在j的读操作之前commit。 容易验证，每个无级联调度也都是可恢复的调度 Concurrency control并发控制 数据库提供了一种机制保证所有可能的调度都满足 冲突可串行化 可恢复并且最好是无级联的 同一时刻只有一个事务可以执行的策略无法实现高并发性 并发控制机制在它们允许的并发量和它们产生的开销之间进行权衡 在调度执行之后检验冲突可串行化已经晚了 目标：提出能够保证可串行化的并发控制协议 低等级的一致性 某些应用允许一定的低一致性，他们允许非串行的调度 一个read-only的事务，他试图获取所有账户总余额的近似值 为查询优化计算的数据库统计信息可以是近似的 用精度换性能 事务隔离性级别 可串行化 sericalizable 默认的 可重复读的 Repeatable read 只允许读取已提交的数据。 一个事务两次读取一个数据项期间，其他事务不能更新该数据。该事务不要求与其他事务可串行化。 已提交读 Read committed 只允许读已提交的数据，但不要求可重复读。事务两次读取同一数据期间可能数据已经被修改并提交 未提交读 read uncommitted 允许度未提交的数据，最低级的。 都不允许dirty write 即如果一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作 某些数据库并不保证默认可串行化 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/CH15.html":{"url":"database/CH15.html","title":"CH15 并发控制","keywords":"","body":"数据库第十五章 Lock-based protocol lock 锁是一种控制对数据项并发访问的机制 数据项可以在两种模式下被锁 排他的exclusive(X)mode：如果事务T获得了数据项Q上的排它锁，可以读写 共享的shared：如果事务T获得了数据项Q上的共享锁，则T可读但是不能写 程序猿向并发控制管理器concurrency-control manager发出锁请求。事务只有在请求得到授权后才能继续 锁相容性矩阵 lock-compatibility A transaction may be granted a lock on an item if the requested lock is compatible with locks already held on the item by other transactions. 任何时候，一个数据项可以同时使用任意数量的共享锁 此后的排它锁请求必须一直等到所有共享锁释放 当有X锁时，不能再使用更多的任何锁 如果不能授予锁， 发送请求的事务就等待，直到所有其他事务使用的不相容的锁被释放掉，才能授予该锁 例子 展示A+B 上述方法不足以保证可串行化。如果A和B在ulock(A)和lock-s(B)之间被修改了，则展示出的和会不正确 locking protocol是所有事务在请求和释放锁时遵守的规则集 locking protocol限定了可能的调度集 自动获取锁Automatic Acquisition of Locks 事务$T_i$处理标准 read/write指令时无需显式使用锁调用指令 read(D) if Ti has a lock on D then read(D) else begin if necessary wait until no other transaction has a lock-X on D // 这里只需要确定其他事务没有X锁就行，自己可以有 grant Ti a lock-S on D read(D) end write(D) if Ti has a lock-X on D then write(D) else begin if necessary wait until no other transaction has a lock on D if Ti has a lock-S on D then upgrade lock on D to lock-X else grant Ti a lock-X on D 所有锁在commit或abort后都释放 The two-phase lockign protocol两阶段锁协议 这个锁协议保证了冲突可串行调度 增长阶段 growing phase 缩减阶段 shrinking phase Deadlocks 考虑如下部分调度 不难看出，最后$T_3$和$T_4$都不能继续执行了。 为了进行下去，$T_3$和$T_4$中的一个应该回滚令其锁释放 两阶段锁无法保证无死锁 饥饿 例如：某事务可能在等待某X-lock请求，但是一系列其他事务不断被授予S-lock，这个事务一直得不到X-lock 并发控制管理器可以designed to prevent starvation 大多数封锁协议中存在潜在死锁 当一个死锁发生时，有可能会发生级联回滚 两阶段锁也有可能会发生级联回滚。为了避免，使用strict two-phase locking一个事务必须持有所有的X-lock，直到commit/aborts Rigorous two-phase locking：事务的所有锁都要一直持有，直到commit/abort 锁的实现 lock manager可以实现为一个进程，从事务接收消息并反馈消息。 针对锁请求消息返回 授予锁消息 事务回滚消息 lock manager维护一个lock table来记录被授予的锁和待办的锁 锁表通常实现为内存中的哈希表，索引以被上锁的数据项的名字作为索引项 死锁处理 定义 如果有一个事务集，其中的所有事务都在等待另一个该事务集中的事务，那么该系统死锁 死锁预防 deadlock prevention 死锁预防协议保证系统永远不会进入死锁状态。例如 要求事务在执行前，对所有数据项上锁（预声明） 有两个缺点 事务开始前通常很难预支哪些数据需要封锁 数据项使用率低，有可能许多数据项长时间封锁却用不到 通过对加锁请求进行排序，偏序 每当有可能导致死锁时，进行事务回滚而不是等待加锁 wait-die策略——非抢占式 当事务Ti申请的数据项当前被Tj持有， 仅当Ti时间戳小于Tj的时间戳时，Ti等待， 否则Ti回滚。 wound-wait策略——抢占式 当事务$T_i$申请的数据项当前被$T_j$持有 $T_i$的时间戳大于$T_j$的时间戳时，$T_i$等待。 否则，$T_j$回滚 这两种方法均会发生不必要的回滚 锁超时 lock timeout 申请锁的事务至多当代一段给定的时间若此期间未授予锁，则该事务超时，回滚并重启。 死锁不可能发生 实现简单，但是有可能发生饥饿，不容易确定合适的超时时间 死锁的检测和恢复 如果系统不能保证不产生死锁，则系统必须采用检测和恢复机制。 wait-for等待图 死锁可以用等待图精确描述，由G=(V,E)组成 V：点集，对应所有事务 E：边集 如果存在$T_i \\rightarrow T_j$成立，则表示$T_i$在等待$T_j$释放数据项 如果等待图有环，则系统处于死锁。必须使用死锁检测算法来寻找环。 检测到死锁后 某些事务回滚，选一个代价最低的作为受害者 回滚多少 Total rollback，abort and restart 更高效的做法：只回滚需要的的距离 如果某个事务总是称为受害者，则会出现饥饿 将回滚的次数作为代价的考量来避免饥饿。 基于时间戳的协议 时间戳 对系统中每个事务$T_i$，把唯一一个时间戳和它相联系。此时间戳记为TS(Ti)。 两种方法 使用系统时钟（system lock）作为时间戳 使用逻辑计数器（logical counter）作为时间戳，每赋予一个时间戳，计数器增加计数，事务的时间戳等于该事务进入系统时的计数器值 时间戳决定了串行化顺序 每个数据项与两个时间戳值相关联 W-timestamp表示成功执行write(Q)的所有事务的最大时间戳 R-timestamp表示成功执行read(Q)的所有事务的最大时间戳 时间戳排序协议 保证任何有冲突的read和write操作按时间戳顺序执行。 $T_i$发出read(Q) 若$TS(T_i) 若$TS(T_i)\\geq W-timestamp(Q)$，则执行read操作，R-timestamp(Q)设置为它与TS(Ti)的最大值 $T_i$发出write(Q) 若$TS(T_i) 若$TS(T_i) 其他情况下，系统继续执行，将$W-timestamp(Q)$设置为$TS(T_i)$ 回滚后，Ti被系统赋予新的时间戳 Thomas写规则 多版本机制 multiversion schemes 时间戳版本 多版本机制保留老版本的数据项来提高并发性 多版本时间戳排序 多版本两阶段锁协议 每个成功的write都会导致数据项的新版本 使用时间戳来标记版本 不保证无级联性和可恢复性 两阶段锁 对只读事务和更新事务加以区分 更新事务执行强两段锁协议，即持有他们直到事务结束。因此，他们可以按提交的次序串行化。数据项的每个版本有一个时间戳（ts-counter），这个计数器在提交处理时增加计数。 只读事务，开始执行前数据库系统读取ts-counter的当前值来作为该事务的时间戳。只读事务执行时按照多版本时间戳排序协议。因此Ti发出read（Q)时，返回值是小于TS(Ti)的最大时间戳版本的内容。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/CH16.html":{"url":"database/CH16.html","title":"ch16","keywords":"","body":"CH16 恢复系统 错误分类 Failure Classification 事务错误 逻辑错误 由于内部错误事务无法完成 系统错误 稳定存储器 多个非易失存储介质上以独立故障模式复制所需信息，以受控方式更新信息。 数据访问 数据库系统常驻非易失性存储器，任何时间都只有数据库的部分内容在主存中。 日志记录 log，最广泛的记录数据库修改的结构。 日志是日志记录（log record）的序列。它记录数据库中的所有更新活动。 更新日志记录update log record描述一次数据库写操作 数据标识（transaction identifier) 数据项标识（data-item identifier） 旧值（old value） 新值（new value） 一个更新日志记录表示为，表示事务T_i对数据项X_i进行了一个写操作，写操作前X_i的值是V1，之后是V2。 还有其他几个 操作 每次事务执行写操作时，必须在数据库修改前建立该次写操作的日志记录并把它加到日志中。 一旦日志记录已经存在，就可以根据需要将修改输出到数据库中，并且有能力撤销输出到数据库中的修改。 日志必须放到稳定存储器中。 并发控制和恢复 有了并发事务，所有事务共享一个磁盘buffer和一个日志 一个buffer block可以包含一个或多个事务更新的数据项 假定如果事务T_i已经修改了一个item，其他事务必须等到T_iabort或者commit后才能修改相同的item 未提交事务的更新对其他事务不可见 否则如果T1更新了A，T2又更新了A并提交，然后T1abort了 可以通过严格两阶段锁strict two-phase locking 不同事务的日志记录可能穿插在log中 恢复 当从错误中恢复时 T_i需要undo，如果 日志包含T_i, start> 但是不包含commit或abort redo，如果 包含start 包含commit和abort 注意，如果事务T_i之前undo过， 例子 检查点checkpoint redo和undo事务记录可能会非常慢 整个log的读取非常耗时 我们可能会进行非必要的redo，有些食物已经将他们的更新输出到了数据库上 通过定期periodically执行检查点来简化恢复过程 把当前主存中所有日志记录输出到主存上 把所有修改过的buffer块输出到磁盘上 写一个日志记录到稳定存储器，L是检查点对应时间还在活跃的事务的 检查点执行过程中不允许任何更新动作。 恢复 恢复过程中只需要考虑检查点之前的most recent 事务T_i以及T_i之后的事务 从log末尾向前扫描来寻找最近的 只有在L中或检查点之后的事务需要redo或undo 检查点之前commit或abort的事务已经将更新输出到了稳定存储器上 例子 恢复算法 logging : at transaction start 每次更新 事务结束时 T_i, abort>事务取消时 事务回滚 回滚T_i 从后向前扫描日志对于T_i的每个格式为日志记录 undo: 将V_1写给X_j 写一个log record（注意，只写三项） 称作补偿日志记录 compensation log records 一旦找到，停止扫描，写日志 出错回滚(两阶段) redo phase undo phase redo phase 找到最后一个记录，设置undo列表L 从检查点向末尾扫描 每当找到一个\\text { or }，redo undo phase 从后往前扫描 当找到并且其在undo-list中执行undo操作 将V_1写给X_j 写一个log record 找到，并且T_i在undo_list中 写一个log record remove T_i from undo_list 当undo_list为空时，停止 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/about.html":{"url":"computer-network/about.html","title":"计算机网络","keywords":"","body":"《计算机通信与网络》课程总复习知识点 配套《数据通信与网络(Forouzan第四版)》 2021年12月 第一部分 概述 第1章 绪论 数据通信的概念及模型 数据流 连接类型和拓扑结构 网络分类 协议和标准 第2章 网络模型 层次结构、层间接口和封装 OSI参考模型的概念和各层功能 TCP/IP*协议簇和各层的功能 物理地址、逻辑地址和端口地址（何时改变？） 第二部分 物理层和介质 第3章 物理层 数字信号：基带传输、低通通道、宽带传输的概念 传输减损：衰减、失真、噪声和信噪比的概念 数据速率限制：奈奎斯特速率、香农容量定理 性能：带宽、吞吐量、信道利用率、延迟、传播时间、传输时间、排队时间、带宽与延迟的乘积的概念 第4章 数字传输 线路编码：数据元素、信号元素、数据速率、信号速率、最小带宽、最大数据速率、直流分量、自同步 线路编码方案：单极性编码（NRZ）、极性编码（NRZ-L和NRZ-I）、归零码（RZ）、双相码（Manchester和Differential Manchester）、双极性编码（AMI和伪三进制码）、 脉码调制PCM：采样（采样率）、量化等级、量化误差 Delta调制的概念 传输模式：异步传输、同步传输、并行传输、串行传输的概念 第5章 模拟传输 比特率和波特率 数字到模拟转换： `ASK的概念及ASK的带宽 FSK的概念及BFSK的带宽 PSK、BPSK、QPSK和QAM的概念 模拟信号调制： AM、FM和PM的概念 AM带宽、FM带宽和PM带宽 第6章 带宽利用 复用：FDM、同步TDM、统计TDM和WDM的概念 数字层次、T1载波、E1载波 波分和码分的概念 扩频：FHSS和DSSS的概念 第三部分 数据链路层 第10章 检错与纠错 差错的类型 块编码 差错检测的方法 纠错的概念与方法：汉明距离、最小汉明距离 线性块编码：线性块编码的距离、简单奇偶校验编码、两维奇偶校验编码、汉明码 循环冗余编码CRC（不包含硬件实现）、CRC的检错能力分析（检测单个位差错、两个独立的位差错、奇数个差错、突发性差错） 校验和及其计算方法 第11章 数据链路控制 组帧 流量控制和差错控制的概念 停止等待ARQ、后退N帧ARQ和选择重发ARQ HDLC 第12章 多路访问 随机访问：纯ALOHA、时隙ALOHA、CSMA、CSMA/CD（最小帧长）、CSMA/CA 受控访问：预约、轮询、令牌环 第13章 有线局域网：以太网 IEEE标准：LLC和MAC 标准以太网的MAC子层：帧格式、MAC地址、最短帧长、编码和解码、10Base5、10 Base 2、10 Base -T、10 Base -F 桥接以太网、交换式以太网、全双工以太网 快速以太网：MAC子层、拓扑结构、100Base -TX、100Base-FX、100Base –T4 千兆以太网：MAC子层、拓扑结构、1000Base -SX、1000Base-LX、1000Base –CX 第14章 无线局域网 WLAN体系结构与IEEE 802.11标准 802.11 MAC子层、帧结构、CSMA/CA* 802.11 物理层、寻址方式、隐蔽终端和暴露终端 第15章 连接局域网、主干网和虚拟局域网 连接设备：无源集线器、中继器、有源集线器、网桥、透明网桥、生成树、二层交换机、路由器、三层交换机（补充）、网关、冲突域与广播域 虚拟局域网的概念及划分方法 第四部分 网络层 第19章 逻辑寻址 IPv4地址：A、B、C、D和E类地址、掩码、子网和超网的概念 子网划分、子网的地址范围、地址聚合 NAT的概念 IPv6地址 第20章 IP协议 IP分组（数据报）的格式 分片(Identification、Flags、Fragmentation offset）、何处分片和重装 MTU IPv6分组格式 下一个头部相关 IPv4到IPv6的过渡 双协议栈 隧道技术 头部转换 第21章 地址映射、差错报告和多播 ARP：ARP的概念、功能、分组格式、封装、4种操作 DHCP的概念 ICMP：ICMP的概念、报文格式、差错报告、Ping* IGMP的基本概念 第22章 传递、转发和路由选择 转发技术与转发过程 路由表、地址聚合和最长掩码匹配 Dijkstra算法和Bellman-Ford* 算法 单播路由协议：AS的概念、域内、域间路由选择协议、RIP协议路由表生成的过程、OSPF协议的原理 多播的概念和多播路由（了解） 第五部分 传输层 第23章 UDP、TCP和SCTP 端口、套接字 UDP协议：UDP协议的概念、数据报结构、校验和的计算、UDP的操作 TCP：TCP的特点与服务、段格式、三次握手（建立连接和拆除连接）、TCP流量控制（信贷滑窗协议）、TCP差错控制 TCP有关字段和序号（SYN、ACK、seq、ack*）、段序号、字节编号 第24章 拥塞控制和服务质量 TCP拥塞控制（慢启动、拥塞避免、拥塞检测） 发送窗口=min（接收窗口rwnd，拥塞窗口cwnd） 第六部分 应用层 第25章 域名系统 DNS*的工作原理 域名空间 通用域、国家域和反向域 域名解析 DNS报文 第26章 远程登录、电子邮件和文件传输 Telnet的基本概念 电子邮件：电子邮件的架构、邮件报文、SMTP和MIME、POP3和IMAP 文件传输：FTP的架构、FTP的连接、FTP的传输方式、FTP的端口 第27章 万维网与超文本传输协议 URL、Cookies的概念 HTTP的概念、报文结构、HTTP操作 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH1.html":{"url":"computer-network/CH1.html","title":"CH1","keywords":"","body":"总线型 总线拓扑结构是多点连接，由一条较长的线缆作为主干来连接网络上的所有设备 电信（telecommunication）在一定距离上的通信 数据：以任何格式表示的信息，该格式需要创建和使用数据的双方达成共识 数据通信，在两台设备之间通过诸如线缆的某种形式的传输介质进行的数据交换 组件：报文 发送方 接收方 传输介质 协议 数据表示：文本 数字 图像 音频 视频 数据流：单工 半双工 全双工 一、五个组件 报文（message） 发送方 sender source 接收方 receiver destination 传输介质 transmission medium 协议 protocol 管理数据通信的一组规则，表示通信设备之间的一组约定 二、数据的表示 三、数据流 三种 四、网络 network是通信链路连接起来的设备（节点）的集合，一个节点是计算机，打印机或者能够发送、接收由该网络上的其他节点产生的数据的任何其他设备 五、分布式处理 将任务给多台计算机 集中式的反义词、分散的 当前通信系统的流行处理方式 六、网络准则 性能： 吞吐量 throughput 延迟 delay latency 可靠性 Reliablity 故障出现的频率 故障恢复所花费的时间 灾难中的健壮性 安全性 Security 保护数据免受未授权的访问 传输过程中免受攻击 七、物理结构 Physical Topoloy 链路 Link 将设备由一台设备传输到另一台设备的通信通路 连接类型 点到点（point to point）： 多点连接 （multipoint connection, multidrop connection）： 八、拓扑结构 环形 混合型拓扑结构 九、网络模型NetworkModel OSI Open System Interconnection 模型：7层模型 Internet模型：5层模型 十、网络分类 按地理范围划分 名称 英文 缩写 局域网 Local area network LAN 广域网 Wide area network WAN 城域网 metropolitan area network MAN 个人网 personal area network PAN 十一、因特网 internet：互联网：两个或多个可以互相通信的网络 Internet：因特网，I大写 因特网层次结构 十二、协议和标准 协议是规则的同义词，然后讨论标准。 十三、协议 协议 通信内容 通信方式 通信时间 要素 语法syntax 语义semantics 时序timing 标准：达成一致的规则 十四、标准的分类 事实上的标准，TCP/IP 法定的标准，OSI/RM var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH2.html":{"url":"computer-network/CH2.html","title":"CH2","keywords":"","body":"第二章网络模型 ISO是组织，OSI是模型 OSI模型（7层） 跨系统 可理解并设计一个灵活、健壮和可互操作的网络体系结构 OSI模型提供了一个可以用来进行网络系统设计的层次化框架，由7个相互独立但又有互相关联的层次组成 物理层 物理介质上传输位流所需的功能，定义了接口与传送戒指的机械和电气特性 物理层负责位从一跳到另一跳的传递 数据链路层 将物理层的数据无差错地传递给网路层 负责将帧从一跳传递到下一跳 跳到跳的传递 网络层 负责将各个分组从源地址传递到目的地址 逻辑寻址 路由选择 从源到目的地址 物理层和数据链路层都是一跳到下一跳 传输层 报文，从一个进程到另一个进程 报文 进程到进程 端到端可靠运输 服务访问点SAP/端口Port（service access port） 分段Segment和组装 连接控制 流量控制 差错控制 一个报文在进程间的可靠传递 会话层session 对话控制 同步 同步点 经常在套接字中使用 经常在套接字中使用 表示层 翻译 加密 压缩数据 应用层 向用户提供服务 二、TCP/IP协议族 一个是模型 一个是协议族 OSI之前开发的，并不与OSI模型的各层严格对应 三、四个层次 物理层 数据链路层 网络层 传输层 应用层 所谓应用层占据了后三层 传输层是 TCP UDP STCP 网络层是IP（加上其他配套协议） 四、PDU 协议数据单元 PDU是指对等层次之间传递的数据单位。 物理层的——数据位bit 数据链路层——数据帧 网络层——数据报 传输层——数据段 更高层次——数据 五、一些协议 六、寻址 TCP/IP协议簇的应用网络中使用4层地址 物理地址 逻辑地址 端口地址 专用地址 Specific address 各层与地址的关系 七、物理地址 别名 链路地址 硬件地址、 MAC地址 局域网或广域网中定义的节点地址。 包含在数据链路层的帧中 最低级的地址 长度和格式可变，与网络有关。通常以以太网使用的网卡上的48位物理地址。 八、IP地址🌰 图显示了由两个路由器连接三个局域网的互联网的一部分。为了相互的连接，每个设备(计 算机或者路由器)都有一对地址(物理地址和逻辑 地址)。在这个例子中，每台计算机只与一个链路相连，因此只有一对地址。然而，每个路由器和三个网络相连(在图中只显示了两个)。因此每个路 由器有三对地址，一对地址对应一个连接。 九、端口地址🌰 两台计算机通过网络进行通信。 发送方计算机有三个进程正在进行，分别使用端口 a，b，c。同时，接收方计算机有两个进程正在进 行，端口地址分别是 j 和 k。在发送方计算机中的 进程 a 需要和在接收方计算机的进程 j 进行通信。 尽管从跳到跳物理地址会改变，但是逻辑地址和端 口地址从源地址到目的地址均保持不变。 跳到跳过程中物理地址改变，逻辑地址不变 十、专用地址 面向对象应用被设计为专用地址 mail://xxxx ftp://xxxx var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH3数据与信号.html":{"url":"computer-network/CH3数据与信号.html","title":"CH3数据与信号","keywords":"","body":"[toc] CH3 数据和信号 物理层通过传输介质以电磁信号的形式传输数据。 数据要进行传输，必须将其转换为电磁信号 模拟和数字 数据和信号可以是模拟analog的，也可以是数字digital的 数据可以是模拟的也可以是离散的 模拟数据是连续的，采用连续值 数字数据有离散状态，采用离散值 信号signal可以是模拟的也可以是数字的 模拟信号在一定范围内有无穷多个值 数字信号只能有有限个数值 周期信号和非周期信号 模拟和数字信号有两种形式 周期信号 periodic signal 非周期信号 nonperiodic signal 往往使用周期模拟信号和非周期数字信号 周期模拟信号：需要更少的带宽（CH5） 非周期数字信号：可以表示数据的变化 周期模拟信号 简单类型： 正弦波sine wave 复合类型：多个正弦波信号组成 正弦波 由以下三个参数决定 峰值振幅 peak amplitude 频率 frenquency 相位 phase 峰值振幅 最高强度的绝对值，单位v，伏特 周期和频率 f=\\frac{1}{T} 频率单位Hz。 如果信号在短时间内发生变化，则频率高，否则频率低 两个极端 信号持续不变化：频率是0 瞬间变化：频率无穷大。 相位phase 波形相对于时间0的位置 波长wavelength 一个简单信号在一个周期能传播的距离 波长=传播速度\\times 周期 \\\\ \\lambda=\\frac{c}{f} 时域和频率 时域图time-domian plot显示了信号振幅随时间的变化。 为了表示振幅与频率的关系。可以用频域图frequency-domain plot 单个峰值，表示一个完整的正弦波 复合信号 复合信号composite signal由许多正弦波构成 单一正弦波在数据通信中没有用户，我们需要发送复合信号，复合信号由许多简单正弦波组成 傅里叶分析：任何符合信号都是由具有不同频率、相位和振幅的正弦波信号组合而成的 周期复合信号 f: 第一谐波；3f: 第三谐波；9f：第九谐波 非周期复合信号 带宽bandwidth 复合信号包含的频率范围称为带宽 通常是两个数的差值。如果一个复合信号包含1000到5000的频率，那么带宽就是4000 最高频率-最低频率 例子 周期复合信号 非周期复合信号 调幅AM和调频FM 后面会说 黑白电视 电视屏幕像素组成。白或黑。 数字信号 数据可以用数字信号表示。1编码为正电平，0编码为0电平。 一个电平也可以表示为多个位。比如，四个电平情况下，一个电平表示两位 信号有L个电平，则每个电平表示$\\log_2^L$个位 比特率 bit rate 1秒发送的位数，单位bps 🌰 100\\times 24\\times 80\\times 8 /60=256\\text{kbps} 位长 bit length 一个位在传送介质上的距离 位长=传播速度\\times位持续时间 数字信号是一种复合模拟信号 基于傅里叶分析，数字信号是复合模拟信号。带宽无穷大 数字信号的传输 数字信号由0到无穷大的频率组合成的复合模拟信号。 两种不同的方法创术数字信号： 基带传输 宽带传输 基带传输baseband 通过通道发送数字信号。该信号不转换成模拟信号。 需要一个下限是0的低通通道low-pass band 有低通通道就可以进行基带传输 有两种情况 宽带宽 宽带窄 宽带宽 如果真想保持垂直段垂直，水平段水平，则需要发送整个频谱。 如果真的有一个无穷大带宽的介质，是有可能实现的。 但是实际上，频谱边界的频率振幅过小以致于可以忽略不计 只要介质有足够宽的带宽，就可以保留很好地准确性进行通信 有限宽带 将数字信号近似为模拟信号 大致近似 假定数字信号bit rate=N 考虑最坏情况：01010101,10101010，这种情况下频率最高$f=\\frac{N}{2}$。使用该频率的模拟信号 考虑3位的情况 000,111.频率=0 101,010，频率=$\\frac{N}{2}$ 011，100，001，110：$f=\\frac{N}{4}$ 第一谐波：$f=\\frac{N}{2}$ 更好近似 增加频率的更多谐波。 基带传输中，带宽与比特率成正比，如果我们需要更快发送位，需要更大的带宽 🌰如果我们需要用基带传输发送1Mbps，那么低通通道需要的带宽是多少？ 答：取决于准确性： 最小带宽，大致近似：$B=\\frac{bit \\quad rate}{2}$ 第一谐波+第三谐波：$B=3\\times{\\text{500kHz}}=1.5MHz$ 1+3+5：$B=5\\times\\text{500kHz}=2MHz$ 宽带传输（使用调制） 宽带传输或调制就是把数字信号转换成模拟信号传输，调制允许我们使用带通通道bandpass channel 带宽不从0开始 比低通通道更可用 🌰 通过电话线传输计算机数据。电话用户线连接住所到中心电话局。使用有限带宽（0~4kHz）。一般把它看做带通通道， 计算机把数字信号转换成模拟信号 发送模拟信号 安装两个转换器 发送端把数字信号转换成模拟信号 接收端反之 转换器称为调制解调器 🌰数字蜂窝电话 数字蜂窝电话把模拟信号转换成数字信号 主叫方和被叫方之间只有一条带通通道 有效带宽是M 如果有1000人同时交谈 一次通话的有效带宽是$\\frac{W}{1000}$ 所以必须把数字信号转换成复合模拟信号 数字蜂窝电话把模拟音频信号转换成数字信号 再把数字信号转换成模拟信号通过带通通道传输 传输减损 通常有三种类型的减损：衰减、失真和噪声 衰减attenuation 失真distortion 噪声noise 衰减 attenuation 意味着能量的损失，一部分能量转换为热能。 解决方法 使用放大器amplifier放大信号 分贝dB 工程上用于计算两种信号之间相对强度。若信号衰减，则分贝为负值 dB = 10 \\log_{10}\\frac{P_2}{P_1} 失真distortion 信号改变了形态或形状 噪声noise 热噪声、感应噪声、串扰和脉冲噪声 信噪比SNR signal-to-noise ratio SNR=\\frac{平均信号功率}{平均噪声功率} 我们需要考虑平均信号功率和平均噪声功率。因为他们会随时间变化 可以用分贝描述，$SNR_{dB}$定义如下 SNR_{dB}=10log_{10}SNR 🌰 数据速率限制 数据速率取决于三种因素 有效带宽 使用的信号电平 通道的质量（噪声的电平） 两个公式 奈奎斯特：无噪声通道 香农定理：噪声通道 无噪声通道奈奎斯特公式 Nyquist bit rate bit rate = 2\\times 带宽 \\times \\log_2L 带宽：通道带宽 L：同于表示数据的信号电平数量 噪声通道：香农容量定理 Shannon Capacity噪声通道理论上最高数据速率 通道容量=带宽\\times \\log_2{(1+SNR)} 通道容量：通道的传输容量，每秒的比特数 极端情况SNR$\\rarr0$ C=B\\log_2 (1+SNR)=B\\times0=0 与带宽无关。bit rate = 0 🌰 B=3000Hz\\\\ SNR=3162\\\\ C=B\\log_2 (1+SNR)=3000\\times \\log_2 3163 🌰 SNR_{dB}=36\\\\ SNR=10^{3.6}\\\\ B=2\\times 10^6Hz\\\\ C=2\\times{10^6}\\times\\log_2(10^{3.6}+1) 性能 带宽 以Hz衡量带宽 复合信号包含的频率范围或通道能通过的频率范围 以每秒比特数衡量的带宽 100Mbps 通道或链路中位传输的速率 吞吐量 throughput用来衡量通过网络发送数据的快慢 延迟 从源开始发出到整个报文完全到达目标的时间 传播时间propagation time 传输时间transmission time 排队时间queuing time 处理延迟processing delay 延迟=传播时间+传输时间+排队时间+处理延迟 传播时间propagation time 传播时间=\\frac{距离}{传播速度} 传输时间 transmission time 传输时间=\\frac{报文长度}{带宽} 带宽时延积 带宽时延积是能充满链路的位的个数。 为了使用链路的最大容量，我们需要脉冲长度是带宽和延迟乘积的二倍（充满全双工通道） var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH4 数字传输.html":{"url":"computer-network/CH4 数字传输.html","title":"CH4数字传输","keywords":"","body":"CH4 数字传输 线路编码：数据元素、信号元素、数据速率、信号速率、最小带宽、最大数据速率、直流分量、自同步 线路编码方案：单极性编码（NRZ）、极性编码（NRZ-L和NRZ-I）、归零码（RZ）、双相码（Manchester和Differential Manchester）、双极性编码（AMI和伪三进制码）、 脉码调制PCM：采样（采样率）、量化等级、量化误差 Delta调制的概念 传输模式：异步传输、同步传输、并行传输、串行传输的概念 DIGITAL-TO-DIGITAL CONVERSION数字到数字转换 线性编码line coding 块编码或分组编码block coding 扰码scrambling 线路编码 将数字数据转换为数字信号。 信号元素与数据元素 区分数据元素data element和信号元素signal element 我们的目标是发送数据元素 我们能发送的是信号元素 数据元素是表示一块信息的最小实体——位 信号元素承载 数据单元，信号元素是数字信号的最小单元 r 定义比率r为每个信号元素的数据元素数量。 数据速率data rate 1s发送的数据元素的数量，即比特率 信号速率signal rate 1s发送的信号速率的数量，单位波特baud 波特率buad rate、脉冲速率pluse rate、调制速率modulation rate 二者关系 S=c\\times{N}\\times \\frac{1}{r}baud 这里的N是数据速率（bps），c是情形因子$c\\in[0,1]$ 带宽 携带信息的数字信号是非周期性的。非周期性信号的带宽是无限连续的。 虽然数字信号的真实带宽是无限的，但有效带宽是有限的。 波特率而不是比特率决定了数字信号的带宽，最小带宽定义如下 B_{\\min}=c\\times N\\times\\frac{1}{r} 如果给出通道带宽，我们可以得出最大数据速率如下 N_{\\max}=\\frac{1}{c}\\times B \\times r 一般情形 $c=\\frac{1}{2}$ 基线偏移 避免长0和长1 直流成分 DC component 当数字信号中的电平保持一段时间恒定时，频谱会产生很低的频率。 这些接近0的频率称为直流成分。会给不能通过低频的系统或使用电子耦合的系统带来问题（变压器）。 对此应该使用无直流方案 自同步 接收方的位间隔必须与发送方的位间隔严格对应。 self-synchronizing，数字信号在 数字信号在传输的数据中包含定时信息。 如果信息中包含有提示接收方 起始 中间 结束位置 的脉冲跳变就可以完成自同步 如果接收方时钟不同步，这些提示跳变会将其时钟复位 线路编码方案 单极——NRZ 极性——NRZ、RZ和双相（曼彻斯特和差分曼彻斯特） 双极——AMI和伪三元码 多电平——2B/IQ、8B/6T and 4D-PAM5 多跳变 单极编码方案 所有信号电平都在时间轴的一边 NRZ non-return-to-zero方案 位中间信号不会归0 开销高 极性编码方案 电平在时间轴两边 NRZ和极性NRZ(polar NRZ) NRZ-L：电平决定位值 NRZ-I：见1就翻不归0 存在的问题 基线偏移 NRZ-L：全0，全1长序列 NRZ-I：全0 同步 NRZ-L：全0，全1长序列 NRZ-I：全0 极性意外改变会导致1变成0 两个方案都有N/2Bd的平均信号速率 S=c✖️N✖️1/r 带宽 频率接近0时，功率密度值会很高 携带高能量DC值 🌰 都是N/2 RZ归0编码 缺点：极性改变会导致所有1识别为0 双相编码：曼彻斯特和差分曼彻斯特difference manchester 位中间的跳变用于同步 差分见0就翻，中间必翻 没有基线偏移 没有DC成分 信号速率太高 双极性方案 双极bipolar编码。 有三个电平 正 负 0 AMI alternate mark inversion交替传号 AMI: 0保持0电平；1交替正负 伪三元编码：0和1交换 适合长距离通信 虽然有长0，但是没有DC成分，因为长0振幅是0 但是长0会有同步问题 模拟analog到数字digit转换 脉冲码调制 delta调制 脉冲码调制PCM 把模拟信号转换成数字信号的最通用技术称为脉冲码调制pluse code modulation 采样 量化 编码 采样sampling 每隔$T_s$秒对模拟信号采样 采样率$f=\\frac{1}{T_s}$ 理想采样 自然采样 方顶采样 采样和保持技术sample and hold 根据奈奎斯特定理，采样率必须至少是最高频率的2倍 采样过程有时被称为脉冲振幅调制（pluse amplitude modulation PAM) 量化 采样后的结果是一些列振幅值结余最大振幅和最小振幅间的脉冲。 假定原始模拟信号有介于$V\\min$和$V\\max$之间的瞬时振幅 把范围分成L个区间，每个区间高度为$\\Delta$ \\Delta=\\frac{V_\\max-V_\\min}{L} 分配0到L-1的量化值给每个区间的中点 样本振幅近似为量化值 量化等级 即L的值。大小取决于模拟信号的振幅范围以及需要恢复的信号的程度。音频中通常为256. 较低的L，会增加量化误差。 量化误差quantization error 🌰 编码 每个样本的位数取决于量化等级数， n_b=log_2L 比特率 \\text{bit rate}=\\text{sampling rate}\\times n_b PCM带宽 假设给定低通模拟信号的带宽。如果要数字化该信号 线路编码的信号最小带宽是$B_\\min=c\\times N \\times \\frac{1}{r}$ B_\\min=c\\times N \\times \\frac{1}{r}=c\\times n_b \\times f_s \\times \\frac{1}{r}=c\\times n_b \\times 2 \\times B_{analog} \\times \\frac{1}{r} 这表明，数字信号的最小带宽是模拟信号带宽的$n_b$倍。这就是数字化的代价。 通道最大数据率 N_\\max=2\\times B \\times \\log_2L \\text{bps} Delta调制 最简单的一种是delta调制，减少了PCM的复杂性 调制器 从模拟信号中产生位流，记录了最小的正负变化，即当前样本-上一个样本的值，如果是正的，则记录为1；否则记录为0。 传输模式 并行parallel：只有一种 串行serial 异步 asynchronous 同步 synchronous 等时 isynchronous 并行传输 parallel transmission 每次使用n条线路传送n位 速度高 成本高 串行传输 位依次传输 只需要一条通道 成本是并行的$\\frac{1}{n}$ 异步传输 时序不重要 信息的接收和转换通过约定的模式进行 将位流组成字节 作为一个单位沿着链路传输 无同步时钟 增加起始位、停止位 每个字节开始时发送一个起始位，结束时发送多个或一个停止位 每个字节间有时间间隔。 同步传输 依次发送位流，不含起始位、停止位和间隙。接收方负责将位流进行分组 速度快 多用于大块二进制数据 等时 isochronous 数据固定速率到达 实时音频和视频中，帧间的不等延迟是不可接受的 整个流必须同步 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH5.html":{"url":"computer-network/CH5.html","title":"CH5 模拟传输","keywords":"","body":"CH5 比特率和波特率 数字到模拟转换： `ASK的概念及ASK的带宽 FSK的概念及BFSK的带宽 PSK、BPSK、QPSK和QAM的概念 模拟信号调制： AM、FM和PM的概念 AM带宽、FM带宽和PM带宽 数字到模拟转换 digital-to-analog conversion 一个正弦波由 振幅 频率 相位 定义 改变任何一个，波都会变化。可以用这个变化来表示数据的变化。可以得出至少三种将数字数据调制到模拟信号的机制 幅移键控：==ASK==amplitude shift keying 频移键控：==FSK==frequency shift keying 相移键控：==PSK==phase shift keying 正交振幅调制：quadrature amplitude modulation QAM 比特率和波特率 S=N\\times \\frac{1}{r} 波特类似车辆，比特类似乘客。 例子🌰 带宽 除了FSK，其他数字数据的模拟传输所需带宽与信号速率成正比。 FSK还要再加上载波信号频率间的差值 载波信号 carrier signal 发送设备产生一个高频信号作为基波来承载信息信号 接收设备将自己的收听频率调整到与所期望的发送设备载波频率一致 数字信息通过改变载波信号的一个或多个特性（振幅，频率和相位）来调制载波信号 这种形式的改变称为调制（移动键控） 收音机 幅移键控 ASK 通过改变载波信号的振幅来生成信号元素 二进制ASK BASK 有多少个电平，就有多少种振幅，ASK常用两个电平 一个信号电平的振幅峰值是0，另一个和载波信号相同 ASK带宽 调制处理后信号变成了非周期复合信号，非周期复合信号由连续频谱 带宽与信号速率成正比，通常涉及另一个因子称为d，如绝育调制和过滤处理 B=(1+d)\\times S\\\\ d\\in [0,1] 最大值是2S 最小值是S 载波频率$f_c$位于带宽中间 如果有可用的带通通道 可以选择合适的$f_c$从而占用该通道。 例子1 多电平ASK 多于两个电平，可以使用4,8,16或更多振幅，一次对应2,3,4位或更多位。 不使用单纯的ASK实现，而是使用QAM实现 频移键控 通过改变频率来表示数据 调制后信号的频率在一个信号元素持续期间是固定的 如果数据元素改变则下一个信号元素会变。 amplitude phase不变 二进制FSK BFSK 考虑两个载波频率。 选择两个载波频率，$f_1$和$f_2$ 如果数据元素是0，使用第一个； 如果数据元素是1，使用第二个 通常两个载波频率很高，差值很小 一个带宽的中点频率是$f_1$，另一个中点频率是$f_2$ 两个带宽都是$(1+d)S$ $f_2-f_1=2\\Delta f$ BFSK带宽 B=(1+d)\\times S+2\\Delta f \\\\ \\Delta f \\geq S 例子 🌰 多电平FSK 使用多于两个频率（4,8,16） 相邻频率相差2$\\Delta f$(最小值为S) d=0时 相移键控 通过改变相位来表示信号元素。 比ASK和FSK更通用 二进制PSK BPSK 使用两个相位 0 180 优点： PSK和ASK一样简单，但是比起ASK不受噪声影响 PSK优于FSK：不需要两个载波信号 带宽 B=(1+d)S 实现 极性NRZ信号乘载波频率 正交PSK QPSK 载波信号一个同相一个异相 星座图 constellation diagram 定义信号元素的振幅和相位 一个信号元素由一个点表示。它携带的位或位组合写在旁边 两根轴 X轴：同相载波相关 Y轴：正交载波相关 每个点包含四个信息 在X轴投影定义了同相成分的amplitude 与Y轴投影定义了正交成分的amplitude 到原点连线的长度：振幅 角度：相位 QAM Quadrature Amplitude Modulation 正交振幅调制 PSK和ASK的结合 一次改变两种特性 ASK + PSK 使用两个载波 一个同相 一个正交 每个载波使用不同振幅 可能的变化有无穷多个 模拟信号调制（模拟到模拟转换） 如果介质具有带通特性或只有带通带宽可用。 那么模拟信号需要调制。 e.g.无线电，正负为每个无线电台分配基带带宽。每个电台生成的模拟信号都是低通信号，都在同一频率范围内。为了能收听不同电台，需要将低通信号平移，使每一个信号对应不同的频率范围 analog-to-analog conversion可以通过三种方法实现 调幅 amplitude modulation AM 调频 frequency modulation FM 调相 phase modulation PM AM 对载波信号调制 使其（载波信号）振幅随调制信号的振幅变化而变化 载波信号频率保持不变 调制信号变成了包络线 使用乘法器实现 AM带宽 调制信号modulation signal带宽的两倍。 音频信号带宽通常为5KHz，所以调幅无线电台最小需要带宽是10kHz B_{AM}=2B 调频 frequency modulation 带宽 B_{FM}=2(1+\\beta)B\\\\ \\beta \\text{一般为4} 🌰 立体声广播的音频信号带宽接近15kHz。FCC允许每个调频电台使用200kHz的频率差，确保不重叠。 B_{FM}=150 调相 phase modulation 带宽 由调制信号的带宽和最大振幅确定 $\\beta$窄带大约是1，宽带大约是3 B_{PM}=2(1+\\beta)B var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH6.html":{"url":"computer-network/CH6.html","title":"CH6","keywords":"","body":"第6章 带宽利用 复用：FDM、同步TDM、统计TDM和WDM的概念 数字层次、T1载波、E1载波 波分和码分的概念 扩频：FHSS和DSSS的概念 motivation 带宽利用是可用带宽的合理利用 复用 multiplexing 可获得效率 扩频 spreading 保密和抗干扰能力 复用 multiplexing 允许通过一条数据链路传输多个信号，在复用的系统中，n条线路共享一条链路的带宽 复用器MUX：将流量组成一个单独的传输流 分离器 DEMUX：接收端，将传输流分解成几个单独的传输流 通道channel：在给定一对设备之间传送传输信号的链路的那部分。一个link可能有多个通道 有三种技术 频分多路复用 Frequency-Division Multiplexing(analog) 波分多路复用 Wavelength-Division Multiplexing(analog) 时分多路复用 Time-Division Multiplexing(digit) FDM 概念 FDM是用来组合模拟信号的模拟多路复用技术 载波频率之间的频率差能容纳调制信号的带宽 通道之间用保护频带分割，防止重叠 载波频率不能影响原始的数据频率 数字信号转换为模拟信号后，仍然可以使用FDM 例子1 例子2 波分多路复用 合并多个光信号 用于具有高数据速率传输能力的光纤 概念上与FDM相同，原理也一样 差别是WDM复用的频率非常高 prisms 棱镜在波分复用中的复用和分离器 将多个光源组成单一光信号 在分离器上做相反的处理 光源组合与分离由棱镜完成 WDM的一种应用是同步光纤网络SONET 时分多路复用复用 TDM 组合多个低速通道为一个高速通道 是一个数字化的过程，允许多个连接共享一条高带宽链路 TDM在时间上共享，每个连接占用链路的一个时间片段 TDM将不同源端的数字数据合并到一个时间共享的链路上 同步时分复用 Sync time-division multiplexing \\text{链路速率}=n\\times{数据速率} 且一个单元的持续时间变为$\\frac{1}{n}$ 例子 交替 interleaving TDM可以看做是两个快速旋转的开关 是同步的，以相同速率旋转但是方向相反 交替interleaving：在复用一侧，当开关在一个连接前打开时，连接即有机会从通路中接收一个单元。 空时隙empty slots 会出现不连续数据 数据速率管理 有时每路信号速率不同 多级复用 multilevel multiplexing 多时隙分配 multiple-slot allocation 脉冲填充 pulse stuffing 前两个都必须是整数倍的情况；最后一个是任意倍即可 多级复用（加速） 一条输入数据线的数据速率是其他一些输入数据线数据速率的整数倍可以采用多级复用技术 多时隙（减速） 脉冲填充 帧同步（帧指示位） 如果复用器和分离器之间失去同步，则属于某一个通道的位可能会被错误的通道接收。 为此，在帧开始增加一位或多为的同步位。 例子 数字信号服务（1.544记住） 电话公司通过一种数字信号的层次结构实现TDM，称为 数字信号（digital signal, DS） 或数字层次结构（digital hierarchy) DS0有24个，每个是64kbps，以及8kbps的同步开销得到1.544记住1.544** T线路 DS-0, DS-1是服务的名称 使用T线路T lines实现 用于模拟传输的T线路 T线路是为数字数据、音频或者视频设计的数字线路。但也可以用于模拟传输（常规电话连接）。前提是对模拟信号采样，然后使用TDM 过去，一个组织可能需要几十根电缆，来与外界通信。有了T线路之后，只需要一根T线路 8kbps的开销是怎么来的 E线路 欧洲版T线路。概念相同，容量不同 统计时分复用 动态分配时隙以提高带宽的效率。 每个帧的时隙个数小于输入线的条数 复用器循环顺序检查输入线 输入线有数据发送时 才对输入线分配时隙 输出时隙时需要携带 数据 目的地址（输入线） 寻址：N个输出线用n位表示，满足$n=\\log_2N$ 没有同步位 时隙大小 带宽 链路的容量小于每个通道容量之和 扩频 spread spectrum 为无线网设计 防止窃听者窃听 防止入侵者干扰 做法 为达到此目的 在信号上增加冗余部分 扩展原始信号的频带满足每个站的需要。 如果需要的带宽是B，扩展至$B_{ss}$ $B_{ss} \\gg B$ 两个原则 每个站点分配的带宽要足够大 原来的带宽B扩大到$B_{ss}$，由一个与原来的信号无关的过程来做 调频扩频FHSS 伪随机噪声 用源信号调制M个不同的载波频率。某一时刻用信号调制1个再破频率，下一时刻调制另一个频率。 伪随机噪声 frequency hopping spread spectrum FHSS循环 宽带共享 如果跳频数是M，可以将M个通道复用为使用同一带宽的通道， 直接序列扩频direct sequence spread spectrum DSSS 每个数据位用扩展编码的n位代替。每一位被编码为n位代替 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/ch10检错与纠错.html":{"url":"computer-network/ch10检错与纠错.html","title":"ch10检错与纠错","keywords":"","body":"ch10检错与纠错 en ZH_CN Types of errors 差错类型 Redundancy 冗余 Dectection Versus Correction 检错和纠错 Forward Error Correction Versus Retransmission 前向纠错和重传 Coding 编码 Modular Arithmetic 模运算 一、差错类型 单比特差错 非常少见 突发性差错 数据单元有两位或多为发生变化 更多 8位突发性差错 不一定连续 二、检错和纠错 为了检测或纠正差错，需要发送除了数据外的额外冗余位 检错：是否发生错误 纠错：哪里发生错误 纠错方法：前向纠错和重传 三、编码和译码 信息+冗余 不可靠传输 校验 编码 块编码 卷积编码 四、块编码BLOCK CODING 模运算 只使用0~(N-1)的整数 在块编码中，把报文分成块，每块k位，称为数据字。并增加r个冗余位使其长度变为n=k+r，形成n位的块称为码字 数据字和码字 下面黄色的，有$2^n$种组合，但是只有$2^k$有效 差错检测 接收方有有效码字列表 原来的码字已改变成无效的码字 如果码字在传输中被破坏，且仍然是有效的码字则差错无法被发现 块编码检测过程 检错码是为某些类型的差错而设计。 只能检测这些类型的差错。其他类型的无法检测 差错纠正 检错：接收方只需知道接收到的码字是无效的 纠错：接收方需要知道发送的原来的码字 纠错更复杂，需要更多冗余位 左边编码器，右边译码器 汉明距离 两个相同长度字的汉明距离是对应位不同的数量。它是差错编码的核心概念 $d(x,y)$总是大于0 计算：对两个字异或后计算1的个数 最小汉明距离 最小汉明距离是一组字中所有可能对的最小汉明距离。 编码方案写成$C(n,k)$和一个单独的$d\\min$表达式，n是码字的长度，k是数据的位数，$d\\min$是最小汉明距离 接收到的码字和发送的码字之间的汉明距离是传输中被破坏的位数 为了保证检测中最多s个错误，块编码中最小汉明距离一定是$d_\\min=s+1$ 为了保证最多能纠正t个差错，块编码中的最小汉明距离是$d_\\min=2t+1$ 🌰 这个方案最多检测3个错误 最多纠正1个差错 需要的最小距离是奇数 线形块编码 所有块编码都属于一个称为线性块编码的子集 在线性块编码中，任意两个有效码字的异或（模2加）生成另一个有效码字 线性块编码的最小汉明距离：具有最小1的个数个非0有效码字中1的个数 简单奇偶校验码 n=k+1，且$d_\\min=2$的单比特检错编码 假设发送方发送数据字1011，生成码字10111 没有差错 单个位差错 两个位差错 三个位差错 能检测出奇数个差错 二维奇偶校验编码 能检测出所有3位或3位以下的错误，此时至少在某行或某列上有一位错误、奇数位错误以及很大一部分偶数位错误 汉明编码 本书只讨论最小汉明距离为$d\\min=3$的汉明码，它最多能检测出2位差错和最多纠正1位差错 选择m>=3的整数，则码字长n、数据字长k和校验位r的关系位 n=2^m-1,k=n-m,r=m 汉明码$C(7,4)$ 逻辑判定 生成器不关心 无差错 奇偶位的差错 矫正子对的值是每个比特值的组合 汉明编码提高突发错误能力 循环码 码字循环移位，结果是另一个码字 循环冗余校验 k位数据字，n位码字 校验和与反码 用校验和进行简单检错的方法常用于Internet 反码 反码算法： n位表示0到$2^n-1$的无符号数 如果这个数组多于n位，最左边的额外位加到最右边的n位 一个数的负数可用该数所有位取反（0变成1，1变成0） 等同$2^n-1$ 🌰 反码4位表示21 10101，最左边的位加到最右边的4位上。 因特网校验和 使用16位校验和。 发送方站点 报文划分为16位字 校验和字的值为0 所有字包括校验和使用反码运算相加 对这个和求反变成校验和 校验和随数据一起发送 接收方，差错检测 报文包括校验和划分为16bit字 用反码加法将所有字相加 对该和求反生成新的校验和 如果校验和是0 接收报文；否则，放弃报文 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/ch11数据链路控制.html":{"url":"computer-network/ch11数据链路控制.html","title":"ch11数据链路控制","keywords":"","body":"3数据链路控制 成帧0 流量控制 差错控制 协议0 无噪声通道 有噪声通道 高级数据链路控制HDLC 点到点PPP PPPoE (了解) 一、成帧 成帧方式 防止混淆 字节填充 位填充 将一组比特位组成帧，一遍帧和帧之间可以识别。 帧 将一条从源端到目的端的报文分离开。 Fixed-size framing Variable-Size Framing 成帧方式 固定大小：ATM网络 可变长度 面向字符 面向位 从上一层来的数据：以字节形式 flag标记一帧的开始和结束 字节填充 当数据中存在一个标记字符（flag）或者换义字符时，添加一个额外字节的过程 流量控制和差错控制 通常一起称为数据链路控制 Flow Control Error Control 流量控制 一系列程序，用来限制发送方在等到确认之前发送的数据数量，使不会超过接收能力 接收方有一定缓存，可以存一部分逐步消费 数据链路层的差错控制基于自动重复请求（ARQ）重传数据 5种协议 两种帧： 确认帧:ACK接收——发送 否定确认帧：NAK——表明确认数据收到但是有错误要求重发 捎带技术 无噪声信道 最简单协议 停止等待协议 不适用差错控制 有噪声信道 停止等待ARQ 回退N帧ARQ 选择重复ARQ 最简单协议 没有流量控制 没有差错控制 发送方 事件：从网络层发出请求 发送好多帧 接收方 事件：网络层传来数据 算法 发送方 while(true){ //永远重复 WaitForEvent(); // 等待事件 if(Event(Request)){ // 包 getData(); //发 MakeFrame(); SendFrame(); } } 接收方 永远重复 等待事件 接受 🌰 发送方不考虑接收方是否接受到 停等协议 没有差错控制 有流量控制 流量控制的实现 发送方发送一帧后，只有收到ACK才会发送下一个 while(true){ canSend = true; WaitForEvent(); if(Event(RequestToSend) and canSend) { GetData(); MakeFrame(); SendFrame(); canSend = false; } WaitForEvent(); if(Event(ArrivalNotification)) { ReceiveFrame(); canSend(); } } 接收方 数据来自物理层 处理 数据交给网络层 🌰 流量图 要求会画，不用这么漂亮 停等ARQ 停止等待 ARQ 自动重发 停等协议没有重发 有差错控制 保留已发送帧的副本 重传定时器到期后重传这个帧实现差错检测 使用序列号为每一个帧编号（差错控制需要） 序列号基于模2运算 ACK确认帧也会丢失，因此也需要序列号 ACK编号是期望收到的下一帧的编号（模2运算） 一次一帧 Sn：窗口 发送方事件 网络层请求 物理层通知：ACK 超时 接收方事件 物理层通知 算法 Sn = 0; canSend = true; while(true){ WaitForEvent(); if(Event(RequestToSend) and canSend){ GetData(); MakeFrame(Sn); StoreFrame(Sn); StartFrame(Sn); StartTimer(); Sn = Sn+1; canSend = false; } WatiForEvent(); if(Event(ArrivalNotication)){ ReceiveFrame(ackNo); if(not corrupted and ackNo == Sn) { stopTimer(); purgeFrame(Sn-1); //清除副本 canSend = true; } } if(Event(Timeout)){ StartTimer(); ResendFrame(Sn-1); } } 序列号不匹配也会发送ACK，但是序号不加1，还是这一帧 这里能看出超时 路上丢失 到了但差错 🌰 都是模2 回退N帧ARQ 序列号模$2^m$，其中m为序列号字段长度 滑动窗口：定义发送方和接收方关心的序列号范围 只有发送窗口内的才能发送 Sn指向下一个发送的帧 窗口大小$2^m-1$ 收到某帧后 左边界右移 右边界右移 发送窗口 Sf Sn Ssize 小于$2^m$一般$2^m-1$ 当有效确认到达时 发送窗口滑动 一个或多个帧时隙 接收窗口 $R_n$定义了一个大小为1的接收窗口 正确的帧到达时，接收窗口滑动到下一个时隙 确认 当一个帧安全有序到达时，接收方发送肯定的确认 如果一个帧被破坏或次序颠倒 接收方不响应 丢弃后来的所有帧 知道收到一个期待帧 接收方不响应使得不被确认帧的定时器过期，发送方从此帧开始重发所有帧 接收方发送一个累积确认 观察左边情况，如果左边窗口大小是$2^m$，则会发送Frame3，然后如果依然超时，则发送Frame0，而此时接收窗口也想要Frame0，这样不行。 所以，发送方窗口必须小于$2^m$ 接收方窗口只能是1 接收方 累积确认 🌰 ACK丢失 丢失的ACK不需要重发 发送帧丢失 问题 接收方只有一个变量，不能解决失序问题 在有噪声信道效率低下，需要重发多个帧 选择重复ARQ 窗口尺寸更小$2^{m-1}$ 接收窗口与发送窗口一样大 选择重传ARQ 发送窗口 接收窗口 窗口大小 $2^{m-1}$ 定时器启动、重启和停止 一组连续帧到达且从窗口起点开始则可以向网络层交付 每个而窗口位置只发送一个NAK，并指向窗口第一个时隙 数据交付到网络层才发ACK 捎带（了解） HDLC高级数据链路控制协议(非重点) High-level Data Link Control 面向位000 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH14.html":{"url":"computer-network/CH14.html","title":"CH14无线局域网WLAN","keywords":"","body":"CH14 无线局域网WLAN 一、IEEE 802.11 IEEE定义的无线局域网规范 涵盖 物理层 数据链路层 体系结构 基本服务集（BSS） 扩展服务集（ESS） 二、基本服务集BSS Basic Service set BSS 无线局域网的积木块 一个基本服务集由 固定的或移动的无线站点 访问点（Access point ，AP）的中央基站 三、扩展服务集 Extend Service Set ESS 两个或更多个带有AP的BSS组成。 通过一个分布式系统（通常是有线局域网将各个BSS连接在一起）。 分布式系统连接到AP， 该分布式系统可以是任何的IEEE局域网 以太网 注意，包含两种类型的站点 移动站点：BSS内的一个普通站点 固定站点：属于有线网络的一部分的AP站点 注意：一个移动站点可以同时属于多个BSS 站点类型 根据站点在无线局域网中的移动性 IEEE 802.11分为三种类型 不迁移：固定的或仅在BSS内部移动 BSS迁移：站点可以从一个BSS移动到另外一个**BSS**，但仅在一个ESS中 ESS迁移：站点可以从一个ESS移动到另一个ESS，不保证通信在移动中是连续的 MAC层 IEEE 802.11定义了两个MAC层 分布式协调功能（DCF） 点协调功能（PCF） 局域网的IEEE标准 分布式协调功能 IEEE在MAC子层定义的两种协议之一称为分布式协调功能（distributed coordination function DCF）。 DCF使用CSMA/CA作为访问方式， Link{@ CH12} 不能用CSMA/CD 为了进行冲突检测：站点必须能够同时发送数据和接收冲突信号 因为隐藏的站点问题：可能检测不到冲突 站点间的距离可以很大：信号衰减会使得一端的站点无法侦听到另一端的冲突 处理流程图 CSMA/CA 为CSMA增加了一个冲突避免（Collision Avoidance） 在使用CSMA/CA的同时还增加使用确认机制 帧交换时序CSMA/CA 在发送一个帧之前，源站点通过检测载波频率的能量级来侦听介质 在通道空闲之前，通道使用带有补偿的持续策略 站点发现通道空闲之后，它等待一个DIFS（分布式帧间间隔）的时间周期，然后发送一个请求发送的控制帧 目的端接收到RTS并等待一个SIFS（short interframe space， SIFS）的短暂时间 目的端向源站点发送一个清除发送（CTS）的控制帧 源端等待一个与SIFS相等的时间，发送数据 目的端收到，等待一个SIFS，发送ACK（在这个协议中，没有任何方法检查数据是否已经成功到达目的站点） CSMA/CD中没有冲突就是向源站点表示数据已经到达 NAV网络分配矢量（冲突避免） 如果一个站点获得访问，那么其他站点需要推迟发送数据 当一个站点发送RTS帧（Request To Send），它包含了需要占据通道的时间。 一个站点发送时，其他站点不能发送 受这一传送所影响的站点建立一个网络分配矢量（network allocation vector NAV）的定时器 NAV指出允许这些站点下次检测还需要多长时间 也就是 每个站点检查物理介质是否空闲之前必须检查NAV是否过期 握手冲突 点协调功能（PCF） Point coordination function ,PCF。它在DCF的上面实现，主要用于对时间敏感的传输 集中式、无竞争轮询方式 AP对可以被轮询的站点进行轮询 站点依次被轮询，将数据发送给AP 有比DCF更高的优先级 定义了另一套帧间间隔（interframe space） PIFS比DIFS端 SIFS与DCF的一样 意味着如果同一个站点想用DCF，一个AP想用PCF，AP有优先权 分段 为什么分段？ 无线环境噪声很多，被毁坏的帧必须重传。将一个大的帧分割为多个更小的帧。 帧格式 MAC层包含9个字段 帧控制（FC）：FC字段为2字节，定义了一个帧的类型和一些控制信息 D：定义了用于设置NAV值的时间间隔时间。在一个控制帧中，这个字段用来定义帧的ID 地址：有4个地址字段，每个6字节。 序列控制：本字段定义帧的序列号，用于流量控制 帧主体：0~2312字节 FCS：4字节 CRC-32差错检测序列 寻址机制 四种情况，由FC字段两个标记定义。每一个标记可能是0或1。 MAC帧的四种地址地址1~4的解释取决于这些标记的值 隐藏站点和暴露站点问题 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH15.html":{"url":"computer-network/CH15.html","title":"CH15连接局域网、主干网和虚拟局域网","keywords":"","body":" CH15 连接局域网、主干网和虚拟局域网 物理层和数据链路层设备 连接设备 物理层以下：无源集线器 物理层：中继器，有源集线器 物理层和数据链路层：网桥和两层交换机 物理层、数据链路和网络层：路由器、三层交换机 所有五层：网关 无源集线器 Passive Hubs 连接器，连接不同分支的线路 星型拓扑以太网中：来自不同站点的信号冲突点，集线器是冲突点 是介质的一部分。 工作在物理层以下 中继器 仅工作在物理层 扩展局域网的长度 不能连接不同协议局域网 连接的是局域网的两个分段 转发每一帧，没有过滤功能 可重新生成原始的位模式，是再生器，不是放大器 常用语星型结构，可以多级级联 以太网10Base-T有最大长度限制100m，用中继器可以突破该限制 有源集线器 Active Hub 是一个多端口的中继器， 网桥 Bridges 工作在物理层和数据链路层 可以检查MAC地址（源和目的） 过滤 有一个端口地址映射表 检查帧的目的地址，决定是否转发或丢弃。 转发时必须指定端口 不改变帧中包含的物理地址MAC地址 透明网桥transparentbridge 有过滤功能的中继器 站点意识不到其存在 自动建立转发表 避免内循环 转发 动态表 生成树 每个LAN都能通过唯一路径到达其他任何LAN。 成本：最小跳数 网桥到LAN=1 LAN到网桥=0 每个网桥有内置ID。每个网桥广播该ID，选择ID最小的网桥作为根网桥。 这个算法尝试找出从根网桥到其他每个网桥或LAN的最短路径 基于生成树， 属于生成树部分的端口为转发端口（forwarding port） 不属于的端口为阻塞端口（blocking port） 某个网桥移除或更新都要重新更新生成树 实际情况中网桥配置了软件包动态完成该过程 网桥互相发送BPDU，网桥协议数据单元来更新生成树 源路由网桥source routing bridge 另一种防止循环的方法 用网桥连接不同局域网 网桥在数据链路层可以连接不同协议的局域网，如以太网连接到无线局域网 两层交换机 Two-Layer Switches 是一个有许多端口且性能更好的网桥。有少量端口的网桥只可以连接几个局域网。有更多端口的交换机可以一个端口对应一个站点 优点 不同拓扑局域网接入不用进行改变 扩容简单 路由器 Routers 基于分组的逻辑地址路由分组，通常连接LAN和WAN，有一张表用来决策路由。路由表通常是动态的，用路由协议更新。 三层交换机 Three-Layer Switches 是路由器，但是更快更复杂。交换光纤允许更快的表查询和转发。 随着技术的发展，网桥接口日益增多，发展成现在的交换机。 使用交换机组网与集线器组网相比具有以下特点: 端口独享带宽:集线器是共享带宽; 安全:交换机根据MAC地址只转发到目标端口; 全双工通信; 全双工不再使用CSMA/CD协议; 接口可工作在不同速率:交换机使用存储转发技术; 转发广播帧:转发到除了发送端口以外的所有端口。 网关 Gateways 网关通常是工作在因特网全部五层或OSI模型全部7层的计算机。 网关拿到一条应用消息，读取并解释消息。它能作为两个使用不同模型的互联网的连接设备。 主干网 主干网允许连接多个局域网。主干网本身也是使用局域网协议的局域网。 总线型 星型 总线型主干网 10Base5 10Base2 虚拟局域网VLAN 交换机间的通信 表维护 帧标记 时分多路复用 中继器只再生信号不放大信号 检查帧的目的地址，决定该帧是转发还是丢弃，转发必须指定端口。 连接的站点完全意识不到的网桥，网络中增加或移除不需要重新配置 帧必须能从一个站点转发到另一个站点 通过学习网络中帧的传输，自动建立转发表 必须避免系统内循环 将电缆分割成几段，分段间安装中继器 转发端口转发网桥接收到的帧 阻塞端口阻塞网桥接收到的帧 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH19逻辑寻址.html":{"url":"computer-network/CH19逻辑寻址.html","title":"CH19逻辑寻址","keywords":"","body":"第四部分网络层 负责计算机间传输分组 IPv4地址：A、B、C、D和E类地址、掩码、子网和超网的概念 子网划分、子网的地址范围、地址聚合 NAT的概念 IPv6地址 可能经过多个网络，数据链路层负责在同一网络（链路）上两个系统之间传输分组 网络层保证每一分组从源到它的最后目的地 网络层增加一个头部 包含来自上一层分组的发送方与接收方逻辑地址，如果分组经过因特网传输，还需要寻址系统来识别源与目的地址 当若干个独立的网络（链路）连接在一起组成一个互联网时，路由器或交换机对分组进行路由选择到达它的最终目的。 CH19逻辑寻址 网络层上的通信是主机到主机。 [TOC] IPv4地址 是一个32位地址，唯一地与通用地定义了一个连接在因特网上的设备 地址空间 $2^{32}$ 标记法 二进制标记法和点分十进制标价法 分类寻址 地址类和地址块 ABCDE类 A类：为具有大量主机的机构设计 B类：为可能具有数万台主机或路由器的中型组织机构所设计的 C类：为具有少量主机或路由器的小型组织机构所设计的 D类：为多播设计 E类：为将来保留 网络号与主机号 ABC地址分为网络号（netid）和主机号（hosted） 注意：只有ABC有 掩码mask 无类域间路由选择（Classless Interdomain Rounting CIDR） 子网化subnetting 子网化可将这些地址划分为几个类组，并赋予每一组为较小的网络（称为子网，subnet） 在子网掩码中在增加1的个数。 超网化supernetting 一个组织机构能将C类地址构成更大范围的地址空间。一个组织机构能将几个C类块地址构成更大范围的地址空间——超网 需要申请一组C类地址块而不是仅仅一个 比如需要1000个地址，需要4个C类地址块 超网化是在掩码中减小1的个数 无类寻址没有超网化的需要 地址耗尽 AB类耗尽，C类对多数中等规模的组织机构还是太小 无类寻址 classless addressing 没有类但仍提供地址块 地址块 按需分配 限制条件 块中的地址必须连续 一个块中地址的个数是2的整数次次幂 块的起始地址必须能被块的个数整除 掩码 块地址定义：块中任一地址和掩码 一个掩码32位，n位1和32-n位0。 用斜杠（CIDR标记法） 用x.y.z.t/n来定义 地址和/n可以完全定义整个地址块（起始地址、最后地址和地址个数） 🌰 无类寻址.网络地址 块的起始地址，定义该组织机构的网络。 起始地址是路由器用来将报文发送到该组织机构外部的地址。 路由器有两个地址，一个属于获准的块，另一个属于路由器另一端所在的网络 起始地址不分配给任何设备，用做向互联网其他部分表示该网络的网络地址 特殊IP地址 层次结构 IP也有层次结构 二级层次结构x.y.z.t/n，左边n位是网络前缀，后缀是主机地址。 三级层次结构：子网化 多级层次结构 网络地址转换 Network Address Translation NAT 专用地址和全球地址 内部拥有大量的地址，外部只有少量的地址。内部通信用内网地址，外部通信用外网地址。 通过一台运行NAT软件的路由器，站点必须只有一条与全局因特网相连的链路。 专用地址只能用于一个机构内部通信，不能用于和因特网上的主机通信 专用地址只能用做本地地址，因特网路由器上，对目的地是专用地址的数据报一律不转发 采用专用IP地址的网络称为专用互联网、本地互联网或专用网。 专用IP地址也称为可重用地址 地址转换 外发的分组都通过NAT路由器发送出来，该路由器全球NAT地址来替代分组中的源地址。所有输入的分组也要通过NAT路由器， 转换表 使用一个IP地址 运用IP地址池 同时运用IP地址和端口号NAPT（Network Address and Port Translation） 把源IP地址和TCP（或UDP）端口号都进行转换 专用网内不同的源IP地址都转换为同样的公网IP地址 对源主机采用的TCP端口号，都转换为不同的新的端口号 机制的特殊性（与普通路由器的区别） 普通路由器转发时不改变源IP地址和目的地址；NAT路由器会改变源地址或目的地址 普通路由器在转发分组时工作在网络层，NAPT路由器要查看和转换运输层的端口号 IPv6 IPv6地址由16字节（8位组）组成，长度128位。 一个IPv6地址的长度是128位 冒号标记法 缩短 IPv6许多数字是0。一个部分中开始的0可以省略。全0可以移去 地址空间 单播地址unicast address 多播地址multicast address 任播地址anycast address 保留地址 reserved address 未指明地址 unspecified address 环回地址 兼容地址 映射地址 本地地址 本地链路地址 Link local address 192.168.1.2/24 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH20IP协议.html":{"url":"computer-network/CH20IP协议.html","title":"CH20IP协议","keywords":"","body":"CH20IP协议 考点 第20章 IP协议 IP分组（数据报）的格式 分片(Identification、Flags、Fragmentation offset）、何处分片和重装 MTU IPv6分组格式 IPv4到IPv6的过渡 网际互联 网络的物理层和数据链路层在本地运行。这两层共同负责网络相邻节点间的数据传递。 这个互联网由五个网络组成：四个LAN一个WAN。 A发送数据分组到D需要经过三个链路，每个链路包括两个物理层和数据链路层 S1如何知道应该从f3接口发送出去，前两层没有规则帮助R1做出正确决策。而且，帧也没有携带任何路由选择信息。帧中只包含主机A的MAC地址和S1的MAC地址 网络层需求 网络层负责 主机间的传递 通过路由器或交换机对分组进行路由选择 网络层总的思想 源端网络层：将来自另一个协议的输入数据生成一个分组，分组的头部包含源和目的逻辑地址以及其他信息。网络层负责检验路由表寻找路由选择信息。如果分组太大，就要分段。 交换机或路由器中的网络层：当一个分组到达时，路由器或交换机就从他的路由选择表中找到一个必须将其发送出去的接口。改变头部的某些内容后的分组按照路由选择信息再传送给数据链路层 目的端的网络层负责地址验证：确保分组组中的目的地址与主机地址是相同的。如果分组是一个分段，网络层就等待所有的分段到达后再对其进行重组，然后再将重组后的分组交给传输层。 作为数据报网络的因特网 交换可以分为 电路交换 分组交换 虚电路方法 数据报方法 报文交换 在网络层，因特网使用数据报交换方法。它利用网络层所定义的全球地址，从源端到目的端路由分组 因特网的网络层交换是利用数据报分组交换的方法实现的 作为无连接网络的因特网 面向连接的服务 源端首先与目的端建立一个连接 连接建立，分组按照顺序依次沿着相同的路径发送 所有报文的所有分组传递完毕，连接终止 一个连接建立后，对具有相同源和目的地址的分组序列，只会进行一次路由策略。 连接服务 网络层协议独立地对待每个分组，每个分组与其他分组没有联系，每个分组与其他分组没有联系。一个报文（传输层来的）中分组可能会沿着不同的路径到达其目的地。 因特网网络层通信无连接 注:无连接是指交换机或路由器不保存有关连接状态的信息，不需要建 立连接，也不需要拆除连接。 因特网中的网络层交换是利用数据报分组交换的方法实现 分组传递可利用面向连接的服务来实现，也可以利用无连接服务实现 因特网的网络层通信是无连接的 IPv4 网际协议第四版 TCP/IP IPv4是TCP/IP协议中使用的传输机制。 IPv4是一种不可靠的无连接数据报协议——尽力传递。尽力传递这一词是指IPv4协议不提供差错控制或流量控制 IPv4假定底层不可靠 IPv4必须与可靠协议（如TCP结合使用）配合 IPv4也是使用数据报的分组交换网的无连接协议 每一分组独立进行处理 每一分租通过不同路由传递到目的端 有些数据报可能遗失或损坏 数据报 IPv4层的分组称为数据报datagram。 VER版本4位 占4bit，IP协议版本 0010 HLEN首部长度4位 单位长度4字节，头部最小字节20，不能小于5000000000 IP首部长度最大60字节（$15\\times 4$） Service服务类型8位 用来获得更好的服务 Total Length总长度16字节 首部和数据之和的长度，单位为字节。数据报最大长度为65535字节。总长度不能超过最大传送单元MTU 以太网限制帧中数据报的长度在46到1500字节之间，当数据报长度小于46字节，必须进行填充(pading) 数据长度的计算方法 为了找到从上层来的数据长度，可以将总长度减去头部长度。将HLEN字段的值乘以4就可以得到头部长度 数据长度=总长度-头部长度 这个字段16位长，因此IPv4数据报长度限制在65535字节，其中头部占20到60字节，剩下的是从上层来的数据 实际上某些网络不能将65535字节的数据报封装成他们的帧，这样的话数据报必须分段 许多情况下，不用读取这个字段，但是有些时候封装在一个帧中的不仅仅是数据报，还有填充。比如，以太网限制数据字段大小为46~1500，如果数据报长度小于46字节，必须增加填充字节才能符合要求。 一个小的数据封装在以太网帧中 标识Identification 16位 是一个计数器，用来产生数据报的标识。用于分段中 标志flag 3bit 只有最后两位有意义 片偏移fragmentation offset13位 较长分组在分片后某片在原分组中的相对位置，8bit为偏移单位 生存时间Time To Live 8bit 数据报可以在网络中通过路由器的个数的最大值 协议Protocol 8bit 协议(8 bit)字段指出此数据报携带的数据使用何种协议， 以便目的主机的 IP 层将数据部分上交给那个处理过程。 首部检验和Checksum 值检测首部，不包括数据部分。使用简单计算方法 例子🌰 一个IPv4分组的前8位如下 01000010 前4位是版本，后四位为HLEN 版本正确。后四位是2，$2\\times {4}=8$字节数为8，头部字节最小字节数20，最大60 HLEN 头部长度字段的值为1000，问这个分组携带的选项是几个字节。 答：12字节 计算数据长度 IPv4分组，头部长度字段的值为5，总长度字段的值是0x0028，问这个分组携带的数据是多少字节？ 32+8=40\\\\ 40-20=20bytes |VER|HLEN|SERVICE | TOTAL_LENGTH | | IDENTIFICATION |FLAG|OFFSET | |TIME_TO_LIVE|PROTOCOL|HEADER_CHECKSUM | |Source IP Address | |Destination IP Address | TTL 0x45000028000100000102 . . . 01，还能1跳。 PROTOCOL是02，是IGMP 分段 一个数据报可以通过几个不同的网络进行传输 每个路由器将它所接收到的帧拆封称IPv4数据报，对其进行处理，再封装成另一个帧 接收到帧的格式和长度取决于此帧刚刚经过的物理网络所使用的协议 发出去的帧的格式和长度则取决于将要经过的物理网络所使用的协议 例如：如果一个路由器将一个局域网连接到一个广域网 接收到：局域网帧 发送：广域网帧 MTU最大传输单元 每个数据链路层协议都有自己的帧格式，这格式定义的一个字段是数据字段的最大长度。 当数据报封装成帧时，该数据报的总长度必须小于最大数据长度 某些网络的MTU值 超级通道Hyperchannel: 65535 令牌环16Mbps： 17194 令牌环4Mbps：4464 FDDI：4352 以太网：1500 X.25：576 PPP：296 源端通常不对IPv4分组进行分段，传输层将数据分割成适合在数据链路层所用IPv4的长度 当对一个数据报进行分段时，每个分段都有其自己的头部： 头部中的某些部分需要被复制到所有的分段中 修改三个字段 标识 分段偏移 总长度 与分段有关的字段 标识identification：标记一个从源主机发出的数据报，唯一定义这个数据报。 为了保证唯一性，IPv4协议使用一个计数器标识数据报 发送数据报时，就将该计数器的值复制到标识字段中 只要该计数器保存在主存中，唯一性就得到保证 所有分段该字段相同 目的端据此进行重组 标记flag Reserved Dont fragment 1不分段：如果通不过该网络，则丢弃并向源主机发送一个ICMP差错报文 0，根据需要对数据报进行分段 More fragment：多分位段 1：表明不是最后的分段 0：是最后的分段或唯一分段 分段偏移 表示这个分段在整个数据报中的相对位置 8字节为度量单位 校验和 IPv6 地址空间更大 层次结构扩展性强 首部格式灵活 改进的选项 允许协议继续扩种 支持即插即用 支持资源的预分配 支持更多的安全性 首部改为8字节对齐 IPv6数据报头部和有效载荷 版本Version 4bit Version 0110 优先级 4bit Traffic Class 发生通信量拥塞时分组的优先级 可进行拥塞控制的通信量 不可进行拥塞控制的通信量 流标号 24bit Flow Label 流是互联网络上从特定源点到特定终点的一系列数据报，“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有同样的流标号 有效载荷长度 Payload length 16bit 指明IPv6数据报除基本首部以外的字节数 下一个首部 next header 8bit 相当于IPv4的protocol或可选字段 跳数控制 hop limit 跳数限制 数据报格式 4to6过渡 因特网上系统非常多，从IPv4到IPv6的过渡不能突然发生。要使每一个系统从IPv4过渡到IPv6，需要花费相当长的时间， 三种过渡策略 双协议栈 隧道技术 头部转换 过渡.双协议栈 过渡到v6之前，使用双协议栈dual stack 分组发送到目的端时 主机向DNS查询， 如果返回一个IPv4地址，源主机就发送IPv4分组， 如果返回IPv6分组，就发送一个IPv6分组 过渡.隧道技术 当两台使用IPv6计算机互相通信，通过Ipv4区域时，使用隧道技术。 进入时封装成4分组，离开时去掉封装 头部转换 0x45 00 00 54 00 03 00 00 20 06 58 41 7C 4E 03 02 B4 0E 0F 02 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH21.html":{"url":"computer-network/CH21.html","title":"CH21","keywords":"","body":"CH21 ARP：ARP的概念、功能、分组格式、封装、4种操作 DHCP的概念 ICMP：ICMP的概念、报文格式、差错报告、Ping IGMP的基本概念 不重要 概论 网络层主要协议：IP 尽力传递协议 没有流量控制和差错控制 使用逻辑地址从主机到主机 需要其他协议帮助 ARP创建物理地址和逻辑地址的映射 IP分组使用逻辑地址，而这些分组需要封装成帧，帧需要物理地址（节点到节点） =>ARP（Address Resolution Protocol）协议 有时我们还需要逆映射。 ICMP差错控制 网际协议(Internet Protocol)缺少流量控制和差错控制，ICMP提供差错告警。 IGMP多播传送 一个源端，多个目的端 地址映射 从源主机发送的分组到达目的地主机之前可能要经过许多不同的物理网络 网络级上，主机和路由器都用IP地址标记 物理级上，主机和路由器用MAC地址标识 物理地址就是本机地址，它的管辖范围是本地网络，范围内唯一，全局上不必如此。 是由于物理地址是用硬件实现。物理地址的例子是以太网协议中48位MAC地址，被写入到网卡NIC上。 就是说将分组传递到一台主机或路由器需要两级地址，逻辑地址和物理地址。我们需要能将一个逻辑地址映射称它相应的物理地址，反过来映射也需要的。 静态映射static mapping 创建一个表，将一个逻辑地址与物理地址联系起来。这个表存储在网络上的每个机器上。 缺陷： 一个机器可能更换网卡，结果得到了一个新的物理地址 某个局域网中，每当计算机加点，物理地址都改变 移动的计算机可能从一个物理网络转移到另一个物理地址，这引起了物理地址的改变 动态映射（dynamic） 每当一个机器知道两个地址中的一个，就可以用协议将另一个求出 Address Resolution Protocol 逻辑地址到物理地址的映射 任何时候，主机或路由器有 数据报要发送到另一个主机或路由器时，必须有接收方的逻辑地址。 如果发送方是主机，他可以从DNS求得逻辑地址 如果发送发是路由器，可以从路由选择表求得 但是，IP数据报必须封装成帧才能通过物理网络。 也就是说发送方必须有接收方的物理地址 主要步骤： 主机或路由器发送一个ARP查询分组 该分组包括 发送方的物理地址 发送方的IP地址 接收方的IP地址 查询就在网络上广播 网络上每个主机或路由器都接收和处理这个ARP查询分组，只有预期的接受者才识别该IP地址 接收方返回ARP相应分组，单播发送给查询者 高速缓存器 分组格式 硬件类型 Hardware Type 16bit 运行ARP的网络类型，每个局域网指定一个整数。ARP可使用在任何物理网络上 以太网是1 协议类型 Protocol Type 16bit 定义协议字段，对于IPv4，这个字段值是$0800_{16}$。 0800H表示IPv4 硬件长度 Hardware Length 8bit 物理地址长度，单位：字节。 以太网：6 协议长度 Protocol Length 8bit 这是一个字段位，用来定义以字节为单位的逻辑地址的长度 IPv4: 4 操作Operation 16bit 用来定义分组的类型 ARP请求：1 ARP回答：2 发送方硬件地址 Source hardware address 可变长 发送方物理地址，可变长字段 以太网是6字节 发送方协议地址 Source protocol address 可变长 发送方的逻辑地址，可变长字段 目标硬件地址 Destination hardware address 可变长 目标硬件地址，发送ARP请求时全0 目标协议地址 Destination protocol address 可变长 目标逻辑地址 对于IPv4是4字节 封装 ARP分组直接封装在数据链路帧中。 类型字段指出了此帧所携带的数据是ARP分组 ARP主要步骤 IP请求ARP协议产生一个ARP请求报文 发送方物理地址 发送方的IP地址 目标的IP地址 目标物理地址（置0） 将报文发送给数据链路层，封装为帧 发送方物理地址为源物理地址 物理广播地址作为目的地址 每个主机和路由器都接收到帧 这个帧包含广播目的地址，所有站点都收到此报文 除了目标机器，所有的机器都丢弃该分组 目标机器识别该IP地址 目标机器用ARP回答报文进行应答 此回答报文包含它的物理地址 报文使用单播 发送方接收到这个回答报文，获得目标机器的物理地址 发送IP数据报 四种不同情况 同网络一个主机发送给另一个主机，将物理地址映射为逻辑地址，将该逻辑地址作为数据报头部的目的IP地址 主机到路由器 路由器到路由器 路由器到接收方主机 发送方是一个路由器，它已经收到了一个数据报，要将该数据报发送个同一网络上的一个主机。数据报的目的IP地址就是必须映射为物理地址的那个逻辑地址 ARP请求报文是广播发送；ARP回答报文是单播发送 代理ARP（proxy ARP） 用来产生子网化效果。可以代表一组主机的ARP。 DHCP没看 ICMP IP缺少差错控制和辅助机制 IP协议缺少一种主机和管理查询机制，主机有时需要确定一个路由器或另一个主机报文是否是活跃的，有时网络管理员需要从另一个主机或路由器得到信息 Internet Control Message Protocol因特网控制报文协议 特点 为了提高IP数据报交付成功的机会，在网际层使用 因特网控制报文协议ICMP ICMP允许主机或路由器报告差错情况和提供异常情况的报告 ICMP不是高层协议，而是IP层的协议 ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去 ICMP不能纠错，只能报告错误 ICMP分为差错报告报文和查询报文 注意:ICMP 总是向原始的源方报告差错报文。 ICMP-报文类型 差错报告报文Error-reporting message 查询报文query message Error-reporting message 差错报告报文向路由器或主机报告在处理一个IP数据报时可能碰到的一些问题 query message 查询报文成对出现 它帮助主机或网络管理员从一个路由器或另一个主机得到特定的信息 报文格式 头部+可变长的数据部分 差错报文 ICMP总是向原始的源方报告差错报文 规定 携带ICMP差错报文的数据报，不再产生ICMP差错报文 对分段的数据报文，只对第一个分段产生ICMP差错报文 对于多播地址的数据报文，不产生ICMP差错报文 具有特殊地址的数据报文，如127.0.0.0或0.0.0.0不产生 数据字段内容 8字节中包含端口序号等信息，让源端知道出问题的是哪个 有5种差错 类型 含义 Destination unreachabel 1. 当路由器不能找到路由或者主机不能传递数据时，丢弃这个数据报 然后发回目的端不可达报文；2. 有路由器发出，或者由目的主机创建 source quench 1. 补充流量控制；2. 当路由器或者目的主机中产生拥塞时，路由器或目的主机丢弃数据报，发送源端抑制报文给发送方 time exceeded 1. TTL减为0，路由器丢弃数据报；2. 报文的所有分片没有在有限时间内到达，由目的主机发送 Parameter problems 1. IP分组的首部中产生错误或者二义性；2. 路由器或主机丢弃这个分组，然后向源方发送参数问题报文 Redirection 1. 路由更新过程中的问题；2. A想向B发送数据报，R2是有效的路由，但A却选择了R1，R1收到后发现应该发往R2，于是把分组发给R2，同时向A发送重定向报文 重定向 时间超时 差错报告报文各字段的内容 查询报文 IGMP不重要 IP协议可用到两种类型的通信:单播和多播。 因 特 网 组 管 理 协 议 (Internet Group Management Protocol, IGMP) 是其中一个必要的，但不是充分 的协议，多播也包含其他的协议。在IP协议中， IGMP是一个辅助协议。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH22 传递、转发和路由选择.html":{"url":"computer-network/CH22 传递、转发和路由选择.html","title":"CH22 传递、转发和路由选择","keywords":"","body":"CH22 传递、转发和路由选择 转发技术与转发过程 路由表、地址聚合和最长掩码匹配 Dijkstra算法和Bellman-Ford* 算法 单播路由协议：AS的概念、域内、域间路由选择协议 RIP协议路由表生成的过程 OSPF协议的原理 多播的概念和多播路由（了解） 传递 网络层负责用底层物理网0络处理分组，定义这种处理为分组的传递 直接传递direct delivery：分组最终目的端主机是与发送方连接在同一个物理网络上。当分组的源端和目的端都在同一物理网络上，或传递是在最后一个路由器与目的主机之间进行时，就出现直接传递 间接传递indirect delivery：目的主机与发送方不在同一个网络 最后的传递总是直接传递 判别方法：提取出目的端的网络地址与它所连接的网络地址进行比较，相同则传递是直接的 转发 分组路由到它的目的端，转发要求主机或路由器由一个路由表。当主机有分组要发送时， 或是路由器收到一个分组要转发时，就要查找路由表以便求得到达最终目的端的路由 当前Internet中，这种技术不可能应用。 转发技术 简化路由表的技术 下一跳方法与路由方法 特定网络方法与特定主机方法 默认方法 下一跳方法与路由方法 next-hop route method 完整路由信息vs只保存下一跳 特定网络方法与特定主机方法 Network-specific method 仅用一个项目来定义这个目的网络本身的地址，将在同一网络上的所有主机看做是一个项目。 检查路由或提供安全措施等目的 默认方法 default method 仅用一个称为默认的项目（通常0.0.0.0） 转发过程 假定主机和路由器用无类寻址。 分类寻址可以认为是无类寻址的一个特殊情况 路由表对涉及到的每一个地址块都需要有一行信息 掩码(\\n) 网络地址 下一跳地址 接口 掩码（/n） 网络地址 下一跳地址 接口 /26 180.70.65.192 -- m2 /25 180.70.65.128 -- m0 /24 201.4.22.0 -- m3 /22 201.4.16.0 -- m1 其他 0.0.0.0 180.70.65.200 m2 最长掩码匹配 使用CIDR时，路由表中可能会有不止一个匹配结果 应当从匹配结果中选择具有最长掩码的路由 掩码越长，其地址块就越小，因而路由机就越具体 🌰 路由（路由的实际实现） 从某一网路设备触发去往某个目的地所经过的路径。 路由器通过查询路由表为数据报选择转发路径。路由表只存在于终端计算机、路由器及三层交换机中，二层交换机中不存在路由表 直连路由：设备自动发现的路由信息，路由器可自动发现与自己接口直接相连的网络的路由 静态路由：人工输入，无法自动更新 动态路由：可周期更新，适合大型网络 直连路由和静态路由 静态路由只适合小型网络 直连路由：可以周期性更新 动态路由优先级 RIP和OSPF协议 路由汇总 图中可以看出 路由表项很多。可以进行简化 地址聚合 默认路由 单播路由选择协议 路由表可以是 静态或动态的 静态：人工输入 动态路由表：互联网中某处 发生变化就自动进行更新 路由选择协议是一些规则或过程的组合，使得 互联网中的 各路由器 能够彼此互相通知 这些变化 重点 优化原则 域内部和域间路由选择 距离向量路由选择和RIP 链路状态路由选择和OSPF 路径向量路由选择和BGP 动态路由协议的功能 知道有哪些邻居路由器 能够学习到网络中有哪些网段 能够学习到至某个网段的所有路径 能够从众多的路径中选择最佳的路径 能够维护和更新路由协议 优化原则 路由器将分组转发到哪个与其相连的网络，取决于哪个可用路径是最佳路径 度量metric：给网络指定 代价 RIP路由信息选择协议（跳数） 开放最短路径有限协议OSPF 可达性 边界网关协议 自治系统autonomous system 是一个单一的管理结构管辖下的一组网络和路由器。 互联网很大，以致于仅使用一个路由选择协议无法处理更新所有路由器路由表任务。 在自治系统内部的路由选择称为 域内路由选择interadomain routing 一种或多种 自治系统之间的路由选择称为 域间路由选择interdomain routing 只能一种 Routing Information Protocol Open Shortest Path First Border Gate Protocol Routing Information Protocol距离向量路由选择 任何两个节点之间路由最低代价是最小距离的路径 初始化方法 图中的表是稳定的，每个节点都知道如何到达其余任一节点机器代价。 实际不一定如此 每一个节点只知道邻站（immediate neighbor）的距离。 初始化时，不是邻站的距离标为无穷大 共享路由信息 在距离向量路由选择中，每个节点与它的邻站周期性地或有变化时共享它的路由表 更新算法 当一个节点从它的邻站接收第二列的表时，它需要更新它的路由表。 接收节点在表的第二列中的每一个值➕上它与发送节点之间代价的值， 如果接受节点使用来自任一行的信息，接收节点需要把发送节点名加入作为第三列 接收节点将修改过的接收到的表与它的旧表逐行比较 下一跳不同，取代价最小的行 下一跳相同，选取新行：因为有可能是节点更新了，旧的路径已经行不通 需要强调 第一，数+无穷为无穷 第二，修改过的表说明了如何从节点A经过节点C到达节点A 何时共享 周期更新：30s一次 触发更新：节点在路由表发生变化时，向它的邻站发送它的二列路由表 节点接收到邻站的表 节点检测到邻站链路有故障 两个节点循环不稳定性 三种解决方法 定义无穷大：比如100，RIP中是16 分割范围split horizon：发送表的一部分，发送路由表之前，先删除自己路由表的最后一行，第一次更新后，系统稳定 毒性逆转posion reverse： 三个节点不稳定性 二节点可以用 分割策略➕毒性逆转结合避免， RIP路由选择信息协议 Routing Information Protocol 自治系统内部使用的域内路由选择协议。基于距离向量路由选择的协议 一个自治系统中，包括路由器和网络（链路），路由器有路由表，网络没有路由表 路由表中的目的端这一列是 网络 ，这表示它的第一列定义了目的网络地址 RIP所用的度量是跳数（hop count， 到达目的端的链路个数） 16定义为无穷大 在任何自治系统中，任何路径不能大于15 下一节点这一列定义为目的路由器地址 特点 距离是跳数 跳数越少路径越好 最多15，适用于小型互联网 优缺点 算法和上面的一致（除了无穷大的定义） 链路状态路由选择Link state routing 链路状态 类型 状态 代价 建立路由表 按每个节点建立LSP（链路状态分组） 洪泛法Flooding：向其他所有路由器扩散LSP 为每个节点构成一个最短路径树 基于最短路径树计算路由表 生成LSP LSP携带大量信息，节点表示、链路清单、序列号、寿命 生成LSP的情况 区域的拓扑发生变化 周期性产生60mins~2h 周期较长保证不会产生太多通信量 洪泛法Flooding 创建节点的LSP，从每个接口发送LSP副本 收到的LSP的每个节点与已有的副本比较 丢弃旧的，保留新的 节点通过每个接口（接口副本的接口除外），再次转发副本 通信量很大 最短路径树的狗层 Dijkstra算法 OSPF 基于链路状态的 Open Shortest Path First Protocol 区域Area 包含在自治系统中的一些网络、主机和路由器的集合； 一个自治系统可以划分为多个区域 一个区域内，所有路由器都是用洪泛法传递路由选择信息 在一个区域的边界——区域边界路由器area border router将本区域信息概括起来发送给其他区域 主干：所有区域必须连接到主干 主干路由器backbone router 从区域：主干外的其他区域 虚链路（virtual link）： 划分区域的优点 将利用洪泛法交换链路状态信息的范围局限于每 一个区域而不是整个的自治系统，减少了整个网 络上的通信量 在一个区域内部的路由器只知道本区域的完整网 络拓扑，而不知道其它区域的网络拓扑的情况。 OSPF 使用层次结构的区域划分。上层的区域为 主干区域 0.0.0.0，用来连通其它在下层的区域。 度量 OSPF协议允许网络管理员给每一条路由指定一个代价，称为度量metric。可以基于服务类型（最小延迟，最大吞吐量等）。 链路类型 特点 代价灵活，不同服务类型可以计算出不同的路由 多路径间的负载平衡，如果通一个目的网络有多条相同代价路径，可以将通信量分配给这几条路径 保证仅在可信赖的路由器之间交换链路状态信息，鉴别功能 由于一个路由器的链路状态只这几到与相邻路由器的联通状态，与整个互联网的规模无直接关系。因此，当互联网规模很大时，OSPF协议远比RIP要好 支持可变长度的子网划分和五分类编址CIDR 路径向量路由选择协议（考点未标） 基准：可达性 初始化 每个自治系统有一个代言节点，每个代言节点仅能知道它的自治系统内部节点的可达性。 共享 邻站共享 更新 优点 BGP 多播路由选择 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH23.html":{"url":"computer-network/CH23.html","title":"CH23","keywords":"","body":"第五部分传输层 端口、套接字 UDP协议：UDP协议的概念、数据报结构、校验和的计算、UDP的操作 TCP：TCP的特点与服务、段格式、三次握手（建立连接和拆除连接）、TCP流量控制（信贷滑窗协议）、TCP差错控制 TCP有关字段和序号（SYN、ACK、seq、ack*）、段序号、字节编号 CH23 传输层负责整个报文的进程到进程的传递。 网络层监管独立分组 从源端到目的端 的传递，但是不辨认分组之间的关系。 传输层从源端到目的端的层次中，监管差错控制和流量控制以确保全部报文完整地、按序地到达。 OSI模型中，传输层头部必须包含一个称为服务点地址的地址类型，或在因特网和TCP/IP协议族中的端口号或端口地址。 无连接 面向连接 无连接传输层将每段作为一个独立分组，将它传递到目的机器的传输层。 面向连接传输层在传递分组前要与目的机器的传输层建立一个连接。当所有数据传输完成后，要终止这个连接 在传输层，一个报文通常被划分称可传输的段。 无连接协议（如UDP）对每一段独立处理 一个面向连接协议（如TCP）还要用序号生成这些段之间的关系 像数据链路层一样，传输层也负责流量控制和差错控制。 考点 端口、套接字 UDP协议：UDP协议的概念、数据报结构、校验和的计算、UDP的操作 TCP：TCP的特点与服务、段格式、三次握手（建立连接和拆除连接）、TCP流量控制（信贷滑窗协议）、TCP差错控制 TCP有关字段和序号（SYN、ACK、seq、ack*）、段序号、字节编号 进程到进程的传递 Process to Process delivery 任何时刻，源主机上可能运行多个进程。目的主机也可能运行多个进程。 为了完成传递过程，需要一种机制将源主机上运行的某个进程的数据发送到目的主机的对应进程上 客户/服务器模式（client-server paradigm） 常用的进程到进程通信方式。本机上进程称为 客户（client），远程主机称为 服务器（server） 定义 本地主机 本地进程 远程主机 远程进程 寻址 端口号（port number）作为传输层地址 端口号是在0~65535之间的16位整数。 客户程序用端口号定义它自己，这个端口号由运行在客户机上的传输层软件随机选择的，这是 临时端口号ephemeral port number 服务器进程也必须用一个端口号定义自己，但是这个端口号不能随机选择。 熟知端口号（well-known port number） IANA范围 因特网号码分配管理局 Internet Assigned Number Authority, IANA。已经把端口编号划分为三种范围：熟知的、注册的和动态的 熟知端口：0~1023 注册端口：1024~49151，IANA不分配也不控制，他们可以在IANA注册防止重复 动态端口：端口号范围 49152~65535，不受控制不用注册，可以由任何进程使用（正好25%） 套接字地址 一个IP地址和一个端口号结合起来称为套接字地址（socket address）。 客户套接字地址唯一定义了客户机进程 服务器套接字地址唯一定义了服务器进程， 也就是说，传输层协议需要一对套接字机制：客户套接字地址和服务器套接字地址。 这四条信息是IP头部和传输层协议头部的组成部分，IP头部包含IP地址，UDP或ICP头部包含端口号 复用与分离 寻址机制，允许通过传输层进行复用和分离 复用器multiplexer 在发送方站点，可能有多个进程要发送分组，因而需要复用。传输层协议接收来自不同进程的报文，按端口号区分。 添加了头部后，传输层把分组发送给网络层。 分离demultiplexer 接收方站点，只有一个传输层协议。但有多个进程可能要接收分组。这是一对多的关系。 因而需要分离。 传输层接收来自网络层的数据报。经过纠错和去除头部以后，传输层根据端口号将每个报文传递到适当的进程。 无连接服务与面向连接的服务 无连接服务 connectionless service 不需要建立连接和释放连接 分组没有编号 可能延迟、丢失或无序到达，也没有确认过程 UDP就是无连接的 面向连接服务 Connection-oriented service 首先在发送方和接收方之间建立一个连接 传送数据 最后释放数据 TCP SCTP 可靠服务与不可靠服务 如果应用层需要可靠性服务 就使用可靠的传输层服务 传输层使用流量控制和差错控制 较慢 更复杂 不需要可靠性服务，使用不可靠性服务 UDP：无连接的和不可靠的 TCP和SCTP：面向连接的和可靠的 传输层保证的是端到端的可靠性 并且因为因特网的网络层是不可靠的（尽力传递），所以传输层必须实现可靠性。 TCP的流量和差错控制是通过滑动窗口协议实现的 三种协议 用户数据报协议UDP User Datagram Protocol 。无连接不可靠传输层协议connectionless， unreliable transport proocol 只添加了进程到进程通信 完成非常有限的差错检验 优点 简单，开销最小 熟知端口号 UDP用户数据报（user datagram） 源端口号 16bit 暂时端口号 由进程请求 源主机上运行的UDP软件进行选择 如果是服务器，则是熟知端口号 目的端口号 16bit 如果是目的主机是服务器，则大多数情况是熟知端口号 如果目的主机是客户端，那么大多数情况下是暂时端口号 长度：用户数据报的总长度，头部+数据 16bit 2^{16}=65535字节 总长度应小于这个值，因为这个值是IP数据报的最大值。 校验和：用来校验整个用户数据报出现的差错 校验和 校验和分为三部分：伪头部、UDP头部和从应用层来的数据 伪头部pseudoheader是IP分组的头部的一部分有些字段填入0 如果校验和不包含伪头部，UD也可能安全到达。如果IP头部收到损坏，则可能提交到错误的主机上。 协议字段可以确保分组属于UDP，而不是其他传输层协议。 某种情况下，一个进程既可以用UDP也可以用TCP，端口号可以不变。 操作 无连接服务 数据包之间独立，没有关系。 不进行编号 短报文采用UDP 流量控制和差错控制 flow control & error control 使用UDP的进程应在应用层提供这些机制 封装和拆封 在IP数据报中进行封装和拆封 排列 队列与端口联系在一起。 客户机端 进程启动 从OS请求端口号 入队列与出队列 只有入队列 将报文（包含端口号）送到出队列 UDP逐个将报文取出，加上UDP头部交给IP 出队列如果移除，OS要求客户进程等待 服务器端 UDP检查对用与该用户数据包中的目的端口号是否创建了入队列， 如果有 UDP将数据报放到队列末尾 如果没有 UDP丢弃该数据报 请求ICMP协议发送端口不可达报文 所有发送给一个进程的入报文，不管来自相同的还是不同的服务器 都放在同一个队列中，入队列可能溢出 如果溢出 UDP丢弃该报文 发送ICMP端口不可达报文 创建队列的机制不同 服务器开始运行时就用熟知端口号请求出入队列 只要服务器运行，队列一直打开 适用于 需要简单的请求响应通信，较少考虑流量控制和差错控制 传送成块的数据的进程一般不用 内部有流量控制和差错控制的进程。TFTP 多播，多播能力已被嵌入在UDP软件中；TCP中没有 管理进程，SNMP 路由选择更新协议，如RIP TCP Transmission Control Protocol 面向连接协议，在两个TCP之间建立一个虚拟连接 在传输层使用流量控制和差错控制协议。 为TCP服务增加了面向连接的和可靠的特性 TCP服务 进程到进程通信 流传递控制 允许发送进程以字节流的形式传递数据（写入） 接收进程以字节流形式接收数据（消费） 两进程间用假想的管道连接 发送和接收缓冲区 发送和接收进程可能以不同的速度写入和读出 TCP需要用于存储的缓冲区 每个方向都有一个缓冲区 发送缓冲区 接收缓冲区 也用于差错控制和流量控制 实现方法 使用一字节存储单元的循环数组 发送缓冲区有三种类型 已发送（TCP保留，直到收到确认） 没有发送（将要发送） 空单元 接收缓冲区有两个类型 空存储单元 接收到的字节 读出后，可被回收 段segment IP是以分组的方式发送数据 传输层中，TCP将多个字节分组组合在一起成为一个分组，这个分组称为段 全双工通信full-deplex service 数据可以同一时间双相流动。双方均患有两个缓冲区 面向连接的服务 两个TCP之间建立连接 在两个方向交换数据 连接终止 是一个虚连接，不是物理连接。 可靠服务 通过确认机制来检查数据的安全和完整 特点 序号系统 段头部采用序号sequence number和确认号acknowledgement number 指的是字节序号而不是段序号 字节序号 为所有数据字节编号。每个方向上序号独立。 发送缓冲区进行编号 不从0开始，选取$2^{32}-1$以内的随机数作为第一个字节的序号 用于流量控制和差错控制 每个段的序号是段第一个字节的序号 确认号 使用确认号来确认已收到的字节 确认号定义了该方期望收到的下一个字节的序号 确认号是累计的 接收方记下接收到的最后一个字节的序号，加一 将其作为确认号 流量控制 面向字节的流量控制 防止接收方数据溢出 差错控制 以段作为差错检的数据单元 拥塞控制 段（TCP中的分组） 20~60字节 源端口地址16 目的端口地址16 序列号32（注意随机数长度32位） 确认号32 头部长度4位（20~60字节/4） 保留 控制 用于流量控制 连接建立 连接终止 连接失败等 窗口大小 16位：窗口最大长度65536字节 校验和 与UDP相同 伪头部 TCP头部 数据 紧急指示符 TCP连接 连接建立 数据传输 连接终止 连接建立 三次握手three wayshaking 被动打开：服务器告诉TCP，已经准备好接受连接 主动打开：客户程序发出请求主动打开，开始三次握手。 客户发送SYN段，用于序号同步。SYN段不携带数据，但是认为SYN占一个字节。数据传输开始时从该序号加一 不携带数据但是占用1序列号 服务器发送第二个段，SYN和ACK置1，即SYN和ACK段。序列号单独再随机一个 另一个方向通信的SYN 用ACK表示对之前的SYN的确认 不携带数据但是占用1个序列号 客户机发送第三个段。ACK段 确认收到了第二个段 seq与SYN中序列号相同，ACK段没有占用任何序列号 同时打开，两个进程彼此发送SYN+ACK 数据传输 连接终止 两种方法 三次握手 四次握手（半关闭选项） 三次握手 客户TCP发送FIN端，可以包含客户机要发送的最后数据块。 如果不携带数据，占用一个序列号 服务器收到FIN端，发送FIN+ACK段 确认FIN段收到，通告另一端连接关闭 不携带数据则占用一个序列号 客户端发送ACK，证实收到FIN段。包含确认号，确认号是FIN.seq+1 不能携带数据 不占用序列号 半关闭 注意服务器第一个ACK.seq是y-1 客户端发送半关闭FIN段 服务器分开发送ACK、数据和FIN 先发送ACK 再单方向发送数据 期间客户端也要发送ACK 最后发送FIN端 客户端发送ACK确认 流量控制 滑动窗口 面向字节的滑动窗口 滑动窗口大小可变 三种活动 张开 合拢 收缩 由接收方控制 张开是右边沿向右移动 合拢是左边沿向右：字节确认 收缩是右边沿向左： 窗口大小取决于min(接收方窗口rwnd, 拥塞窗口cwnd) 差错控制 校验和：如果段损坏，则段丢弃，被认为是遗失。 确认：ACK，不占用序列号，不需要确认 重传：重传计时器 retransmission timer。计时器到时或发送方收到三个重复的ACK时重传。 ACK不重传，不设置计时器。 RTO后重传：对所有重要的段（已发送，但还未确认）Retransmission timeout。RTO计时器。 计时器到时，可能是由于 段被延迟，ACK被延迟 确认丢失 超时则重发最早的重要段。 RTO动态更新，根据RTT值进行更新（一个段到达目的端并被确认所需要的时间） TCP中的拥塞控制 慢速启动slow start：指数增长 设置拥塞窗口大小cwnd为一个最大段长度MSS 每收到一个ACK，cwnd增加一个MSS 也就是每进行一次传输（清空一次窗口），窗口大小都以指数规则增长 如果有被延迟的ACK，则窗口大小增长小于2的幂 慢速启动阈值ssthresh，拥塞窗口的字节达到这个阈值，慢速启动阶段结束，下一阶段开始 拥塞避免congestion avoidance：加性增长additive increase 拥塞避免算法 一个窗口的所有段都被确认，拥塞窗口大小加一 直到检测到拥塞 拥塞检测congestion dectecion：乘性减少multiplicative decrease RTO计时器到时，可能存在非常严重拥塞 设置阈值为当前窗口大小的一半 设置cwnd为一个段的大小 回到慢速启动阶段 接收到三个ACK，存在轻度拥塞的可能，一个段可能已经丢失，一些段可能已经到达。 TCP做出轻度反映 设置阈值为当前窗口大小的一般 设置cwnd为阈值 启动拥塞避免阶段 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/application.html":{"url":"computer-network/application.html","title":"应用层","keywords":"","body":"应用层 CH25 CH26 CH27 第25章 域名系统 1. 域名空间，客户端服务器模式 域名解析 DNS 报文 第26章 远程登录、电子邮件和文件传输 Telnet 的基本概念 2. 电子邮件:电子邮件的架构、邮件报文、SMTP 和 MIME、POP3 和 IMAP 3. 文件传输:FTP 的架构、FTP 的连接、FTP 的传输方式、端口 第27章 万维网与超文本传输协议 **1. URL HTTP 的概念、报文结构、HTTP 操作，采用 TCP** 服务的端口 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH25.html":{"url":"computer-network/CH25.html","title":"CH25","keywords":"","body":"CH25 Domain Name System 域名空间，客户端服务器模式 域名解析 DNS 报文 使用DNS服务的例子 名字空间 为了实现无二义性，分配给机器的名字必须从名字空间中仔细选择。该名字空间完全控制对名字和IP地址的绑定。 平面名字空间 一个名字分配一个地址，名字是一个无结构的字符序列。 缺点 必须集中控制才能避免二义性，不能用于大规模系统 层次名字空间 每个名字由几部分组成，分配和控制名字空间的机构可以分散化 域名空间 所有名字由根在顶部的倒置树结构定义。最多有128级 全程域名FQDN和部分域名PQDN FQDN：Fully qualified domain name 最后是点 PQDN: Parially qualified domain name 域 名字空间的分布 一台计算机不足以存储 一台服务器管理的空间称为区域zone 因特网中的DNS 通用域 generic domains 按照行为区分 国家域 country domains 使用两个字母的国家缩写，第二级标号可以是组织结构 反向域 将地址映射为名字，为了确定客户端是否在授权的列表中。 解析 将名字映射称为地址或者将向地址映射称为名字的过程 递归解析 recursive resolution client 向就近服务器发送请求，如果这一服务器是授权服务器，则其检查数据库做出相应，如果不是，则发送给另一个服务器通常是父服务器。 当解析得到响应，响应就向后传送，知道最终到达发出请求的客户机。 迭代解析 iterative resolution 如果服务器是该授权服务器，发送应答； 不是，发送它认为可以解析这个查询的服务器的IP 客户端向下一台发送请求。 高速缓存 缩短查询的时间 映射可能会过期 设置生存时间TTL 要求每台服务器保留一个TTL计数器，到达时间，高速缓存会定期检查，并清除掉TTL已经过期的映射 DNS报文 两种报文 查询报文 query message 响应响应 response message 头部 header identification 客户端使用该字段匹配对查询的响应。 客户端每次发送查询时会使用不同的标识号。 响应时该字段相同 flags标记 子字段的集合。定义了 报文类型 应答类型 期望的解析类型（递归或迭代） 询问记录数 报文中询问部分所含请求的数量。 应答时为0 应答记录数 报文中应答部分所含应答记录的数量 查询时为0 授权记录数 响应报文中授权部分所含授权记录的数量 查询时为0 附加记录数 附加部分所含附加记录的数量 查询时为0 询问部分 一条或多条询问记录构成。两种报文都含有 应答部分 由一条或多条资源记录构成。包含应答内容 授权部分 一条或多条资源记录。给出用于查询的一台或多台授权服务器的信息（域名） 附加消息 给出了有助于解析程序的附加信息 记录类型 DNS使用两种类型的记录。 询问记录question record：从server获取信息 资源记录resource record: 每个域名都与一个资源记录相关量。服务器数据库包含所有的资源记录，服务器还返回资源记录给客户机 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH26.html":{"url":"computer-network/CH26.html","title":"CH26","keywords":"","body":"CH26 远程登录TELNET Terminal Network 标准TCP/IP协议 使用户能够建立一个到远程系统的连接。本地终端连接到远程系统上。 本地远程登录过程 本地登录 local login 远程 电子邮件 架构 第一种情况 发送方与接收方在同一个系统。 仅需两个UA。 Alice发给Bob Alice运行用户代理程序准备报文，在BOb的邮箱中放下该邮件 第二种情况 二者在两个系统上（邮件域名不同）需要用户代理和报文传输代理（message transfer agent MTA） Alice先发给自己的邮件服务器，使用队列存储报文。 Bob可以用UA查看自己的邮件 两个邮件服务器各需要一个Message Transfer Agent，一个是client,一个是server。 需要两个UA和一对MTA 第三种情况 Alice通过广域网连接自己的邮件服务器， 需要两对MTA Message Transfer Agent 第四种情况 用户代理 UserAgent 是一个软件包（程序），组成、读取、回答和转发报文。 邮件格式 信封 envelope包含发件人和收件人地址 报文： header：发信人，收件人，保温主题及其他信息。 body：读取的真正信息 MIME 电子邮件只能发送NVT 7位 ASCII格式的报文。不用用来发送二进制文件或音频，不用使用某些语言 MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 它是一个互联网标准，扩展了电子邮件标准，使其能够支持： 非ASCII字符文本；非文本格式附件（二进制、声音、图像等）；由多部分（multiple parts）组成的消息体；包含非ASCII字符的头信息（Header information）。 头部 MIME版本 内容-类型 内容-传送-代码 内容-标识符 内容-描述 报文传输代理SMTP Simple Mail Transfer Protocol 发送邮件时，发送方必须有MTA，系统必须有服务器MTA。因特网中，定义MTA客户机和服务器的形式化协议 SMTP在发送方与接收方邮件服务器时间和两个邮件服务器之间使用两次。（两对MTA） 邮件传输阶段 连接建立 邮件传输 连接终止 第三阶段 POP3和IMAP$ 邮件服务器到接收方使用pull协议 文件传输 FTP 使用TCP服务，需要两个TCP连接 数据传输 控制信息 21端口用于控制连接，20用于数据连接 控制连接 数据连接 解决异构问题 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/CH27.html":{"url":"computer-network/CH27.html","title":"CH27","keywords":"","body":"CH27 体系结构 www是一个分布式的客户/服务器服务，客户机用浏览器能够使用服务器提供的服务。提供的服务是分布在许多称为站点的位置上。 url cookies 采用客户端保持状态的方案。在用户端的会话状态存储机制。 WEB文档 静态文档、动态文档、活动文档。 基于文档内容的时间确定分配 静态稳定 基于GGI技术的动态文档 使用服务端脚本的动态文档 使用客户端脚本的活动文档 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/总复习.html":{"url":"computer-network/总复习.html","title":"总复习","keywords":"","body":"《计算机通信与网络》课程总复习知识点 配套《数据通信与网络(Forouzan第四版)》 2021年12月 第一部分 概述 第1章 绪论 数据通信的概念及模型 数据流 连接类型和拓扑结构 网络分类 协议和标准 第2章 网络模型 层次结构、层间接口和封装 OSI参考模型的概念和各层功能 TCP/IP*协议簇和各层的功能 物理地址、逻辑地址和端口地址（何时改变？） 第二部分 物理层和介质 第3章 物理层 数字信号：基带传输、低通通道、宽带传输的概念 传输减损：衰减、失真、噪声和信噪比的概念 数据速率限制：奈奎斯特速率、香农容量定理 性能：带宽、吞吐量、信道利用率、延迟、传播时间、传输时间、排队时间、带宽与延迟的乘积的概念 第4章 数字传输 线路编码：数据元素、信号元素、数据速率、信号速率、最小带宽、最大数据速率、直流分量、自同步 线路编码方案：单极性编码（NRZ）、极性编码（NRZ-L和NRZ-I）、归零码（RZ）、双相码（Manchester和Differential Manchester）、双极性编码（AMI和伪三进制码）、 脉码调制PCM：采样（采样率）、量化等级、量化误差 Delta调制的概念 传输模式：异步传输、同步传输、并行传输、串行传输的概念 第5章 模拟传输 比特率和波特率 数字到模拟转换： ASK的概念及ASK的带宽 FSK的概念及BFSK的带宽 PSK、BPSK、QPSK和QAM的概念 模拟信号调制： AM、FM和PM的概念 AM带宽、FM带宽和PM带宽 第6章 带宽利用 复用：FDM、同步TDM、统计TDM和WDM的概念 数字层次、T1载波、E1载波 波分和码分的概念 扩频：FHSS和DSSS的概念 第三部分 数据链路层 第10章 检错与纠错 差错的类型 块编码 差错检测的方法 纠错的概念与方法：汉明距离、最小汉明距离 线性块编码：线性块编码的距离、简单奇偶校验编码、两维奇偶校验编码、汉明码 循环冗余编码CRC（不包含硬件实现）、CRC的检错能力分析（检测单个位差错、两个独立的位差错、奇数个差错、突发性差错） 校验和及其计算方法 第11章 数据链路控制 组帧 流量控制和差错控制的概念 停止等待ARQ、后退N帧ARQ和选择重发ARQ HDLC 第12章 多路访问 随机访问：纯ALOHA、时隙ALOHA、CSMA、CSMA/CD（最小帧长）、CSMA/CA 受控访问：预约、轮询、令牌环 第13章 有线局域网：以太网 IEEE标准：LLC和MAC 标准以太网的MAC子层：帧格式、MAC地址、最短帧长、编码和解码、10Base5、10 Base 2、10 Base -T、10 Base -F 桥接以太网、交换式以太网、全双工以太网 快速以太网：MAC子层、拓扑结构、100Base -TX、100Base-FX、100Base –T4 千兆以太网：MAC子层、拓扑结构、1000Base -SX、1000Base-LX、1000Base –CX 第14章 无线局域网 WLAN体系结构与IEEE 802.11标准 802.11 MAC子层、帧结构、CSMA/CA* 802.11 物理层、寻址方式、隐蔽终端和暴露终端 第15章 连接局域网、主干网和虚拟局域网 连接设备：无源集线器、中继器、有源集线器、网桥、透明网桥、生成树、二层交换机、路由器、三层交换机（补充）、网关、冲突域与广播域 虚拟局域网的概念及划分方法 第四部分 网络层 第19章 逻辑寻址 IPv4地址：A、B、C、D和E类地址、掩码、子网和超网的概念 子网划分、子网的地址范围、地址聚合 NAT的概念 IPv6地址 第20章 IP协议 IP分组（数据报）的格式 分片(Identification、Flags、Fragmentation offset）、何处分片和重装 MTU IPv6分组格式 下一个头部相关 IPv4到IPv6的过渡 双协议栈 隧道技术 头部转换 第21章 地址映射、差错报告和多播 ARP：ARP的概念、功能、分组格式、封装、4种操作 DHCP的概念 ICMP：ICMP的概念、报文格式、差错报告、Ping* IGMP的基本概念 第22章 传递、转发和路由选择 转发技术与转发过程 路由表、地址聚合和最长掩码匹配 Dijkstra算法和Bellman-Ford* 算法 单播路由协议：AS的概念、域内、域间路由选择协议、RIP协议路由表生成的过程、OSPF协议的原理 多播的概念和多播路由（了解） 第五部分 传输层 第23章 UDP、TCP和SCTP 端口、套接字 UDP协议：UDP协议的概念、数据报结构、校验和的计算、UDP的操作 TCP：TCP的特点与服务、段格式、三次握手（建立连接和拆除连接）、TCP流量控制（信贷滑窗协议）、TCP差错控制 TCP有关字段和序号（SYN、ACK、seq、ack*）、段序号、字节编号 第24章 拥塞控制和服务质量 TCP拥塞控制（慢启动、拥塞避免、拥塞检测） 发送窗口=min（接收窗口rwnd，拥塞窗口cwnd） 第六部分 应用层 第25章 域名系统 DNS*的工作原理 域名空间 通用域、国家域和反向域 域名解析 DNS报文 第26章 远程登录、电子邮件和文件传输 Telnet的基本概念 电子邮件：电子邮件的架构、邮件报文、SMTP和MIME、POP3和IMAP 文件传输：FTP的架构、FTP的连接、FTP的传输方式、FTP的端口 第27章 万维网与超文本传输协议 URL、Cookies的概念 HTTP的概念、报文结构、HTTP操作 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/计网期末试题.html":{"url":"computer-network/计网期末试题.html","title":"期末试题","keywords":"","body":" var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"computer-network/报文、报文段等的区别.html":{"url":"computer-network/报文、报文段等的区别.html","title":"报文、报文段等的区别","keywords":"","body":"报文、报文段等的区别 报文message 应用层的信息分组，是网络中交换与传输的数据单元，也是网络传输的单元。 报文包含了将要发送的完整的数据信息，长短不需一致。 传输过程中会封装成 分组packet 包 帧frame 报文段segment 起始点和目的地都是传输层的信息单元 分组/包packet 分组时网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分，在每个部分的前面加上必要的控制信息组成的首部，有时加上尾部，构成了一个分组，起始和目的地是网络层 数据报datagram 面向无连接的数据传输，工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。通常是起始点和目的地都是用无连接网络服务的网络层的信息单元 帧frame 是数据链路层的传输单元，起始点和目的地都是数据链路层 数据单元data unit 服务数据单元（SDU）、协议数据单元（PDU） var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"about/about.html":{"url":"about/about.html","title":"搭建说明","keywords":"","body":"搭建说明 相关教程 基本结构 https://snowdreams1006.github.io/ 一些问题的解决 mathjax安装问题 使用node10.24.1即可 https://www.piginzoo.com/tech/2021/10/15/gitbook#%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6 行内代码无法使用$\\rightarrow$ https://github.com/yunsean/gitbook-mathjax-url 使用插件 https://www.npmjs.com/package/gitbook-plugin-headscript TOC还没解决 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}