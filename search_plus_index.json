{"./":{"url":"./","title":"简介","keywords":"","body":" xinwuyun的笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch1.html":{"url":"database/ch1.html","title":"CH1","keywords":"","body":"第一章 一、Data Models and Databases 抽象层次 Levels of Abstraction 物理层Phsical Level：描述数据如何存储 逻辑层Logical Level：描述数据库中存储什么数据以及数据间的关系。 物理数据独立性（phicial data indepentdence） 视图层View Level：描述整个数据库的某个部分 例子 定义如下记录 type instructor = record ID: char(5) name: char(20) dept_name: char(20) salary: numberic(8, 2) end; 物理层：instructor记录可能被描述为连续存储位置组成的存储块。 逻辑层：定义了这些记录类型的相互关系 程序设计人员正式在这个抽象层次上使用某种程序设计语言进行工作。 数据库管理员也是在这个抽象层次工作。 视图层：计算机用户看见的是为其屏蔽了数据类型细节的一组应用程序 视图层上定义了数据库的多个视图，数据库用户看到的是这些视图。 提供了防止用户访问数据库的某些部分的安全性机制 二、实例和模式 实例 特定时刻存储在数据库中的信息的集合称作数据库的一个实例。 模式 数据库的总体设计 物理模式 physical schema 物理层描述数据库的设计 逻辑模式 logical schema 在逻辑层描述数据库的设计 视图层模式 有若干种，有时称为子模式（subschema） 描述了数据库的不同视图 逻辑层最重要，物理模式隐藏在逻辑模式下，通常可以轻易被更改应用程序如果不依赖与物理模式，他们就被称为具有物理数据独立性 三、数据模型 data model 是一个 描述数据 数据联系 数据语义 以及一致性约束 的概念工具集合 提供了一种描述 物理层 逻辑层 视图层 的数据库设计的方式 关系模型 rational model 关系模型用表的集合来表示数据和数据间的联系。 实体-联系模型 entity-relationship model ER模型，基于对显示世界的这样一种认识 现实世界由一组称作实体的基本对象以及这些对象间的联系构成。实体是现实世界中可区别于 基于对象的数据模型 object-based model ER模型增加了封装、方法和对象标识等概念后的扩展。 半结构化数据模型 semistructured data model（XML） 允许那些相同类型的数据项含有不同的属性集的数据定义。XML被广泛用来标识半结构化数据。 四、关系数据库 关系数据库包括DML和DDL。 表 所有数据都存放在若干表中 数据操纵语言 DML Data-Manipulation Language DML中设计信息检索的部分称作查询语言（query language）。通常把查询语言和数据操纵语言作为同义词 非过程化的，以几个表作为输入，总是仅返回一个表。 数据定义语言 DDL Data-Defination Language 可以定义表、完整性约束、断言和授权等。 元数据：metadata，关于数据的数据。只能由数据库系统本身来访问和修改 五、Database Design 设计过程 初始阶段：全面刻画预期的数据库 概念设计**conceptual-design**：描述数据以及他们之间的关系 ER模型 规范化算法，将所有属性集所谓输入，生成一组关系表 逻辑设计阶段：将高层的概念模型映射到要使用的数据库系统的实现数据模型上 物理设计阶段指定物理特性，包括文件组织的形式以及内部的存储结构 六、数据库引擎 存储管理器（storage manager） 查询处理器（query processing） 事务管理（transaction manager） 存储管理器 storage manager 存储管理器在数据库中存储的底层数据与应用数据以及向系统提交的查询之间提供接口的部件； 存储管理器负责与文件管理器进行交互，原始数据通过操作系统提供的文件系统存储在磁盘上； 存储管理器将各种DML语句翻译为底层文件系统命令。 存储管理器负责数据库中数据的存储、检索和更新 权限及完整性管理器 事务管理器 文件管理器 缓冲器管理器 实现了几种数据结构 数据文件：数据库自身 数据字典：关于数据库结构的元数据，尤其是数据库模式 索引：针对数据项的快速访问 查询处理器 DDL解释器（DDL interpreter），解释DDL语句并将这些定义记录在数据字典里 DML编译器（DMLcompiler），将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令 一个查询通常可被翻译成多中等价的具有相同结果的执行方案的一种，DML编译器还进行查询优化，从几种选择汇总选出代价最小的一种 查询执行引擎（query evaluation engine），执行由DML编译器产生的低级指令。 事务管理 原子性 atomicity 一致性 consistency 持久性 durability 事务transaction是数据库应用中完成单一逻辑功能的操作集合。 每个事务是一个具有原子性和一致性的单元。我们要求单元不违反任何数据库的一致性约束。但是执行过程中，必要时允许暂时的不一致。 原子性和一致性是恢复管理器recovery manager的职责。 为了保证原子性，失败的事务必须对数据库状态不产生任何影响，数据库必须被恢复到该失败事务开始执行之前的状态。这种情况下数据库系统必须进行故障恢复failure recovery。 并发控制管理器concurrency-control manager，控制并发事务间的相互影响，保证数据一致性 事务管理器transaction manager包括并发控制管理器和恢复管理器 数据库体系结构 数据库架构很大程度上取决于所运行的操作系统 集中式 客户端-服务器的 并行的 分布式的 数据库史 50~60年代 磁带用于数据存储，只能顺序读取。 60年代末~70年代 摆脱了顺序访问的限制，可以将表和数保存在磁盘上。 关系模型和查询数据的非过程化方法出现。关系型数据库诞生 80年代 关系型数据库真正应用，取代了网状和层次型数据库。 程序猿只需要考虑逻辑层的工作。 90年代初 许多厂商推出了并行数据库产品。 90年代 互联网的爆发式发展。数据库系统需要提高事务处理速度和高可靠性，提供对数据的web接口 2010年前 XML兴起。开源数据库系统应用显著增长——PostgreSQL和MySql 至今 用于数据分析的数据库。 按列存储的列存储数据库 高度并行的数据库 分布式数据库 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch2.html":{"url":"database/ch2.html","title":"CH2","keywords":"","body":"第二章 关系模型 [toc] 一、Structure of relational database 关系数据库的结构 关系数据库由表的集合组成，每个表有唯一的名字。 关系——表 元组——行 属性——列 关系实例——一个关系的特定实例 域——属性的取值范围 数据库模式 需要区分数据库模式和数据库实例（database） 前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照。 关系实例的内容经常变化，关系模式不经常变化。 码keys 一个元组的属性值必须能够唯一区分元组。 一个关系中没有两个元组在所有属性上取值相同 超码 superkey 一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地确定一个元组。 形式化描述：设R表示关系r模式中的属性集合，如果R的一个子集K是r的一个超码，则关系r中任意两个不同元组不会在K的所有属性上取值完全相等。 超码中可能包含无关紧要的属性。如果K是一个超码，则K的任意超集也是超码。 最小超码称为候选码 candidate key，他们的任意真子集 主码 primary key 表示被数据库设计者选中，用来在关系中区分不同元组的候选码。 外码 foreign key 一个关系模式$r_1$可能在它的属性中包括另一个关系模式$r_2$的主码。 关系$r_1$也称为外码依赖的参照关系（referencing realtion），$r_2$称为外码的被参照关系（referenced relation）。 参照完整性 referential integrity constraint 要求在参照关系任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值 二、关系查询语言 查询语言（query language）是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化和非过程化的 过程化语言（procedural language） 用户指导系统对数据库执行一系列操作以计算出所需结果。 非过程化语言（nonprocedural language） 用户只需描述所需信息，不用给出获取该信息的具体过程 三、关系运算 关系运算是过程化语言，有如下6个运算 select（选择）：$\\sigma$ project（投影）：$\\pi$ union（并）：$\\cup$ set difference（集合差）：$-$ cartesian product（笛卡尔积）：$\\times$ rename：$\\rho$ select 选择 $\\sigma_{p}(r)$ $p$是选择谓词 \\sigma_{p}(r)=\\{t \\mid t \\in r \\text { and } p(t)\\} project 投影 Union并 按行并 r和s必须有相同的属性 属性的domain必须是compatible可兼容的 笛卡尔积 $r\\times s$ $\\rho$ 四、例子 五、额外操作符 set intersection（集合交） natural join（自然连接） division（除法） 集合交 与union同等级 r \\cap S=\\{t \\mid t \\in r \\wedge t \\in S\\} r \\cap s=r-(r-s)$ 连接 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch3.html":{"url":"database/ch3.html","title":"CH3","keywords":"","body":"第三章 SQL 一、SQL查询语言概览 SQL包含一下部分 数据定义语言（data-defination language，DDL）：提供定义关系模式、删除关系以及修改关系模式的命令 数据操纵语言（data-manipulation language，DML） 插入元祖 删除元组 修改元组 完整性（integrity） DDL包括定义完整性约束的命令 破坏完整性约束的更新是不允许 视图定义（view defination） DDL定义视图的命令 事务控制（transaction control） SQL包括定义事务的开始或结束的命令 嵌入式SQL和动态SQL（embedded SQL and dynamic SQL） Embedded sql and dynamic sql如何嵌入到通用编程语言，如C、C++和java 授权（authorization） DDL包括定义对关系和视图的访问权限命令 基本类型 每种类型都可能包含一个被称作空值的特殊值。 该值可能存在但并不为人所知，可能根本不存在 create table construct create table r(A1D1, A2D2, ..., AnDn, integrity-constraint1, ... integrity-constraintk) integrity constraints完整性约束 not null Primary key($A_1, ..., A_n$) Foreign key($A_m,...,A_n$) references r create table instructor( ID char(5), name varchar(20) not null, dept_name varchar(20), salary varchar(20), salary numeric(8,2), primary key(ID), foreign key(dept_name) references department); primary key自动保证字段为not null Integrity Constraints in Tables表的完整性约束 完整性约束保证数据库的修改不会导致数据一致性的丢失 primary key foreign key [not] null unique default check assertion update insert insert into instructor values(.....) delete delete from student where... drop table alter alter table r add A D A是attribute D是domain alter table r drop A SQL查询的基本结构 结果也是一个关系 执行顺序 select语句 大小写不敏感 \\text { Name } \\equiv N A M E \\equiv \\text { name } 结果的元组重复 allow duplicates in relations as well as in query results. 允许query结果中存在重复元组 force elimination of duplicates, 在select后添加distinct select distinct dept_name from instructor 使用all关键字显示保留重复值 select all dept_name from instructor 星号 asterisk asterisk * 表示all attributes select * from instructor 属性可以是字面值 没有from语句 select '457' 结果是一个一行一列的表，值为'457' 可以给列命名 select '233' as FOO 使用from语句 select 'A' from instructor 结果一列n行（n是instructor表的行数） 每一行的值都会“A” 可以使用算术表达式 select ID, name, salary/12 from instructor 返回的relation中salary属性的值均除以12 可以对该字段进行重命名 select ID, name, salary/12 as monthly_salary where语句 from语句 rename operation select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name = 'Comp.Sci' 自连接例子 find the supervisor of the supervisor of \"Bob\" select S.supervisor from emp_super as T, emp_super as S where T.person = 'Bob' and T.supervisor = S.person like percent%：匹配任意子串 underscore_：匹配任意字符 Find the names of all instructors whose name includes the substring \"dar\" select name from instructor where name like \"%dar%\" 如果匹配字符串“100%” like '100\\%' escape '\\' Esacpe '\\'指定转义字符 是大小写敏感的 排序 select distinct name from instructor order by name 指定顺序逆序 desc 降序 asc 升序 order by name desc 根据多个属性排序 order by dept_nam, name 重复 集合操作 union：并 intersect：交 except：差 上述操作默认消除重复元组，使用union\\intersect\\except all保留重复 集合操作例子 题目：找出最高的工资 找出工资不是最高的instructor的工资 select distinct T.salary from instructor as S, instructor as T where T.salary 用总体的减去上述结果 (select distinct salary from instructor) except (select distinct T.salary from instructor as T, instructor as S where T.salary Null values null表示未知值或不存在的值 任何包含null的数学表达式的结果都是null is null可以用来检查null值 example Find all instructors whose salary is null select name from instructor where salary is null unknown 三个逻辑值 true false unknown 任何与null值进行的比较都返回unknown example：5 null or null = null 对于上述操作，令unknown为true或false，如果得到结果一致，则结果是对应结果，如果结果不一致，则结果是unknown 聚合函数 avg min max sum count group by 找出每个学院教师的平均工资 select dept_name avg(salary) as avg_salary from instructor group by dept_name 注意：在group by中出现的属性，必须在select中出现，不能出现其他属性（除了聚合函数） having语句 找出所有平均工资超过42000的学院 select dept_name, avg(salary) from instructor group by dept_name having avg(salary) > 42000 having语句中是在group by之后进行的 null值和聚合 select sum(salary) from instructor 上述语句忽略空值 如果没有非空值则查询结果是null 除了$count(*)$，所有聚合函数都忽略在被聚合属性上是空值的元组 嵌套子查询 where语句中的嵌套子查询 set成员 set比较 set基数 membership Find courses offered in Fall 2009 and in Spring 2010 select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id in (select course_id from section where semester='Spring' and year = 2010) Find courses offered in Fall 2009 but not in Spring 2010 select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id not in (select course_id from section where semester='Spring' and year=2010); 可以考察更多属性的membership select count(distinct ID) from takes where (course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year from teaches where teaches.ID=10101); comparison——\"some\" 找出收入高于生物学院的instructor select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name='Biology'; 等同于用some select distinct name from instructor where salary > some(select salary from instructor where dept_name='Biology'); comparison——all Comparison——'exists' 当子查询不是空集时，exists返回true 找出选了生物学院的所有课程的学生 select distinct S.ID, S.name from student as S where not exists((select distinct course_id from course where dept_name='Biology') except (select course_id from takes where S.ID=takes.ID)); Comparison——unique 考察子查询结果中是否存在重复元组，是则返回false，否则返回true 找出2009年最多开展一次的课程 select T.course_id from course as T where unique(select S.course_id from course as S where S.course_id=T.course_id and S.year=2009); from子句中的子查询 with语句 with子句提供了定义临时关系的方式，这个临时关系只能在当前语句中使用 例子：找出预算最多的院 with max_budget(value) as (select max(budget) from department) select department.name from deparment, max_budget where department.budget = max_budget.value 例子：找出总收入大于所有院平均总收入的院 with dept_total(dept_name, value) as (select dept_name, sum(salary) from instructor group by dept_name), dept_total_avg(value) as (select avg(salary) from instructor) select dept_name from dept_total, dept_total_avg where dept_total.value > dept_total_avg.value; select中的嵌套子查询 一个语句必须只得到一个值 例子：列出所有department和院中的教师数 select dept_name, (select count(*) from instructor where instructor.dept_name=department.dept_name) as num from department; 如果这个查询返回超过一个元组，则报错。 修改数据库 删除 插入 更新 条件语句 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch4.html":{"url":"database/ch4.html","title":"CH4","keywords":"","body":"CH4 views 某些情况下，不是所有用户都想看到整个逻辑模型。 创建方法 create view v as \"query expression\"是一个合法的SQL表达式，视图名是v Once a veiw is defined, the view name can be used to refer to the virtual relation that the view generates. A view defination causes the saving of an expression; the expression is substituted into queries using the view. 使用了视图的queris中，view会替换为expression create view faculty as select ID, name, dept_name from insturctor create view departments_total_salary(dept_name, total_salary) as select dept_name, sum(salary) from instructor group by dept_name; 使用view定义其他view create view physics_fall_2009 as select course.course_id, sec_id, building, room_number from course, section where course.course_id = section.course_id and course.dept_name='Physics' and section.semester='Fall' and section.year='2009' 使用上面的view创建其他view create view physics_fall_2009_watson as select course_id, room_number from physics_fall_2009 where building='Watson'; view展开为如下： create view physics_fall_2009_watson as (select course_id, room_number from (select course.course_id, building, room_number from course, section where course.course_id=section.section_id and section.semester='Fall' and section.year='2009') where building='watson'); view更新 向faculty视图中添加值 insert into faculty values('30765', 'Green', 'Music') 某些更新无法uniquely翻译 create view instructor_info as select ID, name, building from instructor, department where instructor.dept_name=department.dept_name 插入一行 insert into instructor_info values('1000', 'wzr', 'watson'); 如果一个建筑中有多个department，就无法确定这个老师是哪个院的，并且如果该建筑中没有department。 满足如下条件view可以 From语句中只涉及一个关系 select语句只包含属性名，不包含任何表达式、聚合函数和distinct 任何没有在select中列出的属性都可以设为null 没有group by和having 物化视图 Materialized Views 允许存储视图关系（物理上） 如果视图中使用的关系更新了，物化视图的结果就会过时 需要通过更新视图来维护视图 alter table table-name add constraint Integrity Constraints完整性约束 not null primary key unique check(P)，P是个谓语 not null name varchar(20) not null, budget numberic(12, 2) not null unique($A_1, A_2, ..., A_m$) 表示属性集A_1, A_2, ..., A_m构成候选码 与主键不同，候选码可以使null（控制不等于其他任何值） check子句 check(P)，关系中每个元组都必须满足谓词P check ( semester in ('Fall', 'Winter', 'Spring', 'Summer')) 参照完整性 referential integrity 保证一个关系中给定属性集上的取值也在另一个关系的特定属性集的取值中出现称为 referential integrity 令关系$r_1$和$r_2$的属性集分别为$R_1$和$R_2$，主码分别为$K_1$和$K_2$。如果$r_2$任意元组$t_2$，均存在$r_1$中元组$t_1$使得$t_1.K_1=t_2.\\alpha$，我们称$R_2$的子集$\\alpha$为参照关系$r_1$中$K_1$的外码（foreign key） 这种关系称为参照完整性约束（referential-integrity constraint）或子集依赖（subset dependency）。 $r_2$中$\\alpha$上的取值集合必须是$r_1$中$K_1$上的取值集合的子集 $\\alpha$和$K_1$必须是相容的属性集 $\\alpha$ 等于$K_1$ 二者属性数相同，且对应属性的类型必须相容 create table course( course_id char(5) primary key, title varchar(20), dept_name varchar(20) references department ) create table course ( ... dept_name varchar(20), foreign key(dept_name) references department on delete cascade on update cascade, ... ) 级联删除on delete cascade：如果删除department中的元组导致参照完整性被违反，则删除不被系统拒绝，course中参照了被删除元组的元组被删除 在插入一个人之前先插入爸爸和妈妈 先把爸爸和妈妈设为null，插入所有人之后在设置爸爸和妈妈 延迟约束检查 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch5.html":{"url":"database/ch5.html","title":"CH5","keywords":"","body":"第五章 高级SQL 有两个重点 使用程序设计语言访问数据库 如何允许数据库与普通程序交互，C还是JAVA 如何处理SQL和C、JAVA中数据类型的不同 如何处理被很多短时进程共享的数据库连接 三种不同类型的可编程SQL embedded sql API ODBC JDBC procedure SQL 函数和过程 Functions and Procedural Constructs 过程 Procedure 使用create procedure创建，使用call语句调用 procedure没有返回值但是可以通过修改参数供调用者稍后检查，它也可以生成结果集。 参数 proc_parameter: [IN|OUT|INOUT] param_name type 每个参数默认是IN参数，可以在参数名前面指定IN OUT 这个关键字（IN|OUT|INOUT）只对PROCEDURE有效 对于FUNCTION，参数都是IN，过程中有可能会改变这些值，但是修改不会对调用者产生影响 OUT参数会将值传送到调用者 INOUT参数由调用者进行初始化，传送一个值到procedure再返回给调用者，对参数的任何修改对调用者都会生效。 delimiter命令，设定分隔符。 delimiter //表示之后如果一行命令以//结束，则执行命令，否则不执行 函数 Function 使用create function使用起来类似内置函数。可以在表达式中调用，它会在表达式执行过程中返回一个值。 定义一个函数，返回一个院内教师人数 create function dept_count(dept_name varchar(20)) returns integer begin declear d_count integer; select count(*) into d_count from instructor where instructor.dept_name=dept_name return d_count; end 内容组成 复合语句：begin...end 可能包含多个SQL语句 returns——指出返回值的类型 return——指出返回值，作为函数调用的结果 SOL 函数实际上是泛化的参数化视图 BEGIN [statement_list] END dept_countfunction也可以procudure代替。 declare statement local variables conditions and handlers cursors declare var_name [, var_name] ... type[DEFAULT value] set variable = expr [, variable=expr]... create procedure sql (x varchar(5)) begin declear xname varchar(5) default 'bob'; declear newname varchar(5); declear xid INT; select xname, id INTO newname, xid from table1 where xname = xname; select newname; end; 流程控制语句 IF CASE LOOP ITERATE LEAVE LOOP WHILE REPEAT RETURN if create funtion xxxx (n INT, m, INT) returns varchar(50) begin declare s varchar(50); if n=m then set s = 'equal'; else if n>m then set s = 'greate'; else set s='less'; end if; end if; set s=concat(n, ' ', s, ' ', m, '.'); return s; end// delimiter ; case语句 case case_value when when_value then statement_list [when when_value then statement_list] [else statement_list] end case 或 case when search_condition then statement_list [when search_condition then statement_list] [else statement_list] end case delimiter | create procedure p() begin declare v int default 1; case v when 2 then select v; when 3 then select 0; else begin end; end case; | delimiter ; LOOP LOOP statement_list END LOOP ITERATE 只能在LOOP REPEAT和WHILE statements中使用，表示\"Start the loop again\" LEAVE 离开循环。 例子 create procedure doiterate(p1 INT) BEGIN l1: loop set p1 = p1 + 1; if p1 while [begin_label]while search_condition do statement_list end while end_label create procedure dowhile() begin declare v1 int default 5; l1: while v1 > 0 do ... set v1 = v1 - 1; end while l1; end repeat create procedure dorepeat(p1 INT) begin set @x = 0; l1: repeat set @x = @x + 1; until @x > p1 end repeat l1; end; cursor游标 mysql支持在存储程序中使用游标，只能单向遍历 create procedure curdemo() begin declare done int default false; declare a char(6); declare b, c int; declare cur1 cursor for select id, data from test.t1; declare cur2 cursor for select i from test.t2; declare continue handler for NOT FOUND SET done = truel open cur1; open cur2; read_loop: LOOP fetch cur1 into a, b; fetch cur2 into c; if done then leave read_loop; end if; if b create procedure curdemo() begin declare dont int default false; declare a char(16); -- 事先声明 declare b, c int; declare cur1 cursor for select id, data from test.t1; declare cur2 cursor for select i from test.t2; declare continue handler for not found set done = true; open cur1; open cur2; read_loop: loop fetch cur1 into a, b; fetch cur2 into c; if done then leave read_loop; end if; if b Condition handling 可以定义handlers，来应对诸如warning、exceptions或者特殊的条件，比如特定错误码 可以给特定条件设定名字并在handlers中引用 declare .. condition statement declare .. handler statement declare condition_name condition for condition_value declare continue handler for 1051 begin -- body of handler end; 通过声明条件的名字，handler的目的是更容易看到 declare condition declare no_such_table condition for 1051; declare continue handler for no_such_table; begin -- body of handler end; declare handler DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement handler_action: { CONTINUE | EXIT | UNDO } condition_value: { mysql_error_code | SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING | NOT FOUND | SQLEXCEPTION } create procedure handlerdemo() begin declare continue handler for sqlstate '23000' set @x2 = 1; set @x = 1; insert into test.t values(1); set @x = 2; insert into test.t values(1); set @x = 3; end triggers event insert delete update create trigger trigger-name trigger-time trigger-event on table-name for each row trigger-action trigger-time$\\in${BEFORE, AFTER} trigger-event$\\in${INSERT, DELETE, UPDATE} 两个值 old row：for deletes and updates new row：for inserts and updates 创建一个触发器，当雇佣新的雇员时更新deparment的总收入 delimiter | create trigger udpate_salary after insert on employee for each row begin if new.dno is not null then update deptsal set totalsalary = totalsalary + new.salary where dnumber = new.dno; end | delimiter ; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch8.html":{"url":"database/ch8.html","title":"CH8","keywords":"","body":"CH8 好的设计的特点Features of Good Relational Design A combined schema without repetion 没有重复的组合模式 更小的模式 对于inst_dept。decompose it into instructor and department dept_name是候选码 表示为函数依赖 dept_name → building, budget 在inst_dept中，因为dept_name不是候选码，building和budget可能会出现重复 不是所有的分解都是好的 lossy decomposition有损分解 如果有多个同名的kim，则无法分辨 lossless decomposition 无损分解 ⚛原子域和第一范式1NF domain is atomic if its elements are considered to be indivisible units 如果域中的元素是不可分割的称域为原子域 如果R的所有属性的域都是原子的，则称该关系模式是第一范式（first normal form, 1NF） goal目的——为下列内容设计一个理论 决定关系R是否是好的范式 当R不是good form时，把它分解成{$R_1, R_2, R_3...$}，其中 每个关系都是good form 分解必须是无损连接分解 理论基于 函数依赖 多值依赖 Functional Dependency Theory 合法关系集的约束 要求关系中有候选码 函数依赖是key的泛化 R是个关系模式 Relation Schema \\alpha \\subseteq R \\text { and } \\beta \\subseteq R 与码的关系 key 当$K\\rightarrow R$时，$K$是超码。 当$K\\rightarrow R$，并且不存在$\\alpha \\subset K, \\alpha \\rightarrow R$ 不存在K的子集，使得函数依赖$\\alpha \\rightarrow R$成立 Function Dependencies允许我们表达不能使用超码表达的约束 考虑如下模式 inst_dept(ID, name, salary, dept_name, building, budget) 使用函数依赖表示 $dept_name\\rightarrow building \\text{ } and \\text{ } ID\\rightarrow building$ we use funcional dependencies to 实例：判定关系的实例是否satisfies给定函数依赖集F satisfies：模式r满足函数依赖集F 模式：说明合法关系集上的约束。如果模式R上满足函数依赖集F的关系，则F在r(R)上成立 注意：一个关系模式的实例可能satisfy一个函数依赖即使这个函数依赖在模式上并不成立。 平凡trivial函数依赖 如果一个函数依赖在一个关系的所有实例上都成立，则它是平凡的 ID, name \\rightarrow ID \\\\ name \\rightarrow name 函数依赖集闭包 closure of a set of functional dependencies 给定函数依赖集F，可以推断出一些其他的函数依赖也成立 例如 $if \\; A \\rightarrow B \\; and \\; B \\rightarrow C$ 可以推出$A \\rightarrow C$ 能够从给定函数依赖集F推导出的所有函数依赖是F的闭包（closure） 写作$F^+$ $F^+$是F的超集 BCNF范式 消除所有基于函数依赖能够发现的冗余 具有函数依赖集F的关系模式R属于BCNF的条件是，对$F^+$中所有函数依赖$\\alpha \\rightarrow \\beta$，下列至少一项成立 是平凡的函数依赖 或者$\\alpha$是超码 数据库属于BCNF的条件是，构成该设计的所有关系模式都属于BCNF 将一个模式分解为BCNF 假设我们有一个关系模式R和非平凡函数依赖，不满足BCNF decompose it into $(\\alpha \\cup \\beta)$ $R-(\\beta - \\alpha)$ BCNF和依赖保留 Dependency Preservation 依赖保留，有时我们希望进行BCNF分解后，某些依赖仍然保留。 但是往往BCNF和依赖保留不能两全。 所以我们提出3NF，它比BCNF更弱。 3NF，第三范式 BCNF基础上再加一个条件 $\\alpha \\rightarrow \\beta$是一个平凡trivial的函数依赖 $\\alpha$是R的一个超码 $\\beta - \\alpha$中的每个属性都包含于R的一个候选码中 如果R满足BCNF则，R满足3NF 能确保每个模式都有保持依赖的函数依赖的3NF分解 规范化的goal 函数依赖理论 closure of a set of functional dependencies 逻辑蕴含 给定关系模式r(R)，如果r(R)的每一个满足F的实例也满足f，则R上的函数依赖f被r上的函数依赖集F逻辑蕴含 函数依赖集F的闭包是$F^+$ 我们可以通过反复使用 reflexivity自反律if $\\beta \\subseteq\\alpha$则$\\alpha \\rightarrow \\beta $ augmentation增广律：如果$\\alpha \\rightarrow \\beta$，则$\\gamma \\alpha\\rightarrow\\gamma\\beta$ transitivity传递律：如果$\\alpha \\rightarrow \\beta$并且$\\beta\\rightarrow\\gamma$则$\\alpha\\rightarrow\\gamma$ union合并律：如果$\\alpha \\rightarrow \\beta$并且$\\alpha \\rightarrow \\gamma$，则$\\alpha \\rightarrow \\beta \\gamma$ decomposition分解率：union逆命题 pseudotransitivity伪传递律：如果$\\alpha \\rightarrow \\beta$并且$\\gamma \\beta \\rightarrow \\delta$则$\\alpha \\gamma \\rightarrow \\delta$ 属性集的闭包 如果$\\alpha \\rightarrow B$，我们称属性B被$\\alpha$函数确定（functionally determine)。 要判断集合$\\alpha$是否是超码，需要设计一个算法，用于计算被$\\alpha$函数确定的属性集。 先判断是不是超码 再判断是不是候选码 用途 判断超码：先求$\\alpha^+$，看看是否包含R的所有属性 判断函数依赖是否holds 对于$\\alpha \\rightarrow \\beta$，check $\\alpha^+$中是否有$\\beta$即可 另一种计算$F^+$的方法，对任意$\\gamma \\subseteq R$找出$\\gamma^+$，对任意$S\\subseteq \\gamma^+$，可以输出一个函数依赖$\\gamma \\rightarrow S$ 正则覆盖 canonical cover 无关属性 extraneous attributes 考虑$\\alpha \\rightarrow \\beta$ in F 如果$A \\in \\alpha$，并且F逻辑蕴含$(F-{\\alpha \\rightarrow \\beta}) \\cup{(\\alpha-A) \\rightarrow \\beta}$ 如果$A\\in\\beta$，并且F逻辑蕴含$(F-{\\alpha \\rightarrow \\beta}) \\cup{\\alpha \\rightarrow (\\beta-A)}$ 则A是无关的 判断一个属性是否无关extraneous（使用属性集闭包） 对于F中的$\\alpha\\rightarrow\\beta$是否存在无关属性 $A\\in\\alpha$ 计算$({\\alpha}-A)^+$，使用F 判断其是否包含$\\beta$，有则A是无关属性 $A\\in \\beta$ 计算$\\alpha^+$，使用$\\mathrm{F}^{\\prime}=(F-{\\alpha \\rightarrow \\beta}) \\cup{\\alpha \\rightarrow(\\beta-A)}$ 判断其是否包含A，不包含则A是无关属性 正则覆盖canoncial cover $F_c$是F的正则覆盖，当 F逻辑蕴含Fc Fc逻辑蕴含F Fc中的函数依赖不包含无关属性 Fc中的每个函数依赖的左边都是唯一的。 算法 适用union rule合并dependency 对剩下的去除无关属性 算法结束后，可能union rule需要再次适用。 无损分解 lossless decomposition 用关系代数说明 对于$R=(R_1, R_2)$，我们要求 r=\\prod_{R 1}(r) \\bowtie \\prod_{R 2}(r) $R_1$和$R_2$是属性集，可能有共同的属性 $\\bowtie$是自然连接 这样令R1和R2是R的分解，没有信息损失，该分解是无损分解 用函数依赖说明 如果以下函数任意一个属于$F^+$，则是无损分解 R_1 \\cap R_2 \\rightarrow R_1 \\\\ R_1 \\cap R_2 \\rightarrow R_2 也就是分解后一方含有另一方的超码 超码可以用属性集闭包判断 example 保持依赖 dependency perservation n个R，$R_i$的函数依赖集是$F_i$，如果 \\left(F_{1} \\cup F_{2} \\cup \\ldots \\cup F_{\\mathrm{n}}\\right)^{+}=F^{+} 则分解是依赖保留的 算法 分别对F中的函数依赖使用如下算法 这里的属性闭包是F下的 example 判断BCNF BCNF分解 3NF分解 BCNF不是依赖保持的 检测违反函数依赖的效率很重要 解决方法 定义一个更弱的范式 允许一定冗余 函数依赖可以在单独的关系中检验不用计算连接 design goals 关系型数据库设计 BCNF 无损分解 lossless join dependency preservation 如果不能达到，接收如下之一 缺少函数依赖 3NF var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/ch14.html":{"url":"database/ch14.html","title":"CH14","keywords":"","body":"数据库第十四章 Transaction concept 一个transaction是一个程序执行的单元unit， sql语句集 存储过程 由高级程序设计语言初始化 由begin transaction和end transaction分隔 example ACID properties Atomcity原子性：事务的所有操作在数据库要么全部正确执行，要么完全不反映 Consistency一致性：隔离执行事务时，保持数据库的一致性 Isolation隔离性：多个事务可能并发执行事务之间感受不到其他事务的并发执行， Durability持久性：一个事务成功后，对数据库的改变必须是永久的 事务状态 Active: 初始状态，事务执行时保持这种状态 Partially committed: 最后一条语句结束后的状态 Failed: 发现正常的执行不能继续后 Aborted:中止的 事务回滚并且数据库已经恢复到事务开始之前的状态 出现这个状态之后，有两个选择 重启事务 kill the transaction Committed: 成功完成后。 并发执行 Concurrent Executions 系统允许多个事务并行 处理器和磁盘利用率的提高，使得事务吞吐率提高 等待时间减少：短事务不必等待长事务 并发控制机制 concurrency control schemes 控制事务之间的交互，防止他们破坏数据库的一致性 调度 schedules schedule——表示指令在系统中执行的时间顺序 一个事务集的调度必须包含这些食物的所有指令 必须保持指令在各个事务中出现的顺序 一个成功完全执行的事务会在最后一条指令后执行一个commit指令 执行失败的事务会在最后一条指令后执行一条abort指令 使用的符号 Database由object(X, Y, Z)组成， Tranactions标记为$T_1, T_2$ 每个transaction在主存中包含局部变量集（其他事务不可访问） 每个事务可以用read()和write()访问数据库 read()命令将数据库object读取到局部变量中 write()命令可以将局部变量写入数据库 Local varibale for read() & write() will not be shown if the context is clear, or if it is unimpoertant 对objects的操作和计算智只能在局部变量上进行，比如，X=X+1不对，但是a1 = a1 + 1可以。 某些情况下，局部操作不展示 Serializable schedule 考虑两个事务 财产转移 利润 对于串行调度serial schedules 如果dividend之前进行transfer X：$100 \\rightarrow 50 \\rightarrow 50.5$ Y: $200 \\rightarrow 250 \\rightarrow 252.5$ transfer之前dividend X：$100\\rightarrow 101 \\rightarrow 50.5$ Y: $200 \\rightarrow 202 \\rightarrow 252$ 两种情况下，$X+Y=300$ 但是如果按照如下方式调度 这种情况下 $X: 100\\rightarrow 50 \\rightarrow 50.5$ Y: $200\\rightarrow 202\\rightarrow 252$ X+Y=302.5 什么造成了上面的问题 资源竞争？ 交叉执行？ 可串行化 serializable 并发执行中，通过保证所执行的任何调度的效果都与没有并发执行的调度效果一样，我们可以确保数据库的一致性。 调度应在某种意义张等价于一个串行调度 四种情形 考虑两条连续指令I,J。 I=read(Q), J=read(Q) 次序可交换，无论怎么读值都一样 I=read(Q),J=write(Q) 不可交换 I=write(Q), J=read(Q) 不可交换 I=write(Q), J=write(Q) 不可交换 总结 只有在两条指令都是读的情况下，执行顺序才无关紧要。 confict 当两条指令在相同数据项上操作，且其中存在write指令，则两个指令是conflict的 考虑之前的调度 尝试对指令执行次序进行交换 （4）指令可以逐步与（i，ii, iii）交换，直到 （5）（6）指令思路相同，（5）与（i，ii，iii）均不冲突，所以可以移动到i之前执行 再看这个调度 （3）无法与i交换；4无法与vi交换 所以不可串行化 总结 一个调度如果可以转变为串行调度则是好的调度（可以达到隔离性） 反之，则不好 冲突可串行化conflict serializable 若一个调度S与一个串行调度冲突等价，则称调度S是冲突可串行化的 优先图 precedence graph 点是事务的有向图 边的含义 $T_i\\rightarrow T_j$表示一下三个条件之一 i写j读：$T_j$执行read(Q)之前$T_i$执行write(Q) i读j写：$T_j$执行write(Q)之前$T_i$执行read(Q) i写j写 如果存在边$T_i\\rightarrow T_j$，则任何等价于S的调度$S^{\\prime}$中，$T_i$必出现在$T_j$之前 冲突可串行化的判断 当且仅当优先图没有环时，调度是冲突可串行化的。因此要判定冲突可串行化，需要构造优先图并调用一个环检测算法。 serializability order串行化顺序 可以通过拓扑排序（topological sorting）得到。 由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。 选择一个入度为0的顶点并输出之； 从网中删除此顶点及所有出边 一般可以获得多个线性顺序。 该调度不可串行化 事务隔离性和原子性 可恢复调度recoverable schedule 如果事务$T_j$读取了前序事务$T_i$写入的数据，那么$T_i$的commit操作必须在$T_j$的commit之前出现 例如 如果$T_8$需要abort，$T_9$将已经读了A并且已经提交无法取消。所以该调度属于不可恢复调度 级联回滚 cascading rollbacks 单个事务失败会导致一系列事务回滚。考虑如下事务，假设还没有事务已经commit 如果$T_{10}$失败了，则T11和T12都要回滚 这样有可能导致大量工作的回滚。 无级联调度 cascadeless schedule 对每对事务$T_i$和$T_j$，如果j读取了i写的数据项，则i应该在j的读操作之前commit。 容易验证，每个无级联调度也都是可恢复的调度 Concurrency control并发控制 数据库提供了一种机制保证所有可能的调度都满足 冲突可串行化 可恢复并且最好是无级联的 同一时刻只有一个事务可以执行的策略无法实现高并发性 并发控制机制在它们允许的并发量和它们产生的开销之间进行权衡 在调度执行之后检验冲突可串行化已经晚了 目标：提出能够保证可串行化的并发控制协议 低等级的一致性 某些应用允许一定的低一致性，他们允许非串行的调度 一个read-only的事务，他试图获取所有账户总余额的近似值 为查询优化计算的数据库统计信息可以是近似的 用精度换性能 事务隔离性级别 可串行化 sericalizable 默认的 可重复读的 Repeatable read 只允许读取已提交的数据。 一个事务两次读取一个数据项期间，其他事务不能更新该数据。该事务不要求与其他事务可串行化。 已提交读 Read committed 只允许读已提交的数据，但不要求可重复读。事务两次读取同一数据期间可能数据已经被修改并提交 未提交读 read uncommitted 允许度未提交的数据，最低级的。 都不允许dirty write 即如果一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作 某些数据库并不保证默认可串行化 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"database/CH15.html":{"url":"database/CH15.html","title":"CH15 并发控制","keywords":"","body":"数据库第十五章 Lock-based protocol lock 锁是一种控制对数据项并发访问的机制 数据项可以在两种模式下被锁 排他的exclusive(X)mode：如果事务T获得了数据项Q上的排它锁，可以读写 共享的shared：如果事务T获得了数据项Q上的共享锁，则T可读但是不能写 程序猿向并发控制管理器concurrency-control manager发出锁请求。事务只有在请求得到授权后才能继续 锁相容性矩阵 lock-compatibility A transaction may be granted a lock on an item if the requested lock is compatible with locks already held on the item by other transactions. 任何时候，一个数据项可以同时使用任意数量的共享锁 此后的排它锁请求必须一直等到所有共享锁释放 当有X锁时，不能再使用更多的任何锁 如果不能授予锁， 发送请求的事务就等待，直到所有其他事务使用的不相容的锁被释放掉，才能授予该锁 例子 展示A+B 上述方法不足以保证可串行化。如果A和B在ulock(A)和lock-s(B)之间被修改了，则展示出的和会不正确 locking protocol是所有事务在请求和释放锁时遵守的规则集 locking protocol限定了可能的调度集 自动获取锁Automatic Acquisition of Locks 事务$T_i$处理标准 read/write指令时无需显式使用锁调用指令 read(D) if Ti has a lock on D then read(D) else begin if necessary wait until no other transaction has a lock-X on D // 这里只需要确定其他事务没有X锁就行，自己可以有 grant Ti a lock-S on D read(D) end write(D) if Ti has a lock-X on D then write(D) else begin if necessary wait until no other transaction has a lock on D if Ti has a lock-S on D then upgrade lock on D to lock-X else grant Ti a lock-X on D 所有锁在commit或abort后都释放 The two-phase lockign protocol两阶段锁协议 这个锁协议保证了冲突可串行调度 增长阶段 growing phase 缩减阶段 shrinking phase Deadlocks 考虑如下部分调度 不难看出，最后$T_3$和$T_4$都不能继续执行了。 为了进行下去，$T_3$和$T_4$中的一个应该回滚令其锁释放 两阶段锁无法保证无死锁 饥饿 例如：某事务可能在等待某X-lock请求，但是一系列其他事务不断被授予S-lock，这个事务一直得不到X-lock 并发控制管理器可以designed to prevent starvation 大多数封锁协议中存在潜在死锁 当一个死锁发生时，有可能会发生级联回滚 两阶段锁也有可能会发生级联回滚。为了避免，使用strict two-phase locking一个事务必须持有所有的X-lock，直到commit/aborts Rigorous two-phase locking：事务的所有锁都要一直持有，直到commit/abort 锁的实现 lock manager可以实现为一个进程，从事务接收消息并反馈消息。 针对锁请求消息返回 授予锁消息 事务回滚消息 lock manager维护一个lock table来记录被授予的锁和待办的锁 锁表通常实现为内存中的哈希表，索引以被上锁的数据项的名字作为索引项 死锁处理 定义 如果有一个事务集，其中的所有事务都在等待另一个该事务集中的事务，那么该系统死锁 死锁预防 deadlock prevention 死锁预防协议保证系统永远不会进入死锁状态。例如 要求事务在执行前，对所有数据项上锁（预声明） 有两个缺点 事务开始前通常很难预支哪些数据需要封锁 数据项使用率低，有可能许多数据项长时间封锁却用不到 通过对加锁请求进行排序，偏序 每当有可能导致死锁时，进行事务回滚而不是等待加锁 wait-die策略——非抢占式 当事务Ti申请的数据项当前被Tj持有， 仅当Ti时间戳小于Tj的时间戳时，Ti等待， 否则Ti回滚。 wound-wait策略——抢占式 当事务$T_i$申请的数据项当前被$T_j$持有 $T_i$的时间戳大于$T_j$的时间戳时，$T_i$等待。 否则，$T_j$回滚 这两种方法均会发生不必要的回滚 锁超时 lock timeout 申请锁的事务至多当代一段给定的时间若此期间未授予锁，则该事务超时，回滚并重启。 死锁不可能发生 实现简单，但是有可能发生饥饿，不容易确定合适的超时时间 死锁的检测和恢复 如果系统不能保证不产生死锁，则系统必须采用检测和恢复机制。 wait-for等待图 死锁可以用等待图精确描述，由G=(V,E)组成 V：点集，对应所有事务 E：边集 如果存在$T_i \\rightarrow T_j$成立，则表示$T_i$在等待$T_j$释放数据项 如果等待图有环，则系统处于死锁。必须使用死锁检测算法来寻找环。 检测到死锁后 某些事务回滚，选一个代价最低的作为受害者 回滚多少 Total rollback，abort and restart 更高效的做法：只回滚需要的的距离 如果某个事务总是称为受害者，则会出现饥饿 将回滚的次数作为代价的考量来避免饥饿。 基于时间戳的协议 时间戳 对系统中每个事务$T_i$，把唯一一个时间戳和它相联系。此时间戳记为TS(Ti)。 两种方法 使用系统时钟（system lock）作为时间戳 使用逻辑计数器（logical counter）作为时间戳，每赋予一个时间戳，计数器增加计数，事务的时间戳等于该事务进入系统时的计数器值 时间戳决定了串行化顺序 每个数据项与两个时间戳值相关联 W-timestamp表示成功执行write(Q)的所有事务的最大时间戳 R-timestamp表示成功执行read(Q)的所有事务的最大时间戳 时间戳排序协议 保证任何有冲突的read和write操作按时间戳顺序执行。 $T_i$发出read(Q) 若$TS(T_i) 若$TS(T_i)\\geq W-timestamp(Q)$，则执行read操作，R-timestamp(Q)设置为它与TS(Ti)的最大值 $T_i$发出write(Q) 若$TS(T_i) 若$TS(T_i) 其他情况下，系统继续执行，将$W-timestamp(Q)$设置为$TS(T_i)$ 回滚后，Ti被系统赋予新的时间戳 Thomas写规则 多版本机制 multiversion schemes 时间戳版本 多版本机制保留老版本的数据项来提高并发性 多版本时间戳排序 多版本两阶段锁协议 每个成功的write都会导致数据项的新版本 使用时间戳来标记版本 不保证无级联性和可恢复性 两阶段锁 对只读事务和更新事务加以区分 更新事务执行强两段锁协议，即持有他们直到事务结束。因此，他们可以按提交的次序串行化。数据项的每个版本有一个时间戳（ts-counter），这个计数器在提交处理时增加计数。 只读事务，开始执行前数据库系统读取ts-counter的当前值来作为该事务的时间戳。只读事务执行时按照多版本时间戳排序协议。因此Ti发出read（Q)时，返回值是小于TS(Ti)的最大时间戳版本的内容。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"about/about.html":{"url":"about/about.html","title":"搭建说明","keywords":"","body":"搭建说明 相关教程 基本结构 https://snowdreams1006.github.io/ 一些问题的解决 mathjax安装问题 使用node10.24.1即可 https://www.piginzoo.com/tech/2021/10/15/gitbook#%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6 行内代码无法使用$\\rightarrow$ https://github.com/yunsean/gitbook-mathjax-url 使用插件 https://www.npmjs.com/package/gitbook-plugin-headscript TOC还没解决 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}